(()=>{"use strict";var t,e,s,r,i,o,a={99497:(t,e,s)=>{s.a(t,(async(t,e)=>{try{var r=s(82671),i=s(69704),o=s(46348);(new(s(37106).J)).init(),await(0,r.V)(),(0,o.A)(),(0,i.A)(),e()}catch(t){e(t)}}),1)},37106:(t,e,s)=>{s.d(e,{J:()=>fe});var r=s(30729),i=s(93693);class o{chunkDepth=16;chunkWidth=16;minHeight=60;worldHeight=256;noiseHeight=120;waterHeight=60;noise;brush;init(t){this.noise=t.noise,this.brush=t.brush}}const a=(t=[-1,1],e=[-1,1],s=[-1,1],r=[-10,-10],i=[-1,1],o=!1,a=!1,n=!1,d=!0,l=!1,h=!1)=>({temperature:t,moisture:e,elevation:s,river:r,mod:i,hardLimitMoisture:o,hardLimitTemperature:a,hardLimitElevation:n,hardLimitRiver:d,hardLimitMod:l,excludeRiver:h}),n=(t,e)=>e.temperature[0]<=t[0]&&e.temperature[0]>=t[1],d=(t,e)=>e.moisture[0]<=t[1]&&e.moisture[1]>=t[1],l=(t,e)=>e.elevation[0]<=t[2]&&e.elevation[1]>=t[2],h=(t,e)=>{let s=0,r=!1,i=0;if(!e.hardLimitTemperature||e.hardLimitTemperature&&n(t,e)){const r=(e.temperature[1]+e.temperature[0])/2;s+=1-Math.abs((t[0]-r)/(e.temperature[1]-e.temperature[0])),i++}else e.hardLimitTemperature&&!n(t,e)&&(r=!0);if(!e.hardLimitMoisture||e.hardLimitMoisture&&d(t,e)){const r=(e.moisture[1]+e.moisture[0])/2;s+=1-Math.abs((t[1]-r)/(e.moisture[1]-e.moisture[0])),i++}else e.hardLimitMoisture&&!d(t,e)&&(r=!0);if(!e.hardLimitElevation||e.hardLimitElevation&&l(t,e)){const r=(e.elevation[1]+e.elevation[0])/2;s+=1-Math.abs((t[2]-r)/(e.elevation[1]-e.elevation[0])),i++}else e.hardLimitElevation&&l(t,e)&&(r=!0);if(e.river[1]>0)if(!e.hardLimitRiver||e.hardLimitRiver&&((t,e)=>e.river[0]<=t[3]&&e.river[1]>=t[3])(t,e)){const r=(e.river[1]+e.river[0])/2;s+=1-Math.abs((t[3]-r)/(e.river[1]-e.river[0])),i++}else e.hardLimitRiver&&(r=!0);if(e.mod[1]>0&&void 0!==t[4])if(!e.hardLimitMod||e.hardLimitMod&&((t,e)=>e.mod[0]<=t[4]&&e.mod[1]>=t[4])(t,e)){const r=(e.mod[1]+e.mod[0])/2;s+=1-Math.abs((t[4]-r)/(e.mod[1]-e.mod[0])),i++}else e.hardLimitMod&&(r=!0);return r?0:s/(i||1)};class c{static _biomeTypes=new Map;static _biomes=new Map;static _caveCarver=new Map;static registerBiomes(...t){t.forEach((t=>this._biomes.set(t.data.id,t)))}static getBiome(t){const e=this._biomes.get(t);if(!e)throw new Error(`The biome with id ${t} does not exist.`);return e}static registerBiomeTypes(...t){t.forEach((t=>this._biomeTypes.set(t.data.id,t)))}static getBiomeType(t){const e=this._biomeTypes.get(t);if(!e)throw new Error(`The biome type with id ${t} does not exist.`);return e}static registerCaveCarver(...t){t.forEach((t=>this._caveCarver.set(t.data.id,t)))}static getCaveCarver(t){const e=this._caveCarver.get(t);if(!e)throw new Error(`The cave carver with id ${t} does not exist.`);return e}}class u{nodes;constructor(t){this.nodes=t}}const g=2**32;class f extends u{static data={id:"valley"};getCarved(t,e,s){const r=500;e+=1e5;let i=t+200*this.nodes.noise.detailNoise((t-g+1e5)/r,(e-g+1e5)/r,(s-g+1e5)/r),o=e+200*this.nodes.noise.detailNoise((t-g+1e5)/r,(e-g-1e5)/r,(s-g+1e5)/r),a=s+200*this.nodes.noise.detailNoise((t-g-1e5)/r*1.9,(e-g+1e5)/r,(s-g-1e5)/r)*1.9,n=this.nodes.noise.detailNoise((i-g)/100,(o-g)/100,(a-g)/100);const d=this.nodes.noise.worldGenDetailNoise((t+1e3)/r,(e+1e3)/r,(s+1e3)/r);return n=1-Math.abs(n-.5),n=Math.pow(n,16),n>.8&&d>.6}getData(){return f.data}getClass(){return f}}var p;!function(t){t.Snow="dc_snow",t.Stone="dc_stone",t.GrassBlock="dc_grass_block",t.Dirt="dc_dirt",t.Sand="dc_sand",t.Water="dc_water",t.Gravel="dc_gravel",t.Clay="dc_clay",t.Ice="dc_ice",t.Andesite="dc_andesite",t.Granite="dc_granite",t.CobbleStone="dc_cobble_stone",t.MossyCobbleStone="dc_mossy_cobble_stone",t.GlowStone="dc_glow_stone",t.OakLog="dc_oak_log",t.OakPlanks="dc_oak_planks",t.OakLeaves="dc_oak_leaves",t.SpruceLog="dc_spruce_log",t.SpruceLeaves="dc_spruce_leaves",t.SprucePlanks="dc_spruce_planks",t.SmoothAndesite="dc_smooth_andesite",t.SmoothGranite="dc_smooth_granite",t.Glass="dc_glass",t.Podzol="dc_podzol",t.EmeraldOre="dc_emerald_ore",t.GoldOre="dc_gold_ore",t.IronOre="dc_iron_ore",t.LapisOre="dc_lapis_ore",t.RedstoneOre="dc_redstone_ore",t.CoalBlock="dc_coal_block",t.DiamondBlock="dc_diamond_block",t.GoldBlock="dc_gold_block",t.IronBlock="dc_iron_block",t.Mycelium="dc_mycelium",t.TallFern="dc_tall_fern",t.TallGrass="dc_tall_grass",t.TallRose="dc_tall_rose",t.PaeoniaFlower="dc_paeonia_flower",t.SyringaFlower="dc_syringa_flower",t.BlueOrchidFlower="dc_blue_orchid_flower",t.DandelionFlower="dc_dandelion_flower",t.OxeyeDaisyFlower="dc_oxeye_daisy_flower",t.TulipFlower="dc_tulip_flower",t.WaterlilyFlower="dc_waterlily_flower",t.Vine="dc_vine",t.Fern="dc_fern",t.Reeds="dc_reeds",t.Kelp="dc_kelp",t.Cactus="dc_cactus",t.Grass="dc_grass",t.SeaGrass="dc_sea_grass",t.BrainCoral="dc_brain_coral",t.BrainCoralBlock="dc_brain_coral_block",t.BubbleCoral="dc_bubble_coral",t.BubbleCoralBlock="dc_bubble_coral_block",t.DeadBrainCoralBlock="dc_dead_brain_coral_block",t.DeadBubbleCoralBlock="dc_dead_bubble_coral_block",t.DeadFireCoral="dc_dead_fire_coral",t.DeadFireCoralBlock="dc_dead_fire_coral_block",t.DeadHornCoral="dc_dead_horn_coral",t.DeadHornCoralBlock="dc_dead_horn_coral_block",t.DeadTubeCoral="dc_dead_tube_coral",t.DeadTubeCoralBlock="dc_dead_tube_coral_block",t.DeadBrainCoral="dc_dead_brain_coral",t.DeadBubbleCoral="dc_dead_bubble_coral",t.FireCoral="dc_fire_coral",t.FireCoralBlock="dc_fire_coral_block",t.HornCoral="dc_horn_coral",t.HornCoralBlock="dc_horn_coral_block",t.TubeCoral="dc_tube_coral",t.TubeCoralBlock="dc_tube_coral_block",t.DarkOakLeaves="dc_dark_oak_leaves",t.DarkOakLog="dc_dark_oak_log",t.DarkOakPlanks="dc_dark_oak_planks",t.AcaciaLeaves="dc_acacia_leaves",t.AcaciaLog="dc_acacia_log",t.AcaciaPlanks="dc_acacia_planks",t.BirchLeaves="dc_birch_leaves",t.BirchLog="dc_birch_log",t.BirchPlanks="dc_birch_planks",t.DarkPrismarine="dc_dark_prismarine",t.Prismarine="dc_prismarine",t.PrismarineBricks="dc_prismarine_bricks",t.Bedrock="dc_bedrock",t.Obsidian="dc_obsidan",t.SeaLantern="dc_sea_lantern"}(p||(p={}));const m={[p.Stone]:{id:p.Stone},[p.SeaLantern]:{id:p.SeaLantern},[p.Snow]:{id:p.Snow},[p.SeaGrass]:{id:p.SeaGrass},[p.GrassBlock]:{id:p.GrassBlock},[p.Grass]:{id:p.Grass},[p.Dirt]:{id:p.Dirt},[p.Sand]:{id:p.Sand},[p.Water]:{id:p.Water},[p.Gravel]:{id:p.Gravel},[p.Clay]:{id:p.Clay},[p.Ice]:{id:p.Ice},[p.Andesite]:{id:p.Andesite},[p.Granite]:{id:p.Granite},[p.CobbleStone]:{id:p.CobbleStone},[p.MossyCobbleStone]:{id:p.MossyCobbleStone},[p.GlowStone]:{id:p.GlowStone},[p.OakLog]:{id:p.OakLog},[p.OakPlanks]:{id:p.OakPlanks},[p.OakLeaves]:{id:p.OakLeaves},[p.SpruceLog]:{id:p.SpruceLog},[p.SpruceLeaves]:{id:p.SpruceLeaves},[p.SprucePlanks]:{id:p.SprucePlanks},[p.SmoothAndesite]:{id:p.SmoothAndesite},[p.SmoothGranite]:{id:p.SmoothGranite},[p.Glass]:{id:p.Glass},[p.Podzol]:{id:p.Podzol},[p.EmeraldOre]:{id:p.EmeraldOre},[p.GoldOre]:{id:p.GoldOre},[p.IronOre]:{id:p.IronOre},[p.LapisOre]:{id:p.LapisOre},[p.RedstoneOre]:{id:p.RedstoneOre},[p.CoalBlock]:{id:p.CoalBlock},[p.DiamondBlock]:{id:p.DiamondBlock},[p.GoldBlock]:{id:p.GoldBlock},[p.IronBlock]:{id:p.IronBlock},[p.Mycelium]:{id:p.Mycelium},[p.TallFern]:{id:p.TallFern},[p.TallGrass]:{id:p.TallGrass},[p.TallRose]:{id:p.TallRose},[p.PaeoniaFlower]:{id:p.PaeoniaFlower},[p.SyringaFlower]:{id:p.SyringaFlower},[p.BlueOrchidFlower]:{id:p.BlueOrchidFlower},[p.DandelionFlower]:{id:p.DandelionFlower},[p.OxeyeDaisyFlower]:{id:p.OxeyeDaisyFlower},[p.TulipFlower]:{id:p.TulipFlower},[p.WaterlilyFlower]:{id:p.WaterlilyFlower},[p.Vine]:{id:p.Vine},[p.Fern]:{id:p.Fern},[p.Reeds]:{id:p.Reeds},[p.Cactus]:{id:p.Cactus},[p.Kelp]:{id:p.Kelp},[p.BrainCoral]:{id:p.BrainCoral},[p.BrainCoralBlock]:{id:p.BrainCoralBlock},[p.BubbleCoral]:{id:p.BubbleCoral},[p.BubbleCoralBlock]:{id:p.BubbleCoralBlock},[p.DeadBrainCoralBlock]:{id:p.DeadBrainCoralBlock},[p.DeadBubbleCoralBlock]:{id:p.DeadBubbleCoralBlock},[p.DeadFireCoral]:{id:p.DeadFireCoral},[p.DeadFireCoralBlock]:{id:p.DeadFireCoralBlock},[p.DeadHornCoral]:{id:p.DeadHornCoral},[p.DeadHornCoralBlock]:{id:p.DeadHornCoralBlock},[p.DeadTubeCoral]:{id:p.DeadTubeCoral},[p.DeadTubeCoralBlock]:{id:p.DeadTubeCoralBlock},[p.DeadBrainCoral]:{id:p.DeadBrainCoral},[p.DeadBubbleCoral]:{id:p.DeadBubbleCoral},[p.FireCoral]:{id:p.FireCoral},[p.FireCoralBlock]:{id:p.FireCoralBlock},[p.HornCoral]:{id:p.HornCoral},[p.HornCoralBlock]:{id:p.HornCoralBlock},[p.TubeCoral]:{id:p.TubeCoral},[p.TubeCoralBlock]:{id:p.TubeCoralBlock},[p.DarkOakLeaves]:{id:p.DarkOakLeaves},[p.DarkOakLog]:{id:p.DarkOakLog},[p.DarkOakPlanks]:{id:p.DarkOakPlanks},[p.AcaciaLeaves]:{id:p.AcaciaLeaves},[p.AcaciaLog]:{id:p.AcaciaLog},[p.AcaciaPlanks]:{id:p.AcaciaPlanks},[p.BirchLeaves]:{id:p.BirchLeaves},[p.BirchLog]:{id:p.BirchLog},[p.BirchPlanks]:{id:p.BirchPlanks},[p.DarkPrismarine]:{id:p.DarkPrismarine},[p.Prismarine]:{id:p.Prismarine},[p.PrismarineBricks]:{id:p.PrismarineBricks},[p.Bedrock]:{id:p.Bedrock},[p.Obsidian]:{id:p.Obsidian}};var y=s(56059);new Map;const x=new Map,v=new Map,b=new Map,I=new Map;function w(t,e,s){return`${t}-${e}-${s}`}class S{nodes;data;biomeTypes=new Map;constructor(t,e){this.nodes=t,this.data=e}init(){for(const[t,e]of this.data.biomeTypes){const s=new(c.getBiomeType(t))(this.nodes,this,e);this.biomeTypes.set(t,s),s.init()}}isInRange(t,e){return e.temperature[0]<=t[0]&&e.temperature[1]>=t[0]&&e.moisture[0]<=t[1]&&e.moisture[1]>=t[1]&&e.elevation[0]<=t[2]&&e.elevation[1]>=t[2]}getBiomeTypeInRange(t){let e=0,s=null,r=0,i=0;for(const[o,a]of this.data.biomeTypes){let n=h(t,a);if(n>i&&a.river[1]<=0&&a.excludeRiver&&(i=n),n>e){if(a.river[1]>=0&&r>0&&e==i){n=0;continue}e=n,s=this.biomeTypes.get(o),r=a.excludeRiver?100:r}}return s||this.biomeTypes.get("grass-land")}getBiomeTypeFromValue(t){let e=this.getBiomeTypeInRange(t);const s=e.getData();if(!s.edgeBiomeTypes.length||!s.edgeFactor)return e;{const r=[t[0]+s.edgeFactor[0],t[1]+s.edgeFactor[1],t[2]+s.edgeFactor[2],t[3]+s.edgeFactor[3]],i=this.getBiomeTypeInRange(r);if(i!=e){const s=this.getEdgeBiomeTypeFromValue(e,t);if(i.getData().edgeBiomeTypes.find((t=>t[0]==s.getData().id)))return s}}{const r=[t[0]-s.edgeFactor[0],t[1]-s.edgeFactor[1],t[2]-s.edgeFactor[2],t[3]-s.edgeFactor[3]],i=this.getBiomeTypeInRange(r);if(i!=e){const s=this.getEdgeBiomeTypeFromValue(e,t);if(i.getData().edgeBiomeTypes.find((t=>t[0]==s.getData().id)))return s}}return e}getBiomeFromValue(t,e){return this.getBiomeTypeFromValue(t).getBiomeFromValue(t,e)}getEdgeBiomeTypeFromValue(t,e){for(const[s,r]of t.getData().edgeBiomeTypes)if(this.isInRange(e,r))return this.biomeTypes.get(s);throw new Error("No biome type")}_clearTimeOut;getRiverNoise(t,e,s){let r=this.nodes.noise.biomeTypeRiverNoise(t/1600,1.2*s/1600),i=.05*this.nodes.noise.biomeDetailNoise(t/50,10,s/50)+.1;return r>-i&&r<i?(r+i)/(2*i):0}getElavation(t,e,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(t/100,50,s/100);const o=this.nodes.noise.biomeTypeElevationNoise((t-r)/1024,(s+r)/1024);let a=o+i;return(a>1||a<-1)&&(i=-i,a=o+i),Math.max(-1,Math.min(1,a))}getTempature(t,e,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(t/100,5880,s/100);const o=this.nodes.noise.biomeTypeTemperatureNoise((t-r)/4096,(s-r)/4096);let a=o+i;return(a>1||a<-1)&&(i=-i,a=o+i),Math.max(-1,Math.min(1,a))}getMostiure(t,e,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(t/100,10980,s/100);const o=this.nodes.noise.biomeTypeMoistureNoise((t-r)/1024,(s-r)/1024);let a=o+i;return(a>1||a<-1)&&(i=-i,a=o+i),Math.max(-1,Math.min(1,a))}getBiomeTypeValue(t,e,s){const r=this.getMostiure(t,e,s);return[this.getElavation(t,e,s),r,this.getTempature(t,e,s),this.getRiverNoise(t,e,s)]}clearCache(){I.clear(),x.clear(),v.clear(),b.clear()}getBiomeType(t,e,s){const r=w(t,e,s);let i=I.get(r);if(i)return i;let o=this.getBiomeTypeValue(t,e,s);return i=this.getBiomeTypeFromValue(o),I.set(r,i),i}getBiome(t,e,s){const r=w(t,e,s);let i=x.get(r);return i||(i=this.getBiomeType(t,e,s).getBiome(t,e,s),x.set(r,i),i)}getHeight(t,e,s){const r=w(t,e,s);let i=b.get(r);return i||(i=Math.max(this.getBiome(t,e,s).getHeight(t,e,s),1),b.set(r,i),i)}getBlendedHeight(t,e,s){const r=w(t,e,s);let i=v.get(r);return i||(i=Math.max(this.getBiome(t,e,s).getBlendedHeight(t,e,s),1),v.set(r,i),i)}generateWorldColumn(t,e){const{brush:s}=this.nodes,r=s.dataCursor;for(let i=t;i<this.nodes.chunkWidth+t;i++)for(let t=e;t<this.nodes.chunkDepth+e;t++){const e=this.getBiome(i,0,t),o=this.getBlendedHeight(i,0,t);if(o>y.k.world.bounds.MaxY-20)continue;for(let r=0;r<=o;r++){if(0==r){s.setId(p.Bedrock).setXYZ(i,r,t).paint();continue}if(e.getCarved(i,r,t))continue;const o=e.getGenVoxel(i,r,t);o&&s.setData(o).setXYZ(i,r,t).paint()}let a=!1,n=!1;for(let s=o+10;s>=0&&(a||(r.getVoxel(i,s,t)?.isRenderable()||1==s)&&(a=!0,e.fill(i,s+1,t)),n||e.addTopLayer(i,s,t)&&(n=!0),!a||!n);s--);}}decorateWorldColumn(t,e){const{brush:s}=this.nodes;for(let s=t;s<this.nodes.chunkWidth+t;s++)for(let t=e;t<this.nodes.chunkDepth+e;t++){const e=this.getBiome(s,0,t),r=this.getBlendedHeight(s,0,t);for(let i=1;i<=r;i++)e.decorate(s,i,t)}}wormCanver;generateBiomeTypeImage([t,e,s],[r,i,o]){this.wormCanver=new f(this.nodes);const a=new Uint8ClampedArray(4194304);console.log("Start");for(let e=s;e<=o;e++)for(let i=t;i<=r;i++){const r=4*(1024*(e-s)+(i-t));try{const[t,s,o]=this.getBiome(i,0,e).getData().color;a[r]=t,a[r+1]=s,a[r+2]=o,a[r+3]=255}catch(t){a[r]=255,a[r+3]=255}}return console.log("done",a),a}}class A{nodes;dimesnion;range;biomes=new Map;isRiver;constructor(t,e,s){this.nodes=t,this.dimesnion=e,this.range=s}getBiomeFromValue(t,e){t[4]=e;let s=0,r=null,i=null;for(const[e,o]of this.getData().biomes){let a=h(t,o);a>s&&(s=a,i=o,r=this.biomes.get(e))}if(!r||!i)return this.biomes.get(this.biomes.keys().next().value);const o=r.getData();if(!o.edgeBiomes.length||!o.edgeFactor)return r;{const s=[t[0]-(Array.isArray(o.edgeFactor[0])?o.edgeFactor[0][0]:o.edgeFactor[0]),t[1]-(Array.isArray(o.edgeFactor[1])?o.edgeFactor[1][0]:o.edgeFactor[1]),t[2]-(Array.isArray(o.edgeFactor[2])?o.edgeFactor[2][0]:o.edgeFactor[2]),t[3]-(Array.isArray(o.edgeFactor[3])?o.edgeFactor[3][0]:o.edgeFactor[3])],a=this.dimesnion.getBiomeTypeFromValue(s);if((i.excludeRiver||this.range.excludeRiver)&&a.isRiver)return r;if(a!=this)return this.getEdgeBiomeFromValue(t,r,e)}{const s=[t[0]+(Array.isArray(o.edgeFactor[0])?o.edgeFactor[0][1]:o.edgeFactor[0]),t[1]+(Array.isArray(o.edgeFactor[1])?o.edgeFactor[1][1]:o.edgeFactor[1]),t[2]+(Array.isArray(o.edgeFactor[2])?o.edgeFactor[2][1]:o.edgeFactor[2]),t[3]+(Array.isArray(o.edgeFactor[3])?o.edgeFactor[3][1]:o.edgeFactor[3])],a=this.dimesnion.getBiomeTypeFromValue(s);if((i.excludeRiver||this.range.excludeRiver)&&a.isRiver)return r;if(a!=this)return this.getEdgeBiomeFromValue(t,r,e)}return r}getEdgeBiomeFromValue(t,e,s){t[4]=s;let r=0,i=null,o=null;for(const[s,a]of e.getData().edgeBiomes){let e=h(t,a);e>r&&(r=e,o=a,i=this.biomes.get(s))}return i&&o?i:this.biomes.get(this.biomes.keys().next().value)}getBiomeValue(t,e,s){return this.nodes.noise.biomeNoise(t/120,0,s/120)}getBiome(t,e,s){const r=this.getBiomeValue(t,e,s),i=this.dimesnion.getBiomeTypeValue(t,e,s);return this.getBiomeFromValue(i,r)}init(){for(const[t]of this.getData().biomes){const e=c.getBiome(t);if(this.biomes.set(t,new e(this.nodes,this)),e.data.edgeBiomes.length)for(const[t]of e.data.edgeBiomes){const e=c.getBiome(t);this.biomes.set(t,new e(this.nodes,this))}}}}class C{nodes;biomeType;isRiver;constructor(t,e){this.nodes=t,this.biomeType=e}findHeightInDirection(t,e,s,r,i,o){let a=t,n=1;for(let t=1;t<=o;t++){const o=e+t*r,d=s+t*i,l=this.biomeType.dimesnion.getBiome(o,0,d);l!==this&&(a+=l.getHeight(o,0,d),n++)}return a/n}getBlendedHeight(t,e,s){const r=this.getData();if(r.heightBlendFactor<=0)return this.getHeight(t,e,s);const i=32*r.heightBlendFactor;let o=Math.round(this.getHeight(t,e,s)),a=o,n=1;a+=this.findHeightInDirection(o,t,s,0,1,i),a+=this.findHeightInDirection(o,t,s,0,-1,i),a+=this.findHeightInDirection(o,t,s,1,0,i),a+=this.findHeightInDirection(o,t,s,-1,0,i),n+=4,a+=this.findHeightInDirection(o,t,s,1,1,i),a+=this.findHeightInDirection(o,t,s,1,-1,i),a+=this.findHeightInDirection(o,t,s,-1,1,i),a+=this.findHeightInDirection(o,t,s,-1,-1,i),n+=4;const d=Math.round(a/9),l=this.getData().minHeight;return void 0!==l&&d<l?l:d}}class B{data;currentState;rules;angle=25;constructor(t){this.data=t}setRules(t,e,s=this.angle){this.currentState=t,this.rules=e,this.angle=s}setAngle(t){this.angle=t}generateRandomRules(){const t=["F[+F]F[-F]FE","F[&F]F[^F]FE","F[&+F]F[^-F]FE","F[-F][+F]FE","F[&-F][^+F]FE"],e=["FF","FFF","F-F"],s=2+Math.floor(2*Math.random());this.rules=[];for(let r=0;r<s;r++){const s=Math.random()<.5?t.map((t=>t.replace(/F/g,e[Math.floor(Math.random()*e.length)]+(Math.random()>.9?"E":"")))):e.map((t=>t+(Math.random()>.9?"E":"")));this.rules.push({symbol:"F",replacements:s})}return this.rules.push({symbol:"X",replacements:["F[-F][+F]F[&F]^FE","F&[X-FX]+FE","F^F[X]+F-FE"].slice(0,1+Math.floor(2*Math.random()))}),this.currentState="X",this.setRules("X",this.rules,this.angle),this}generateState(t){if(!this.rules.length)throw new Error("Rules not set. Please set rules before generating L-system.");for(let e=0;e<t;e++){let t="";for(const e of this.currentState){let s=!1;for(const r of this.rules)if(e===r.symbol){t+=r.replacements[Math.floor(Math.random()*r.replacements.length)],s=!0;break}s||(t+=e)}this.currentState=t}return this.currentState}interpret(t,e={x:0,y:0,z:0},s={x:0,y:1,z:0}){let r=[],i=e,o=s;for(const e of t)switch(e){case"F":i.x+=o.x,i.y+=o.y,i.z+=o.z,this.placeVoxel(i.x,i.y,i.z);break;case"E":this.placeEnd(i.x,i.y,i.z);case"+":o=this.rotate(o,this.angle,"z");break;case"-":o=this.rotate(o,-this.angle,"z");break;case"&":o=this.rotate(o,this.angle,"x");break;case"^":o=this.rotate(o,-this.angle,"x");break;case"[":r.push({position:{...i},direction:{...o}});break;case"]":const t=r.pop();i=t.position,o=t.direction}}rotate(t,e,s){const r=e*Math.PI/180;let i=t.x,o=t.y,a=t.z;switch(s){case"x":o=t.y*Math.cos(r)-t.z*Math.sin(r),a=t.y*Math.sin(r)+t.z*Math.cos(r);break;case"y":i=t.x*Math.cos(r)-t.z*Math.sin(r),a=t.x*Math.sin(r)+t.z*Math.cos(r);break;case"z":i=t.x*Math.cos(r)-t.y*Math.sin(r),o=t.x*Math.sin(r)+t.y*Math.cos(r)}return{x:i,y:o,z:a}}placeEnd(t,e,s){this.data.placeEnd(Math.round(t),Math.round(e),Math.round(s))}placeVoxel(t,e,s){this.data.placeVoxel(Math.round(t),Math.round(e),Math.round(s))}}var T=s(61e3);function _(t,e,s,r,i,o,a=!1,n=!0){let d=s-o,l=i-o;t.setId(e);const h=t.dataCursor;for(let e=d;e<=s+o;e++)for(let d=l;d<=i+o;d++)if(!a||e!=s||d!=i){if(n){const t=h.getVoxel(e,r,d);if(t){if(t.isAir()&&1==t.getLevelState())continue;if(t.isRenderable())continue}}(0,T.me)(e,s,d,i)<=o&&t.setXYZ(e,r,d).paint()}}function z(t,e,s,r,i,o,a=-1,n=!0){let d=Math.floor(s-o),l=Math.floor(r-o),h=Math.floor(i-o);t.setId(e);const c=t.dataCursor;for(let e=d;e<=s+o;e++)for(let d=h;d<=i+o;d++)for(let h=l;h<=r+o;h++){if(a>-1&&Math.random()<a)continue;const l=c.getVoxel(e,h,d);if(n&&l){if(l.isAir()&&1==l.getLevelState())continue;if(l.isRenderable())continue}(0,T.D7)(e,h,d,s,r,i)<=o&&t.setXYZ(e,h,d).paint()}}class D{static oakLSystem=new B({placeVoxel(t,e,s){D.nodes.brush.setXYZ(t,e,s).setId(p.OakLog).paint()},placeEnd(t,e,s){z(D.nodes.brush,p.OakLeaves,t,e,s,Math.max(5*Math.random(),4),.01)}});static birchSystem=new B({placeVoxel(t,e,s){D.nodes.brush.setXYZ(t,e,s).setId(p.BirchLog).paint()},placeEnd(t,e,s){z(D.nodes.brush,p.BirchLeaves,t,e,s,Math.max(5*Math.random(),4),.01)}});static acaciSystem=new B({placeVoxel(t,e,s){D.nodes.brush.setXYZ(t,e,s).setId(p.AcaciaLog).paint()},placeEnd(t,e,s){z(D.nodes.brush,p.AcaciaLeaves,t,e,s,Math.max(5*Math.random(),4),.01)}});static darkOakSystem=new B({placeVoxel(t,e,s){D.nodes.brush.setXYZ(t,e,s).setId(p.DarkOakLog).paint()},placeEnd(t,e,s){z(D.nodes.brush,p.DarkOakLeaves,t,e,s,Math.max(5*Math.random(),4),.01)}});static nodes;static init(t){this.nodes=t}static generateOakTree(t,e,s){this.oakLSystem.generateRandomRules();const r=this.oakLSystem.generateState(2);this.oakLSystem.interpret(r,{x:t,y:e-1,z:s})}static generateDarkOakTree(t,e,s){this.darkOakSystem.generateRandomRules();const r=this.darkOakSystem.generateState(2);this.darkOakSystem.interpret(r,{x:t,y:e-1,z:s})}static generateAcaciaTree(t,e,s){this.acaciSystem.generateRandomRules();const r=this.acaciSystem.generateState(2);this.acaciSystem.interpret(r,{x:t,y:e-1,z:s})}static generateBirchTree(t,e,s){this.birchSystem.generateRandomRules();const r=this.birchSystem.generateState(2);this.birchSystem.interpret(r,{x:t,y:e-1,z:s})}static generateSpruceTree(t,e,s){const{brush:r}=this.nodes;r.setId(p.SpruceLog).setXYZ(t,e,s).paint();let i=Math.floor(30*Math.random()+10);r.setId(p.SpruceLeaves).setXYZ(t,i+e+1,s).paint(),r.setXYZ(t+1,i+e+1,s).paint(),r.setXYZ(t,i+e+1,s+1).paint(),r.setXYZ(t+1,i+e+1,s+1).paint();let o=4,a=i,n=a/4;for(;a>n&&o<10;)_(r,p.SpruceLeaves,t,e+a,s,o),a-=3,o++;for(let o=e;o<=e+i;o++)r.setId(p.SpruceLog).setXYZ(t,o,s).paint(),r.setXYZ(t+1,o,s).paint(),r.setXYZ(t,o,s+1).paint(),r.setXYZ(t+1,o,s+1).paint()}}const k={getIndex(t,e=Math.random()){if(t.length<=1)return 0;const s=[];let r=0;for(const[e,i]of t)r+=i,s.push(r);const i=e*r|0;let o=0;for(const t of s){if(i<=t)break;o++}return o},getValue(t,e=Math.random()){return t[this.getIndex(t,e)][0]}},L=[[p.TulipFlower,10],[p.PaeoniaFlower,10],[p.SyringaFlower,10],[p.DandelionFlower,10],[p.BlueOrchidFlower,10],[p.OxeyeDaisyFlower,10],[p.WaterlilyFlower,10]],V=[[p.Fern,10],[p.Grass,10],[p.TallGrass,10],[p.TallFern,10]],R=[[p.DeadFireCoral,10],[p.DeadHornCoral,10],[p.DeadTubeCoral,10],[p.DeadBrainCoral,10],[p.DeadBubbleCoral,10]],F=[[p.FireCoral,10],[p.HornCoral,10],[p.TubeCoral,10],[p.BrainCoral,10],[p.BubbleCoral,10]],M=[[p.SeaGrass,10]];class U{static generateCactus(t,e,s,r){const{brush:i}=t;let o=Math.floor(5*Math.random()+2);for(let t=s;t<=s+o;t++)i.setId(p.Cactus).setXYZ(e,t,r).paint()}static generateReed(t,e,s,r){const{brush:i}=t;let o=Math.floor(5*Math.random()+2);for(let t=s;t<=s+o;t++)i.setId(p.Reeds).setXYZ(e,t,r).paint()}static generateKelp(t,e,s,r){const{brush:i}=t;let o=Math.floor(15*Math.random()+5),a=Math.floor(5*Math.random());for(let n=s;n<=s+o&&n<t.waterHeight-a;n++)i.setId(p.Water).setLevel(7).setSecondaryId(p.Kelp).setXYZ(e,n,r).paint();i.setLevel(0),i.setSecondaryId("")}static generateWaterPlant(t,e,s,r){const{brush:i}=t,o=k.getValue(M);i.setId(p.Water).setLevel(7).setSecondaryId(o).setXYZ(e,s,r).paint(),i.setLevel(0),i.setSecondaryId("")}static generateRandomFlower(t,e,s,r){const{brush:i}=t,o=k.getValue(L);i.setId(o).setXYZ(e,s,r).paint()}static generateRandomPlant(t,e,s,r){const{brush:i}=t,o=k.getValue(V);i.setId(o).setXYZ(e,s,r).paint()}static generateRandomDeadCoral(t,e,s,r){const{brush:i}=t,o=k.getValue(R);i.setId(o).setXYZ(e,s,r).paint()}static generateRandomCoral(t,e,s,r){const{brush:i}=t,o=k.getValue(F);i.setId(p.Water).setLevel(7).setSecondaryId(o).setXYZ(e,s,r).paint(),i.setLevel(0),i.setSecondaryId("")}}const E=2**32;class N extends u{static data={id:"standard"};getCarved(t,e,s){const r=this.nodes.noise.worldGenNoise(t/50,e/50,s/50),i=(1+this.nodes.noise.detailNoise((t-E)/100,e/100,(s-E)/100))/2;return i<.4+(.6-.4)*r-.9*i&&e<(.2+(.8-.2)*r+.9*i)*this.nodes.worldHeight}getData(){return N.data}getClass(){return N}}const P=2**32;class H extends u{static data={id:"worm"};getCarved(t,e,s){for(let r=0;r<4;r++){let i=150/(r%3);t+=2e4*r,s-=2e4*r;let o=this.nodes.noise.detailNoise(t/200,25e4*r,s/200);if(this.nodes.noise.worldDetailNoise(t/600,25e4*r,s/600)<.5)continue;let a=(1+this.nodes.noise.worldDetailNoise((t-P)/i,5e4,(s-P)/i))/2*60+5,n=(1+this.nodes.noise.worldDetailNoise((t-P)/150,25e4,(s-P)/150))/2*10+5,d=(1+this.nodes.noise.worldDetailNoise((t-P)/30,(e+200)/30,(s-P)/30))/2;if(o>-.03-.02*d&&o<.03+.02*d&&e<=a+(n+20*d)/2&&e>=a-(n+20*d)/2)return!0}return!1}getData(){return H.data}getClass(){return H}}class G{static standard;static worm;static valley;static init(t){this.standard=new N(t),this.worm=new H(t),this.valley=new f(t)}static getCarved(t,e,s){const r=this.standard.getCarved(t,e,s),i=this.worm.getCarved(t,e,s);return r||i}}const[Q,O]=[1e3,1e4];class Y extends C{static data={id:"tundra",heightBlendFactor:1,color:[3,171,121],edgeBiomes:[]};getGenVoxel(t,e,s){return!(e>40*this.noiseQuery(t,e,s)+this.nodes.minHeight)&&m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+Q)/100,e/100,(s+O)/100))/2}getHeight(t,e,s){return 40*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint(),r.setData(m[p.Snow]).setXYZ(t,e+1,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();r>.999&&D.generateOakTree(t,e+1,s),r>.88&&r<.89&&U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Y}}const[X,Z]=[1e3,1e4];class W extends C{static data={id:"frozen-waste",heightBlendFactor:1,color:[255,255,255],edgeBiomes:[]};getGenVoxel(t,e,s){return!(e>40*this.noiseQuery(t,e,s)+this.nodes.minHeight)&&m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+X)/100,e/100,(s+Z)/100))/2}getHeight(t,e,s){return 40*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Gravel]).setXYZ(t,e,s).paint(),r.setData(m[p.Snow]).setXYZ(t,e+1,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){}getData(){return this.getClass().data}getClass(){return W}}class q extends A{static data={id:"artic",color:[255,255,255],biomes:[[Y.data.id,a([-.8,-.5])],[W.data.id,a([-1,-.8])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return q}}const[j,$]=[1e3,1e4];class K extends C{static data={id:"desert",heightBlendFactor:1,color:[166,132,40],edgeBiomes:[]};getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+j)/480,e/480,(s+$)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Sand]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Sand]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.Sand){const r=Math.random();if(r>.999)return void D.generateOakTree(t,e+1,s);if(r>.88&&r<.89)return void U.generateCactus(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return K}}class J{static brainCoralSystem=new B({placeVoxel(t,e,s){e>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(t,e,s).setId(p.BrainCoralBlock).paint()},placeEnd(t,e,s){}});static fireCoralSystem=new B({placeVoxel(t,e,s){e>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(t,e,s).setId(p.FireCoralBlock).paint()},placeEnd(t,e,s){}});static bubbleCoralSystem=new B({placeVoxel(t,e,s){e>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(t,e,s).setId(p.BubbleCoralBlock).paint()},placeEnd(t,e,s){}});static hornCoralSystem=new B({placeVoxel(t,e,s){e>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(t,e,s).setId(p.HornCoralBlock).paint()},placeEnd(t,e,s){}});static tubeCoralSystem=new B({placeVoxel(t,e,s){e>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(t,e,s).setId(p.TubeCoralBlock).paint()},placeEnd(t,e,s){}});static nodes;static init(t){this.nodes=t}static generateBrainCoral(t,e,s){this.brainCoralSystem.generateRandomRules();const r=this.brainCoralSystem.generateState(2);this.brainCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateFireCoral(t,e,s){this.fireCoralSystem.generateRandomRules();const r=this.fireCoralSystem.generateState(2);this.fireCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateBubbleCoral(t,e,s){this.bubbleCoralSystem.generateRandomRules();const r=this.bubbleCoralSystem.generateState(2);this.bubbleCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateHornCoral(t,e,s){this.hornCoralSystem.generateRandomRules();const r=this.hornCoralSystem.generateState(2);this.hornCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateTubeCoral(t,e,s){this.tubeCoralSystem.generateRandomRules();const r=this.tubeCoralSystem.generateState(2);this.tubeCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static deadBrainCoralSystem=new B({placeVoxel(t,e,s){J.nodes.brush.setXYZ(t,e,s).setId(p.DeadBrainCoralBlock).paint()},placeEnd(t,e,s){}});static deadBubbleCoralSystem=new B({placeVoxel(t,e,s){J.nodes.brush.setXYZ(t,e,s).setId(p.DeadBubbleCoralBlock).paint()},placeEnd(t,e,s){}});static deadFireCoralSystem=new B({placeVoxel(t,e,s){J.nodes.brush.setXYZ(t,e,s).setId(p.DeadFireCoralBlock).paint()},placeEnd(t,e,s){}});static deadHornCoralSystem=new B({placeVoxel(t,e,s){J.nodes.brush.setXYZ(t,e,s).setId(p.DeadHornCoralBlock).paint()},placeEnd(t,e,s){}});static deadTubeCoralSystem=new B({placeVoxel(t,e,s){J.nodes.brush.setXYZ(t,e,s).setId(p.DeadTubeCoralBlock).paint()},placeEnd(t,e,s){}});static generateDeadBrainCoral(t,e,s){this.deadBrainCoralSystem.generateRandomRules();const r=this.deadBrainCoralSystem.generateState(2);this.deadBrainCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateDeadBubbleCoral(t,e,s){this.deadBubbleCoralSystem.generateRandomRules();const r=this.deadBubbleCoralSystem.generateState(2);this.deadBubbleCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateDeadFireCoral(t,e,s){this.deadFireCoralSystem.generateRandomRules();const r=this.deadFireCoralSystem.generateState(2);this.deadFireCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateDeadHornCoral(t,e,s){this.deadHornCoralSystem.generateRandomRules();const r=this.deadHornCoralSystem.generateState(2);this.deadHornCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static generateDeadTubeCoral(t,e,s){this.deadTubeCoralSystem.generateRandomRules();const r=this.deadTubeCoralSystem.generateState(2);this.deadTubeCoralSystem.interpret(r,{x:t,y:e-1,z:s})}static runRandomGenerator(t){return t[Math.floor(Math.random()*t.length)]}static liveGens=[this.generateBrainCoral,this.generateBubbleCoral,this.generateFireCoral,this.generateHornCoral,this.generateTubeCoral];static generateRandomCoral(t,e,s){this.runRandomGenerator(this.liveGens).call(this,t,e,s)}static deadGens=[this.generateDeadBrainCoral,this.generateDeadBubbleCoral,this.generateDeadFireCoral,this.generateDeadHornCoral,this.generateDeadTubeCoral];static generateRandomDeadCoral(t,e,s){this.runRandomGenerator(this.deadGens).call(this,t,e,s)}}const[tt,et]=[1e3,1e4];class st extends C{static data={id:"dea-sea",heightBlendFactor:1,color:[153,131,70],edgeBiomes:[]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+tt)/480,e/480,(s+et)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Sand]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Sand]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.Sand){const r=Math.random();if(r>.87&&r<.89)return void J.generateRandomDeadCoral(t,e+1,s);if(r>.85&&r<.87)return void U.generateRandomDeadCoral(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return st}}class rt extends A{static data={id:"desert",color:[166,132,40],biomes:[[K.data.id,a([-1,1],[-1,1],[.3,.7],[-1,1])],[st.data.id,a([-1,1],[-1,1],[0,.2],[-1,1])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return rt}}const[it,ot]=[1e3,1e4];class at extends C{static data={id:"oak-forest",heightBlendFactor:1,color:[42,102,49],edgeBiomes:[]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+it)/480,e/480,(s+ot)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.97)return void D.generateOakTree(t,e+1,s);if(r>.85&&r<.89)return void U.generateRandomFlower(this.nodes,t,e+1,s);if(r>0&&r<.1)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return at}}const[nt,dt]=[1e3,1e4];class lt extends C{static data={id:"spruce-forest",heightBlendFactor:1,color:[32,56,35],edgeBiomes:[]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+nt)/480,e/480,(s+dt)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}getFillVoxel(t,e,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(t/200,e/200,s/200))/2;return i>.4&&i<1?p.Podzol:i>.3&&i<.4?r?p.GrassBlock:p.Dirt:p.Gravel}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[this.getFillVoxel(t,e,s,!0)]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[this.getFillVoxel(t,e,s)]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&(o==p.Podzol||o==p.GrassBlock)){const r=Math.random();if(r>.99)return void D.generateSpruceTree(t,e+1,s);if(r>.88&&r<.89)return void U.generateRandomFlower(this.nodes,t,e+1,s);if(r>0&&r<.05)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return lt}}const[ht,ct]=[1e3,1e4];class ut extends C{static data={id:"dark-oak-forest",heightBlendFactor:1,color:[1,66,8],edgeBiomes:[]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+ht)/480,e/480,(s+ct)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.97)return void D.generateDarkOakTree(t,e+1,s);if(r>.85&&r<.89)return void U.generateRandomFlower(this.nodes,t,e+1,s);if(r>0&&r<.1)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return ut}}class gt extends C{static data={id:"birch-forest",heightBlendFactor:1,color:[95,204,61],edgeBiomes:[]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){const[r,i]=[1e3,1e4];return(1+this.nodes.noise.worldGenNoise((t+r)/480,e/480,(s+i)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.97)return void D.generateBirchTree(t,e+1,s);if(r>.85&&r<.89)return void U.generateRandomFlower(this.nodes,t,e+1,s);if(r>0&&r<.1)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return gt}}class ft extends A{static data={id:"forest",color:[19,77,17],biomes:[[at.data.id,a([-.2,.3],[-.2,-.01],[.1,.8])],[lt.data.id,a([-.8,-.1],[-.4,-.2],[.2,.8])],[ut.data.id,a([-.2,.3],[-.4,-.3],[.2,.5])],[gt.data.id,a([-.3,.4],[-.3,-.1],[.4,.8])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return ft}}const[pt,mt]=[1e3,1e4];class yt extends C{static data={id:"prairie",heightBlendFactor:1,color:[117,255,112],edgeBiomes:[]};caveCarver=new N(this.nodes);getCoreVoxel(t,e,s){const r=(1+this.nodes.noise.worldGenNoise(t/200,e/200,s/200))/2;return r>=.8?p.Granite:r>=.7&&r<.8?p.Andesite:p.Stone}getGenVoxel(t,e,s){return m[this.getCoreVoxel(t,e,s)]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+pt)/480,e/480,(s+mt)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone||a==p.Andesite||a==p.Granite){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.99)return void D.generateOakTree(t,e+1,s);if(r>.9&&r<.92)return void U.generateRandomFlower(this.nodes,t,e+1,s);if(r>0&&r<.1)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return yt}}const[xt,vt]=[1e3,1e4];class bt extends C{static data={id:"savannah",heightBlendFactor:1,color:[188,255,112],edgeBiomes:[]};caveCarver=new N(this.nodes);getCoreVoxel(t,e,s){const r=(1+this.nodes.noise.worldGenNoise(t/200,e/200,s/200))/2;return r>=.8?p.Granite:r>=.7&&r<.8?p.Andesite:p.Stone}getGenVoxel(t,e,s){return m[this.getCoreVoxel(t,e,s)]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+xt)/480,e/480,(s+vt)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone||a==p.Andesite||a==p.Granite){r.setData(m[p.GrassBlock]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.99)return void D.generateAcaciaTree(t,e+1,s);if(r>0&&r<.01)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return bt}}class It extends A{static data={id:"grass-land",color:[117,255,112],biomes:[[yt.data.id,a([.1,.3],[-.5,-.3])],[bt.data.id,a([.3,.4],[-.3,-.1])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return It}}const[wt,St]=[1e3,1e4];class At extends C{static data={id:"rocky-mountain",heightBlendFactor:.2,color:[129,142,143],edgeBiomes:[]};caveCarver=new N(this.nodes);getCoreVoxel(t,e,s){const r=(1+this.nodes.noise.worldGenNoise(t/40,e/40,s/40))/2;return r>.6&&r<.7?p.Gravel:p.Stone}getGenVoxel(t,e,s){return m[this.getCoreVoxel(t,e,s)]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+wt)/30,e/30,(s+St)/30))/2}getHeight(t,e,s){return 200*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){if(e<150)return!0;const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Snow]).setXYZ(t,e,s).paint(),r.setData(m[p.Snow]).setXYZ(t,e+1,s).paint();let i=5;for(;i--;)r.setData(m[p.Snow]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){}getData(){return this.getClass().data}getClass(){return At}}const[Ct,Bt]=[1e3,1e4];class Tt extends C{static data={id:"high-gravel-hills",heightBlendFactor:1,color:[90,99,99],edgeBiomes:[]};caveCarver=new N(this.nodes);getCoreVoxel(t,e,s){const r=(1+this.nodes.noise.worldGenNoise(t/40,e/40,s/40))/2;return r>.2&&r<.8?p.Gravel:p.Stone}getGenVoxel(t,e,s){return m[this.getCoreVoxel(t,e,s)]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.getHeight(t,e,s)}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+Ct)/100,e/100,(s+Bt)/100))/2}getHeight(t,e,s){return 80*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){if(e<150)return!0;const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Snow]).setXYZ(t,e,s).paint(),r.setData(m[p.Snow]).setXYZ(t,e+1,s).paint();let i=5;for(;i--;)r.setData(m[p.Snow]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){return!1}decorate(t,e,s){}getData(){return this.getClass().data}getClass(){return Tt}}class _t extends A{static data={id:"mountain",color:[129,142,143],biomes:[[At.data.id,a(void 0,void 0,[.85,1])],[Tt.data.id,a(void 0,void 0,[.7,.85])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return _t}}const[zt,Dt]=[1e3,1e4];class kt extends C{static data={id:"beache",heightBlendFactor:.5,color:[252,252,3],edgeBiomes:[],minHeight:60};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+zt)/480,e/480,(s+Dt)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Sand]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Sand]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(;i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setId(p.Sand).setXYZ(t,i,s).paint(),i++}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.999)return void D.generateOakTree(t,e+1,s);if(r>.85&&r<.89)return void U.generateRandomPlant(this.nodes,t,e+1,s)}if(i&&o==p.Sand){const r=Math.random();if(r>.88&&r<.89)return void U.generateRandomPlant(this.nodes,t,e+1,s);if(r>2e-4&&r<.005)return void U.generateReed(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return kt}}const[Lt,Vt]=[1e3,1e4];class Rt extends C{static data={id:"rocky-beach",heightBlendFactor:.5,color:[122,122,59],edgeBiomes:[],minHeight:60};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getFillVoxel(t,e,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(t/200,e/200,s/200))/2;return i>.4&&i<1?p.Gravel:i>.3&&i<.4?p.Sand:p.Andesite}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+Lt)/480,e/480,(s+Vt)/480))/2}getHeight(t,e,s){return 30*this.noiseQuery(t,0,s)+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[this.getFillVoxel(t,e,s)]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[this.getFillVoxel(t,e,s)]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(;i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setId(this.getFillVoxel(t,e,s)).setXYZ(t,i,s).paint(),i++}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.999)return void D.generateOakTree(t,e+1,s);if(r>.85&&r<.89)return void U.generateRandomPlant(this.nodes,t,e+1,s)}if(i&&o==p.Sand){const r=Math.random();if(r>.88&&r<.89)return void U.generateRandomPlant(this.nodes,t,e+1,s);if(r>2e-4&&r<.005)return void U.generateReed(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Rt}}const[Ft,Mt]=[1e3,1e4];class Ut extends C{static data={id:"icy-beach",heightBlendFactor:.5,color:[230,230,85],edgeBiomes:[],minHeight:60};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+Ft)/480,0,(s+Mt)/480))/2*5+this.nodes.minHeight}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setData(m[p.Sand]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Sand]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(;i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setId(p.Sand).setXYZ(t,i,s).paint(),i++}decorate(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();o&&a==p.Sand&&Math.random()<.95&&r.setId(p.Snow).setXYZ(t,e+1,s).paint()}getData(){return this.getClass().data}getClass(){return Ut}}const[Et,Nt]=[1e3,1e4];class Pt extends C{static data={id:"shallow-ocean",heightBlendFactor:1,color:[0,119,128],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[kt.data.id,a([0,1],void 0,[-1,.6])],[Rt.data.id,a(void 0,void 0,[.6,1])],[Ut.data.id,a([-1,-.5],void 0,[-1,.6])]]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((t+Et)/480,0,(s+Nt)/480))/2*40}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(t,e,s)?.getStringId();if(a&&n==p.Stone){r.setData(m[p.Dirt]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(r.setId(p.Water).setLevel(7);i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setXYZ(t,i,s).paint(),i++;r.setLevel(0)}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s),o=i?.isAir()||i?.isRenderable()&&r.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,a=r.getVoxel(t,e,s)?.getStringId();if(o&&(a==p.Dirt||a==p.Sand)){const r=Math.random();if(r>.87&&r<.89)return void U.generateKelp(this.nodes,t,e+1,s);if(r>.98)return void U.generateWaterPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Pt}}const[Ht,Gt]=[1e3,1e4];class Qt extends C{static data={id:"tropical-ocean",heightBlendFactor:1,color:[10,231,247],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[kt.data.id,a([0,1],void 0,[-1,.6])],[Rt.data.id,a(void 0,void 0,[.6,1])],[Ut.data.id,a([-1,-.5],void 0,[-1,.6])]]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((t+Ht)/480,0,(s+Gt)/480))/2*40}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(t,e,s)?.getStringId();if(a&&n==p.Stone){r.setData(m[p.Dirt]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(r.setId(p.Water).setLevel(7);i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setXYZ(t,i,s).paint(),i++;r.setLevel(0)}decorate(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(t,e,s)?.getStringId();if(a&&(n==p.Dirt||n==p.Sand)){const i=Math.random();if(i>.87&&i<.89)return void J.generateRandomCoral(t,e+1,s);if(i>.85&&i<.87)return void U.generateRandomCoral(this.nodes,t,e+1,s);if(i>.8&&i<.82)return void r.setId(p.SeaLantern).setXYZ(t,e+1,s).paint();if(i>.98)return void U.generateWaterPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Qt}}const[Ot,Yt]=[1e3,1e4];class Xt extends C{static data={id:"deep-ocean",heightBlendFactor:1,color:[2,83,89],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[kt.data.id,a([0,1],void 0,[-1,.6])],[Rt.data.id,a(void 0,void 0,[.6,1])],[Ut.data.id,a([-1,-.5],void 0,[-1,.6])]]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((t+Ot)/480,0,(s+Yt)/480))/2*50}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(t,e,s)?.getStringId();if(a&&n==p.Stone){r.setData(m[p.Dirt]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(r.setId(p.Water).setLevel(7);i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setXYZ(t,i,s).paint(),i++;r.setLevel(0)}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s),o=i?.isAir()||i?.isRenderable()&&r.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,a=r.getVoxel(t,e,s)?.getStringId();if(o&&(a==p.Dirt||a==p.Sand)){const r=Math.random();if(r>.87&&r<.89)return void U.generateKelp(this.nodes,t,e+1,s);if(r>.98)return void U.generateWaterPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Xt}}const[Zt,Wt]=[1e3,1e4];class qt extends C{static data={id:"frozen-ocean",heightBlendFactor:1,color:[57,99,102],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[kt.data.id,a([0,1])],[Rt.data.id,a(void 0,void 0,[.7,1])],[Ut.data.id,a([-1,-.5])]]};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((t+Zt)/480,0,(s+Wt)/480))/2*40}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid||!1,n=i.getVoxel(t,e,s)?.getStringId();if(a&&n==p.Stone){r.setData(m[p.Dirt]).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setData(m[p.Dirt]).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;Math.random()>.8&&r.setId(p.Ice).setXYZ(t,this.nodes.waterHeight+1,s).paint(),r.setId(p.Ice).setXYZ(t,this.nodes.waterHeight,s).paint();let i=e;for(r.setId(p.Water).setLevel(7);i<=this.nodes.waterHeight-1;)e<this.nodes.waterHeight-1&&r.setXYZ(t,i,s).paint(),i++;r.setLevel(0)}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s),o=i?.isAir()||i?.isRenderable()&&r.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid||!1,a=r.getVoxel(t,e,s)?.getStringId();if(o&&(a==p.Dirt||a==p.Sand)){const r=Math.random();if(r>.87&&r<.89)return void U.generateKelp(this.nodes,t,e+1,s);if(r>.98)return void U.generateWaterPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return qt}}class jt extends A{static data={id:"ocean",color:[2,83,89],biomes:[[Pt.data.id,a([-.2,.4],[0,1],[-.4,0])],[Qt.data.id,a([.8,1],[0,1],[-.1,0])],[Xt.data.id,a([-1,.4],[0,1],[-1,-.5])],[qt.data.id,a([-1,-.5],[0,1],[-.5,0])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return jt}}const[$t,Kt]=[1e3,1e4];class Jt extends C{static data={id:"river-bank",heightBlendFactor:.25,color:[43,26,1],edgeBiomes:[],minHeight:60};caveCarver=new N(this.nodes);getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}noiseQuery(t,e,s){return(1+this.nodes.noise.worldGenNoise((t+$t)/120,e/120,(s+Kt)/120))/2}getHeight(t,e,s){return 5*this.noiseQuery(t,0,s)+(this.nodes.waterHeight+5)}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s)?.isAir()||!0,a=i.getVoxel(t,e,s)?.getStringId();if(o&&a==p.Stone){r.setId(this.getFillVoxel(t,e,s,!0)).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setId(this.getFillVoxel(t,e-1-i,s)).setXYZ(t,e-1-i,s).paint();return!0}return!1}getFillVoxel(t,e,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(t/20+10,e/20+100,s/20+10))/2;return i>.5&&i<1?p.Sand:i>.3&&i<.5?r?p.GrassBlock:p.Dirt:p.Gravel}fill(t,e,s){const r=this.nodes.brush,i=r.dataCursor;let o=e;for(;o<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&(i.getVoxel(t,e,s)?.isRenderable()||r.setId(this.getFillVoxel(t,o,s,o==this.nodes.waterHeight)).setXYZ(t,o,s).paint()),o++}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s)?.isAir()||!0,o=r.getVoxel(t,e,s)?.getStringId();if(i&&o==p.GrassBlock){const r=Math.random();if(r>.99)return void D.generateOakTree(t,e+1,s);if(r>.9&&r<.92)return void U.generateReed(this.nodes,t,e+1,s);if(r>0&&r<.1)return void U.generateRandomPlant(this.nodes,t,e+1,s)}}getData(){return this.getClass().data}getClass(){return Jt}}const[te,ee]=[1e3,1e4];class se extends C{static data={id:"river",heightBlendFactor:.25,color:[3,206,252],edgeFactor:[0,0,0,[.1,.3]],edgeBiomes:[[Jt.data.id,a()]]};caveCarver=new N(this.nodes);isRiver=!0;getGenVoxel(t,e,s){return m[p.Stone]}getCarved(t,e,s){return G.getCarved(t,e,s)}getBlendtoHeight(t,e,s){return this.nodes.waterHeight}getHeight(t,e,s){return this.nodes.waterHeight-5-(1+this.nodes.noise.worldGenNoise((t+te)/480,0,(s+ee)/480))/2*5}getLayerVoxel(t,e,s){const r=(1+this.nodes.noise.worldGenNoise(t/200,e/200,s/200))/2;return r>=.7?p.Gravel:r<.7&&r>.4?p.Dirt:r<=.4&&r>.2?p.Sand:p.Clay}addTopLayer(t,e,s){const r=this.nodes.brush,i=r.dataCursor,o=i.getVoxel(t,e+1,s),a=o?.isAir()||o?.isRenderable()&&i.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(t,e,s)?.getStringId();if(a&&n==p.Stone){r.setId(this.getLayerVoxel(t,e,s)).setXYZ(t,e,s).paint();let i=5;for(;i--;)r.setId(this.getLayerVoxel(t,e-1,s)).setXYZ(t,e-1-i,s).paint();return!0}return!1}fill(t,e,s){const{brush:r}=this.nodes;let i=e;for(r.setId(p.Water).setLevel(7);i<=this.nodes.waterHeight;)e<this.nodes.waterHeight&&r.setXYZ(t,i,s).paint(),i++;r.setLevel(0)}decorate(t,e,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(t,e+1,s),o=i?.isAir()||i?.isRenderable()&&r.getVoxel(t,e+1,s).getSubstanceData().dve_is_liquid,a=r.getVoxel(t,e,s)?.getStringId();o&&(a==p.Dirt||a==p.Sand)&&e<this.nodes.waterHeight-1&&Math.random()>.98&&U.generateWaterPlant(this.nodes,t,e+1,s)}getData(){return this.getClass().data}getClass(){return se}}class re extends A{static data={id:"river",color:[0,228,245],biomes:[[se.data.id,a()]],edgeBiomeTypes:[]};isRiver=!0;getData(){return this.getClass().data}getClass(){return re}}const ie=-.35,oe=.8,ae={id:"overworld",biomeTypes:[[rt.data.id,a([.6,1],[-1,-.5],[ie,oe])],[q.data.id,a([-1,-.8],[-.7,0],[ie,oe])],[jt.data.id,a([-1,.5],[.1,1],[-1,ie],void 0,void 0,!1,!1,!1,!0,!1,!0)],[It.data.id,a([-.2,.5],[-.5,-.2],[ie,oe])],[ft.data.id,a([-.2,.3],[-.55,-.1],[ie,oe])],[_t.data.id,a([-.4,.7],[-1,0],[oe,1])],[re.data.id,a([-1,1],[-1,1],[ie,oe-.2],[.3,1.2],void 0,!1,!1,!1,!0)]]};var ne=s(99559),de=s.n(ne),le=s(92697);class he{worldGenNoise;detailNoise;orePerlin;worldDetailNoise;worldGenDetailNoise;biomeNoise;biomeDetailNoise;biomeTypeMoistureNoise;biomeTypeTemperatureNoise;biomeTypeElevationNoise;biomeTypeRiverNoise;oreNoise;init(t){this.worldGenNoise=(0,le.Cf)(de()(`${t.worldNoise}`)),this.detailNoise=(0,le.Cf)(de()(`${t.detailNoise}`)),this.biomeNoise=(0,le.fu)(de()(`${t.biomeNoise}`)),this.biomeTypeMoistureNoise=(0,le.fu)(de()(`${t.biomeTypeMoistureNoise}`)),this.biomeTypeTemperatureNoise=(0,le.fu)(de()(`${t.biomeTypeTemperatureNoise}`)),this.biomeTypeElevationNoise=(0,le.fu)(de()(`${t.biomeTypeElevationNoise}`)),this.biomeDetailNoise=(0,le.Cf)(de()(`${t.biomeDetailNoise}`)),this.biomeTypeRiverNoise=(0,le.fu)(de()(t.biomeTypeRiverNoise)),this.oreNoise=(0,le.Cf)(de()(t.oreNoise)),this.worldDetailNoise=(0,le.Cf)(de()(t.worldDetailNoise)),this.worldGenDetailNoise=(0,le.Cf)(de()(t.worldGenDetailNoise)),console.log("noise",this.biomeTypeElevationNoise(123,31290),this.biomeTypeElevationNoise(239048230,42304),this.biomeTypeTemperatureNoise(209348,238490))}}var ce=s(62567);const ue=new i.T;let ge;class fe{static instance;nodes;overWorldGen;constructor(){if(fe.instance)return fe.instance;fe.instance=this}init(){c.registerBiomeTypes(jt,q,ft,_t,rt,It,re),c.registerBiomes(Y,K,st,ut,gt,W,Tt,bt,at,Ut,Rt,At,lt,yt,At,Pt,kt,Xt,qt,Qt,se,Jt),c.registerCaveCarver(N,H,f),r.J.setWorldGen(this);const t=new he;this.nodes=new o,t.init({biomeNoise:8394723847382,biomeDetailNoise:7089879878979,biomeTypeMoistureNoise:2748927489274,biomeTypeTemperatureNoise:1748927483928,biomeTypeElevationNoise:7384723847938,biomeTypeRiverNoise:3472983472983,worldNoise:1892738192738,detailNoise:3928743928743,oreNoise:1928371928371,worldDetailNoise:4938274938274,worldGenDetailNoise:0xefabe3fe05}),this.nodes.init({noise:t,brush:ue}),this.overWorldGen=new S(this.nodes,ae),this.overWorldGen.init(),D.init(this.nodes),G.init(this.nodes),J.init(this.nodes)}async generate([[t,e,s,r],i]){ue.start(t,e,s,r),this.overWorldGen.generateWorldColumn(e,r),ue.stop()}async decorate([[t,e,s,r],i]){ue.start(t,e,s,r),this.overWorldGen.decorateWorldColumn(e,r),clearTimeout(ge),ge=setTimeout((()=>this.overWorldGen.clearCache()),6e4),ue.stop()}}ce.QK.registerTask("get-biome-image",(([t,e])=>{const s=fe.instance.overWorldGen.generateBiomeTypeImage(t,e);return[s,[s.buffer]]}))},87706:(t,e,s)=>{s.d(e,{P:()=>i});var r=s(55935);class i{buffer;data;constructor(t){return this.buffer=t,this.data=new DataView(ArrayBuffer.isView(t)?t.buffer:t),new Proxy(this,{get:(t,e)=>{if("string"==typeof e&&!isNaN(Number(e))){const s=Number(e);return t.get(s)}return t[e]},set:(t,e,s)=>{if("string"==typeof e&&!isNaN(Number(e))){const r=Number(e);return t.set(r,s),!0}return t[e]=s,!0}})}get length(){return 8*this.buffer.byteLength}get(t){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);return r.u.getBitArrayIndexView(this.data,0,t)}set(t,e){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);if(e<0||e>1)throw new RangeError(`Value ${e} is out of bounds for a bit`);r.u.setBitArrayIndexView(this.data,0,t,e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.get(t++),done:!1}:{value:void 0,done:!0}}}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}}},48493:(t,e,s)=>{var r,i;s.d(e,{QI:()=>r,Yd:()=>o,bI:()=>i}),function(t){t[t.Int8=0]="Int8",t[t.Uint8=1]="Uint8",t[t.Uint8Clamped=2]="Uint8Clamped",t[t.Int16=3]="Int16",t[t.Uint16=4]="Uint16",t[t.Float32=5]="Float32",t[t.Int32=6]="Int32",t[t.Uint32=7]="Uint32",t[t.Float64=8]="Float64",t[t.BigInt=9]="BigInt",t[t.BigUint=10]="BigUint"}(r||(r={})),function(t){t[t.Int8=1]="Int8",t[t.Uint8=1]="Uint8",t[t.Uint8Clamped=1]="Uint8Clamped",t[t.Int16=2]="Int16",t[t.Uint16=2]="Uint16",t[t.Float32=4]="Float32",t[t.Int32=4]="Int32",t[t.Uint32=4]="Uint32",t[t.Float64=8]="Float64",t[t.BigInt=8]="BigInt",t[t.BigUint=8]="BigUint"}(i||(i={}));const o={[r.Int8]:i.Int8,[r.Uint8]:i.Uint8,[r.Uint8Clamped]:i.Uint8Clamped,[r.Int16]:i.Int16,[r.Uint16]:i.Uint16,[r.Float32]:i.Float32,[r.Int32]:i.Int32,[r.Uint32]:i.Uint32,[r.Float64]:i.Float64,[r.BigInt]:i.BigInt,[r.BigUint]:i.BigUint}},55935:(t,e,s)=>{s.d(e,{u:()=>i});var r=s(36713);class i{static getBitArrayIndexView(t,e,s){const i=s/8|0,o=s-8*i,a=t.getUint8(i+e);return r.y.getBitValue(a,o,1)}static setBitArrayIndexView(t,e,s,i){const o=s/8|0,a=s-8*o,n=t.getUint8(o+e);t.setUint8(o+e,r.y.setBitValue(n,a,i,1))}static getBitArrayIndex(t,e,s){const i=s/8|0,o=s-8*i,a=t[i+e];return r.y.getBitValue(a,o,1)}static setBitArrayIndex(t,e,s,i){const o=s/8|0,a=s-8*o,n=t[o+e];t[o+e]=r.y.setBitValue(n,a,i,1)}static getNibbleArrayIndex(t,e,s){const i=s/2|0,o=s%2==0,a=t.getUint8(i+e);return r.y.getBitValue(a,o?4:0,4)}static setNibbleArrayIndex(t,e,s,i){const o=s/2|0,a=s%2==0,n=t.getUint8(o+e);t.setUint8(o+e,r.y.setBitValue(n,a?4:0,i,4))}static getHalfNibbleArrayIndex(t,e,s){const i=s/4|0,o=s%4,a=t.getUint8(i+e);return r.y.getBitValue(a,2*o,2)}static setHalfNibbleArrayIndex(t,e,s,i){const o=s/4|0,a=s%4,n=t.getUint8(o+e);t.setUint8(o+e,r.y.setBitValue(n,2*a,i,2))}}},36713:(t,e,s)=>{s.d(e,{y:()=>a});var r=s(34676),i=s(48493),o=s(85648);class a{static setTypedNumber(t,e,s,r){return o.v[s](t,e,r)}static getTypedNumber(t,e,s){return r.n[s](t,e)}static calculateBitsNeeded(t,e){let s=e-t;return Math.ceil(Math.log2(s))}static getTypedSize(t){return i.Yd[t]}static getBitValue(t,e,s){return(2**s-1<<e&t)>>>e}static setBitValue(t,e,s,r){const i=2**r-1;return t&~(i<<e)|(s&i)<<e}}},34676:(t,e,s)=>{s.d(e,{n:()=>i});var r=s(48493);const i={[r.QI.Int8]:(t,e)=>t.getInt8(e),[r.QI.Uint8]:(t,e)=>t.getUint8(e),[r.QI.Uint8Clamped]:(t,e)=>t.getUint8(e),[r.QI.Int16]:(t,e)=>t.getInt16(e,!0),[r.QI.Uint16]:(t,e)=>t.getUint16(e,!0),[r.QI.Float32]:(t,e)=>t.getFloat32(e,!0),[r.QI.Int32]:(t,e)=>t.getInt32(e,!0),[r.QI.Uint32]:(t,e)=>t.getUint32(e,!0),[r.QI.Float64]:(t,e)=>t.getFloat64(e,!0),[r.QI.BigInt]:(t,e)=>t.getBigInt64(e,!0),[r.QI.BigUint]:(t,e)=>t.getBigUint64(e,!0)}},85648:(t,e,s)=>{s.d(e,{v:()=>i});var r=s(48493);const i={[r.QI.Int8]:(t,e,s)=>t.setInt8(e,s),[r.QI.Uint8]:(t,e,s)=>t.setUint8(e,s),[r.QI.Uint8Clamped]:(t,e,s)=>t.setUint8(e,s),[r.QI.Int16]:(t,e,s)=>t.setInt16(e,s,!0),[r.QI.Uint16]:(t,e,s)=>t.setUint16(e,s,!0),[r.QI.Float32]:(t,e,s)=>t.setFloat32(e,s,!0),[r.QI.Int32]:(t,e,s)=>t.setInt32(e,s,!0),[r.QI.Uint32]:(t,e,s)=>t.setUint32(e,s,!0),[r.QI.Float64]:(t,e,s)=>t.setFloat64(e,s,!0),[r.QI.BigInt]:(t,e,s)=>t.setBigInt64(e,s,!0),[r.QI.BigUint]:(t,e,s)=>t.setBigUint64(e,s,!0)}},71280:(t,e,s)=>{var r,i;s.d(e,{$f:()=>r,xH:()=>i}),function(t){t.North="north",t.South="south",t.West="west",t.East="east",t.NorthEast="north-east",t.NorthWest="north-west",t.SouthEast="south-east",t.SouthWest="south-west"}(r||(r={})),function(t){t[t.North=0]="North",t[t.NorthEast=Math.PI/4]="NorthEast",t[t.East=Math.PI/2]="East",t[t.SouthEast=3*Math.PI/4]="SouthEast",t[t.South=Math.PI]="South",t[t.SouthWest=5*Math.PI/4]="SouthWest",t[t.West=3*Math.PI/2]="West",t[t.NorthWest=7*Math.PI/4]="NorthWest"}(i||(i={})),r.North,i.North,r.South,i.South,r.West,i.West,r.East,i.East,r.NorthEast,i.NorthEast,r.NorthWest,i.NorthWest,r.SouthEast,i.SouthEast,r.SouthWest,i.SouthWest},64617:(t,e,s)=>{s.d(e,{Jd:()=>r.J});var r=s(89569)},94176:(t,e,s)=>{function r(t,e,s,r){var i=e-t,o=r-s;return Math.sqrt(i*i+o*o)}s.d(e,{m:()=>r})},31373:(t,e,s)=>{function r(t,e,s,r,i,o){return Math.sqrt((r-t)**2+(i-e)**2+(o-s)**2)}s.d(e,{D:()=>r})},60485:(t,e,s)=>{s.d(e,{D7:()=>i.D,me:()=>r.m});var r=s(94176),i=s(31373)},93942:(t,e,s)=>{s.d(e,{Z:()=>r});class r{x;y;z;w;static Create(t=0,e=0,s=0,i=0){return new r(t,e,s,i)}static ApplyMatrix(t,e){return{x:t[0]*e.x+t[1]*e.y+t[2]*e.z+t[3]*e.w,y:t[4]*e.x+t[5]*e.y+t[6]*e.z+t[7]*e.w,z:t[8]*e.x+t[9]*e.y+t[10]*e.z+t[11]*e.w,w:t[12]*e.x+t[13]*e.y+t[14]*e.z+t[15]*e.w}}static ApplyMatrixArray(t,e){return[t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3],t[4]*e[0]+t[5]*e[1]+t[6]*e[2]+t[7]*e[3],t[8]*e[0]+t[9]*e[1]+t[10]*e[2]+t[11]*e[3],t[12]*e[0]+t[13]*e[1]+t[14]*e[2]+t[15]*e[3]]}static RotateAroundPivot(t,e,s){const i={x:e.x-s.x,y:e.y-s.y,z:e.z-s.z,w:e.w-s.w},o=r.ApplyMatrix(t,i);return{x:o.x+s.x,y:o.y+s.y,z:o.z+s.z,w:o.w+s.w}}static RotateAroundPivotArray(t,e,s){const i=[e[0]-s[0],e[1]-s[1],e[2]-s[2],e[3]-s[3]],o=r.ApplyMatrixArray(t,i);return[o[0]+s[0],o[1]+s[1],o[2]+s[2],o[3]+s[3]]}static Add(t,e){return{x:t.x+e.x,y:t.y+e.y,z:t.z+e.z,w:t.w+e.w}}static AddToRef(t,e,s){s.x=t.x+e.x,s.y=t.y+e.y,s.z=t.z+e.z,s.w=t.w+e.w}static AddInPlace(t,e){t.x+=e.x,t.y+=e.y,t.z+=e.z,t.w+=e.w}static AddArray(t,e){return[t[0]+e[0],t[1]+e[1],t[2]+e[2],t[3]+e[3]]}static AddArrayToRef(t,e,s){s[0]=t[0]+e[0],s[1]=t[1]+e[1],s[2]=t[2]+e[2],s[3]=t[3]+e[3]}static AddArrayInPlace(t,e){t[0]+=e[0],t[1]+=e[1],t[2]+=e[2],t[3]+=e[3]}static AddScalar(t,e){return{x:t.x+e,y:t.y+e,z:t.z+e,w:t.w+e}}static AddScalarToRef(t,e,s){s.x=t.x+e,s.y=t.y+e,s.z=t.z+e,s.w=t.w+e}static AddScalarInPlace(t,e){t.x+=e,t.y+=e,t.z+=e,t.w+=e}static AddScalarArray(t,e){return[t[0]+e,t[1]+e,t[2]+e,t[3]+e]}static AddScalarArrayToRef(t,e,s){s[0]=t[0]+e,s[1]=t[1]+e,s[2]=t[2]+e,s[3]=t[3]+e}static AddScalarArrayInPlace(t,e){t[0]+=e,t[1]+=e,t[2]+=e,t[3]+=e}static Subtract(t,e){return{x:t.x-e.x,y:t.y-e.y,z:t.z-e.z,w:t.w-e.w}}static SubtractToRef(t,e,s){s.x=t.x-e.x,s.y=t.y-e.y,s.z=t.z-e.z,s.w=t.w-e.w}static SubtractInPlace(t,e){t.x-=e.x,t.y-=e.y,t.z-=e.z,t.w-=e.w}static SubtractArray(t,e){return[t[0]-e[0],t[1]-e[1],t[2]-e[2],t[3]-e[3]]}static SubtractArrayToRef(t,e,s){s[0]=t[0]-e[0],s[1]=t[1]-e[1],s[2]=t[2]-e[2],s[3]=t[3]-e[3]}static SubtractArrayInPlace(t,e){t[0]-=e[0],t[1]-=e[1],t[2]-=e[2],t[3]-=e[3]}static SubtractScalar(t,e){return{x:t.x-e,y:t.y-e,z:t.z-e,w:t.w-e}}static SubtractScalarToRef(t,e,s){s.x=t.x-e,s.y=t.y-e,s.z=t.z-e,s.w=t.w-e}static SubtractScalarInPlace(t,e){t.x-=e,t.y-=e,t.z-=e,t.w-=e}static SubtractScalarArray(t,e){return[t[0]-e,t[1]-e,t[2]-e,t[3]-e]}static SubtractScalarArrayToRef(t,e,s){s[0]=t[0]-e,s[1]=t[1]-e,s[2]=t[2]-e,s[3]=t[3]-e}static SubtractScalarArrayInPlace(t,e){t[0]-=e,t[1]-=e,t[2]-=e,t[3]-=e}static Multiply(t,e){return{x:t.x*e.x,y:t.y*e.y,z:t.z*e.z,w:t.w*e.w}}static MultiplyToRef(t,e,s){s.x=t.x*e.x,s.y=t.y*e.y,s.z=t.z*e.z,s.w=t.w*e.w}static MultiplyInPlace(t,e){t.x*=e.x,t.y*=e.y,t.z*=e.z,t.w*=e.w}static MultiplyArray(t,e){return[t[0]*e[0],t[1]*e[1],t[2]*e[2],t[3]*e[3]]}static MultiplyArrayToRef(t,e,s){s[0]=t[0]*e[0],s[1]=t[1]*e[1],s[2]=t[2]*e[2],s[3]=t[3]*e[3]}static MultiplyArrayInPlace(t,e){t[0]*=e[0],t[1]*=e[1],t[2]*=e[2],t[3]*=e[3]}static MultiplyScalar(t,e){return{x:t.x*e,y:t.y*e,z:t.z*e,w:t.w*e}}static MultiplyScalarToRef(t,e,s){s.x=t.x*e,s.y=t.y*e,s.z=t.z*e,s.w=t.w*e}static MultiplyScalarInPlace(t,e){t.x*=e,t.y*=e,t.z*=e,t.w*=e}static MultiplyScalarArray(t,e){return[t[0]*e,t[1]*e,t[2]*e,t[3]*e]}static MultiplyScalarArrayToRef(t,e,s){s[0]=t[0]*e,s[1]=t[1]*e,s[2]=t[2]*e,s[3]=t[3]*e}static MultiplyScalarArrayInPlace(t,e){t[0]*=e,t[1]*=e,t[2]*=e,t[3]*=e}static Divide(t,e){return{x:t.x/e.x,y:t.y/e.y,z:t.z/e.z,w:t.w/e.w}}static DivideToRef(t,e,s){s.x=t.x/e.x,s.y=t.y/e.y,s.z=t.z/e.z,s.w=t.w/e.w}static DivideInPlace(t,e){t.x/=e.x,t.y/=e.y,t.z/=e.z,t.w/=e.w}static DivideArray(t,e){return[t[0]/e[0],t[1]/e[1],t[2]/e[2],t[3]/e[3]]}static DivideArrayToRef(t,e,s){s[0]=t[0]/e[0],s[1]=t[1]/e[1],s[2]=t[2]/e[2],s[3]=t[3]/e[3]}static DivideArrayInPlace(t,e){t[0]/=e[0],t[1]/=e[1],t[2]/=e[2],t[3]/=e[3]}static DivideScalar(t,e){return{x:t.x/e,y:t.y/e,z:t.z/e,w:t.w/e}}static DivideScalarToRef(t,e,s){s.x=t.x/e,s.y=t.y/e,s.z=t.z/e,s.w=t.w/e}static DivideScalarInPlace(t,e){t.x/=e,t.y/=e,t.z/=e,t.w/=e}static DivideScalarArray(t,e){return[t[0]/e,t[1]/e,t[2]/e,t[3]/e]}static DivideScalarArrayToRef(t,e,s){s[0]=t[0]/e,s[1]=t[1]/e,s[2]=t[2]/e,s[3]=t[3]/e}static DivideScalarArrayInPlace(t,e){t[0]/=e,t[1]/=e,t[2]/=e,t[3]/=e}static Dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z+t.w*e.w}static DotArray(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w)}static LengthArray(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]+t[3]*t[3])}static Normalize(t){const e=r.Length(t);return 0===e?{x:0,y:0,z:0,w:0}:{x:t.x/e,y:t.y/e,z:t.z/e,w:t.w/e}}static NormalizeToRef(t,e){const s=r.Length(t);0===s?(e.x=0,e.y=0,e.z=0,e.w=0):(e.x=t.x/s,e.y=t.y/s,e.z=t.z/s,e.w=t.w/s)}static NormalizeInPlace(t){const e=r.Length(t);0===e?(t.x=0,t.y=0,t.z=0,t.w=0):(t.x/=e,t.y/=e,t.z/=e,t.w/=e)}static NormalizeArray(t){const e=r.LengthArray(t);return 0===e?[0,0,0,0]:[t[0]/e,t[1]/e,t[2]/e,t[3]/e]}static NormalizeArrayToRef(t,e){const s=r.LengthArray(t);0===s?(e[0]=0,e[1]=0,e[2]=0,e[3]=0):(e[0]=t[0]/s,e[1]=t[1]/s,e[2]=t[2]/s,e[3]=t[3]/s)}static NormalizeArrayInPlace(t){const e=r.LengthArray(t);0===e?(t[0]=0,t[1]=0,t[2]=0,t[3]=0):(t[0]/=e,t[1]/=e,t[2]/=e,t[3]/=e)}static Distance(t,e){return r.Length(r.Subtract(t,e))}static DistanceArray(t,e){return r.LengthArray(r.SubtractArray(t,e))}static Lerp(t,e,s){return{x:t.x+s*(e.x-t.x),y:t.y+s*(e.y-t.y),z:t.z+s*(e.z-t.z),w:t.w+s*(e.w-t.w)}}static LerpToRef(t,e,s,r){r.x=t.x+s*(e.x-t.x),r.y=t.y+s*(e.y-t.y),r.z=t.z+s*(e.z-t.z),r.w=t.w+s*(e.w-t.w)}static LerpInPlace(t,e,s){t.x+=s*(e.x-t.x),t.y+=s*(e.y-t.y),t.z+=s*(e.z-t.z),t.w+=s*(e.w-t.w)}static LerpArray(t,e,s){return[t[0]+s*(e[0]-t[0]),t[1]+s*(e[1]-t[1]),t[2]+s*(e[2]-t[2]),t[3]+s*(e[3]-t[3])]}static LerpArrayToRef(t,e,s,r){r[0]=t[0]+s*(e[0]-t[0]),r[1]=t[1]+s*(e[1]-t[1]),r[2]=t[2]+s*(e[2]-t[2]),r[3]=t[3]+s*(e[3]-t[3])}static LerpArrayInPlace(t,e,s){t[0]+=s*(e[0]-t[0]),t[1]+=s*(e[1]-t[1]),t[2]+=s*(e[2]-t[2]),t[3]+=s*(e[3]-t[3])}static Negate(t){return{x:-t.x,y:-t.y,z:-t.z,w:-t.w}}static NegateToRef(t,e){e.x=-t.x,e.y=-t.y,e.z=-t.z,e.w=-t.w}static NegateInPlace(t){t.x=-t.x,t.y=-t.y,t.z=-t.z,t.w=-t.w}static NegateArray(t){return[-t[0],-t[1],-t[2],-t[3]]}static NegateArrayToRef(t,e){e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3]}static NegateArrayInPlace(t){t[0]=-t[0],t[1]=-t[1],t[2]=-t[2],t[3]=-t[3]}static Equals(t,e){return t.x===e.x&&t.y===e.y&&t.z===e.z&&t.w===e.w}static EqualsArray(t,e){return t[0]===e[0]&&t[1]===e[1]&&t[2]===e[2]&&t[3]===e[3]}static Clone(t){return{x:t.x,y:t.y,z:t.z,w:t.w}}static CloneArray(t){return[t[0],t[1],t[2],t[3]]}static Copy(t,e){return t.x=e.x,t.y=e.y,t.z=e.z,t}static CopyArray(t,e){return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}static CopyFromArray(t,e){return t.x=e[0],t.y=e[1],t.z=e[2],t}static CopyIntoArray(t,e){return t[0]=e.x,t[1]=e.y,t[2]=e.z,t}static ToArray(t){return[t.x,t.y,t.z,t.w]}static FromArray(t){return new r(t[0],t[1],t[2],t[3])}constructor(t,e,s,r){this.x=t,this.y=e,this.z=s,this.w=r}}},5919:(t,e,s)=>{s.d(e,{Az:()=>i.A,D7:()=>a.D7,ZS:()=>o.Z,me:()=>a.me,xt:()=>r.x});var r=s(79104),i=s(68823),o=s(93942),a=s(60485)},15457:(t,e,s)=>{s.d(e,{F:()=>r});class r{_getIndex;_getXYZ;position;bounds;constructor(t,e){this._getIndex=t,this._getXYZ=e,this.position=[0,0,0],this.bounds=[1,1,1]}static GetXZYOrder(){return new r(((t,e)=>t[0]+t[2]*e[0]+t[1]*e[0]*e[2]),((t,e,s)=>{s[1]=Math.floor(t/(e[0]*e[2])),s[2]=Math.floor(t%(e[0]*e[2])/e[0]),s[0]=Math.floor(t%e[0])}))}static GetXYZOrder(){return new r(((t,e)=>t[0]+t[1]*e[0]+t[2]*e[0]*e[1]),((t,e,s)=>{s[2]=Math.floor(t/(e[0]*e[1])),s[1]=Math.floor(t%(e[0]*e[1])/e[0]),s[0]=Math.floor(t%e[0])}))}static GetYXZOrder(){return new r(((t,e)=>t[1]+e[1]*(t[0]+e[0]*t[2])),((t,e,s)=>{s[2]=Math.floor(t/(e[0]*e[1])),s[0]=Math.floor(t%(e[0]*e[1])/e[1]),s[1]=t%e[1]}))}get size(){return this.bounds[0]*this.bounds[1]*this.bounds[2]}getIndex(t){return this._getIndex(t,this.bounds)}getIndexVec3Array(t){return this.position[0]=t[0],this.position[1]=t[1],this.position[2]=t[2],this._getIndex(this.position,this.bounds)}getIndexXYZ(t,e,s){return this.position[0]=t,this.position[1]=e,this.position[2]=s,this._getIndex(this.position,this.bounds)}getIndexVec3(t){return this.position[0]=t.x,this.position[1]=t.y,this.position[2]=t.z,this._getIndex(this.position,this.bounds)}output=[0,0,0];getXYZ(t){return this._getXYZ(t,this.bounds,this.output),this.output}setBounds(t,e,s){this.bounds[0]=t,this.bounds[1]=e,this.bounds[2]=s}}},62097:(t,e,s)=>{s.d(e,{F:()=>r.F});var r=s(15457)},34052:(t,e,s)=>{s.d(e,{l:()=>r});class r{static ForEachFromToVec2(t,e,s,r){const i=t[0]<e[0]?s:-s,o=t[1]<e[1]?s:-s;for(let s=t[0];i>0?s<=e[0]:s>=e[0];s+=i)for(let i=t[1];o>0?i<=e[1]:i>=e[1];i+=o)r(s,i)}static*FromToVec2(t,e,s){const r=t[0]<e[0]?s:-s,i=t[1]<e[1]?s:-s;for(let s=t[0];r>0?s<=e[0]:s>=e[0];s+=r)for(let r=t[1];i>0?r<=e[1]:r>=e[1];r+=i)yield{x:s,y:r}}static ForEachFromToVec3(t,e,s,r){const i=t[0]<e[0]?s:-s,o=t[1]<e[1]?s:-s,a=t[2]<e[2]?s:-s;for(let s=t[0];i>0?s<=e[0]:s>=e[0];s+=i)for(let i=t[1];o>0?i<=e[1]:i>=e[1];i+=o)for(let o=t[2];a>0?o<=e[2]:o>=e[2];o+=a)r(s,i,o)}static*FromToVec3(t,e,s){const r=t[0]<e[0]?s:-s,i=t[1]<e[1]?s:-s,o=t[2]<e[2]?s:-s;for(let s=t[0];r>0?s<=e[0]:s>=e[0];s+=r)for(let r=t[1];i>0?r<=e[1]:r>=e[1];r+=i)for(let i=t[2];o>0?i<=e[2]:i>=e[2];i+=o)yield{x:s,y:r,z:i}}}},46996:(t,e,s)=>{s.d(e,{F$:()=>r.F,l5:()=>i.l});var r=s(62097),i=s(34052)},61e3:(t,e,s)=>{s.d(e,{$f:()=>a.$f,Az:()=>r.Az,D7:()=>r.D7,F$:()=>i.F$,Jd:()=>o.Jd,ZS:()=>r.ZS,l5:()=>i.l5,me:()=>r.me,xH:()=>a.xH,xt:()=>r.xt});var r=s(5919),i=s(46996),o=s(64617),a=s(71280)},92149:(t,e,s)=>{s.d(e,{j:()=>a});var r=s(45238),i=s(2341),o=s(98296);class a{name;index;threadPoolName;static readySet=new Set;get isRemoteReady(){return a.readySet.has(this)}get isPortSet(){return Boolean(this.port)}port=null;_pool=null;constructor(t,e,s="worker",r=null){this.name=t,this.index=e,this.threadPoolName=s,this._pool=r}setPort(t){if(this.port=t,"browser"==r.Q.environment){const e=t;e.onmessage=t=>{if(o.E.isInternal(t.data))return o.E.runInternal(t.data,this,t)},e.onmessageerror=t=>{console.error(`Error occured in from thread ${this.name}`),console.log(t.data),console.log(t)}}if("node"==r.Q.environment){const e=t;e.on("message",(t=>{if(o.E.isInternal(t))return o.E.runInternal(t,this,t)})),e.on("error",(t=>{console.error(`Error occured in from thread ${this.name}`),console.log(t)}))}this.sendMessage([o.E.INTERNAL_CODE,i.g.setReady,[this.name,this.index]])}sendMessage(t,e){if(!this.port)throw new Error(`Cannot send message to thread [${this.name}] port is not set`);this.port.postMessage(t,"browser"==r.Q.environment&&e?e:void 0)}connectToThread(t){const e=new MessageChannel;t.sendMessage([o.E.INTERNAL_CODE,i.g.connectPort,[this.name,this.threadPoolName,e.port1]],[e.port1]),this.sendMessage([o.E.INTERNAL_CODE,i.g.connectPort,[t.name,t.threadPoolName,e.port2]],[e.port2])}waitTillTaskExist(t,e=50){let s=!1;return new Promise((r=>{const i=t=>{if(s)return clearTimeout(a);t?(s=!0,r(!0),clearTimeout(a)):setTimeout(o,e)},o=()=>{this.taskExist(t,i)};let a=setTimeout(o,e)}))}taskExist(t,e){const s=o.E.getPromiseId();o.z.checkTasks[2][0]=t,o.z.checkTasks[2][1]=s,this.sendMessage(o.z.checkTasks),o.E.addPromiseTakss("tasks-check",s,(t=>{e(t)}))}runTask(t,e,s,r){const i=r?o.E.getPromiseId():-1;r&&o.E.addPromiseTakss(t,i,r),o.z.runTask[2][0]=t,o.z.runTask[2][1]=i,o.z.runTask[2][2]=e,this.sendMessage(o.z.runTask,s),o.z.runTask[2][2]=null}runTaskAsync(t,e,s){return new Promise((r=>{this.runTask(t,e,s,(t=>{r(t)}))}))}waitTillReady(){return new Promise(((t,e)=>{const s=setInterval((()=>{this.isPortSet&&(clearInterval(s),t(!0))}),1)}))}destroy(){a.readySet.delete(this),this.port&&"terminate"in this.port&&this.port.terminate()}}},5767:(t,e,s)=>{s.d(e,{p:()=>o});var r=s(92149),i=s(45238);class o{name;_totalThreads=0;_currentThread=0;__threads=[];constructor(t){this.name=t}getThreads(){return this.__threads}connectToThread(t){for(const e of this.__threads)e.connectToThread(t)}destroyAll(){for(const t of this.__threads)t.destroy()}isReady(){let t=!0;for(const e of this.__threads)e.isPortSet||(t=!1);return t}waitTillAllAreReady(){return new Promise(((t,e)=>{const s=setInterval((()=>{this.isReady()&&(clearInterval(s),t(!0))}),1)}))}addPort(t){const e=`${this.name}-${this._totalThreads}`,s=new r.j(e,this._totalThreads,this.name,this);i.Q.addThread(s),s.setPort(t),this.__threads.push(s),this._totalThreads++}runTaskForAll(t,e,s){for(let r=0;r<this.__threads.length;r++)this.__threads[r].runTask(t,e,s)}runTask(t,e,s,r,i,o){return"number"!=typeof i?(this._currentThread==o&&this.__handleCount(),this.__threads[this._currentThread].runTask(t,e,s,r),this.__handleCount()):(this.__threads[i].runTask(t,e,s,r),i)}runTaskAsync(t,e,s,r,i){return new Promise((o=>{this.runTask(t,e,s,o,r,i)}))}__handleCount(){let t=this._currentThread;return this._currentThread++,this._currentThread>=this._totalThreads&&(this._currentThread=0),t}}},46348:(t,e,s)=>{function r(){}s.d(e,{A:()=>r})},69704:(t,e,s)=>{s.d(e,{A:()=>g});var r=s(44711),i=s(30729),o=s(61e3),a=s(76132),n=s(25012),d=s(41986),l=s(13163),h=s(83066);class c{index=o.F$.GetXZYOrder();size;ids;level;state;mod;secondary;idPalette;levelPalette;statePalette;modPalette;secondaryIdPalette;secondaryStatePalette;constructor(t){this.size=[...t.size],this.index.setBounds(...t.size),this.idPalette=new a.N(t.palettes.id),this.levelPalette=new n.h(t.palettes.level),this.statePalette=new n.h(t.palettes.state),this.modPalette=new n.h(t.palettes.mod),this.secondaryIdPalette=new a.N(t.palettes.secondaryId),this.secondaryStatePalette=new n.h(t.palettes.secondaryState),"object"==typeof t.buffers.ids?this.ids=(0,d.f)(t.palettes.id.length,t.buffers.ids):this.ids=t.buffers.ids,"object"==typeof t.buffers.level?this.level=(0,d.f)(t.palettes.level.length,t.buffers.level):this.level=t.buffers.level,"object"==typeof t.buffers.state?this.state=(0,d.f)(t.palettes.state.length,t.buffers.state):this.state=t.buffers.state,"object"==typeof t.buffers.mod?this.mod=(0,d.f)(t.palettes.mod.length,t.buffers.mod):this.mod=t.buffers.mod,"object"==typeof t.buffers.secondary?this.secondary=(0,d.f)(Math.max(t.palettes.secondaryState.length,t.palettes.secondaryId.length),t.buffers.secondary):this.secondary=t.buffers.secondary}getIndex(t,e,s){return this.index.getIndexXYZ(t,e,s)}getId(t){const e=this.ids;return l.A.voxels.getNumberId(this.idPalette.getStringId("number"==typeof e?e:e[t]))}getState(t){const e=this.state;return this.statePalette.getValue("number"==typeof e?e:e[t])}getLevel(t){const e=this.mod;return this.modPalette.getValue("number"==typeof e?e:e[t])}getMod(t){const e=this.mod;return this.modPalette.getValue("number"==typeof e?e:e[t])}getSecondary(t,e){const s=this.secondary;return h.L.VoxelTags[t].dve_can_have_secondary?l.A.voxels.getNumberId(this.secondaryIdPalette.getStringId("number"==typeof s?s:s[e])):this.secondaryStatePalette.getValue("number"==typeof s?s:s[e])}*traverse(){const t=this.size,e=[0,0,0,0,0,0],s={position:[0,0,0],raw:e};for(const{x:r,y:i,z:a}of o.l5.FromToVec3([0,0,0],[t[0]-1,t[1]-1,t[2]-1],1)){const t=this.index.getIndexXYZ(r,i,a);s.position[0]=r,s.position[1]=i,s.position[2]=a,e[0]=this.getId(t),e[1]=0,e[2]=this.getLevel(t),e[3]=this.getState(t),e[4]=this.getMod(t),e[5]=this.getSecondary(e[0],t),e[0]<1&&e[3]<1||(yield s)}}toJSON(){return{templatorVersion:0,version:0,size:this.size,palettes:{id:this.idPalette._palette,level:Uint8Array.from(this.statePalette._palette),state:Uint16Array.from(this.statePalette._palette),mod:Uint16Array.from(this.modPalette._palette),secondaryId:this.secondaryIdPalette._palette,secondaryState:Uint16Array.from(this.secondaryStatePalette._palette)},buffers:{ids:this.ids instanceof Uint16Array||this.ids instanceof Uint8Array||"number"==typeof this.ids?this.ids:new Uint8Array(this.ids.buffer),level:this.level instanceof Uint8Array||"number"==typeof this.level?this.level:new Uint8Array(this.level.buffer),mod:this.mod instanceof Uint16Array||this.mod instanceof Uint8Array||"number"==typeof this.mod?this.mod:new Uint8Array(this.mod.buffer),state:this.state instanceof Uint16Array||this.state instanceof Uint8Array||"number"==typeof this.state?this.state:new Uint8Array(this.state.buffer),secondary:this.secondary instanceof Uint16Array||this.secondary instanceof Uint8Array||"number"==typeof this.secondary?this.secondary:new Uint8Array(this.secondary.buffer)}}}}var u=s(62567);function g(){const t=i.J.getBrush();u.QK.registerTask(r.m.PlaceVoxelArea,(async([e,[s,r,i],[o,a,n],d])=>{t.start(e,s,r,i),t.setData(d);for(let e=s;e<o;e++)for(let s=r;s<a;s++)for(let r=i;r<n;r++)t.dataCursor.inBounds(e,s,r)&&t.setXYZ(e,s,r).paint();t.runUpdates();for(let e=s;e<o;e++)for(let s=r;s<a;s++)for(let r=i;r<n;r++)t.dataCursor.inBounds(e,s,r)&&t.setXYZ(e,s,r).update();t.runUpdates();const l=t.getUpdatedSections();return t.stop(),[l]})),u.QK.registerTask(r.m.RemoveVoxelArea,(([e,[s,r,i],[o,a,n]])=>{t.start(e,s,r,i);for(let e=s;e<o;e++)for(let s=r;s<a;s++)for(let r=i;r<n;r++)t.dataCursor.inBounds(e,s,r)&&t.dataCursor.getVoxel(e,s,r)?.isRenderable()&&t.setXYZ(e,s,r).erase();t.runUpdates(),r-=1,i-=1,o+=1,a+=1,n+=1;for(let e=s-=1;e<o;e++)for(let s=r;s<a;s++)for(let r=i;r<n;r++)t.dataCursor.inBounds(e,s,r)&&t.setXYZ(e,s,r).update();t.runUpdates();const d=t.getUpdatedSections();return t.stop(),[d]})),u.QK.registerTask(r.m.BuildTemplate,(async([e,[s,r,i],o],a)=>{t.start(e,s,r,i);const n=new c(o),d=s+n.size[0],l=r+n.size[1],h=i+n.size[2];await t.worldAlloc([s,r,i],[d,l,h]);for(const{raw:e,position:o}of n.traverse())e[1]=0,t.setRaw(e).setXYZ(o[0]+s,o[1]+r,o[2]+i).paint();t.runUpdates();for(let e=s;e<d;e++)for(let s=r;s<l;s++)for(let r=i;r<h;r++)t.dataCursor.inBounds(e,s,r)&&t.setXYZ(e,s,r).update();t.runUpdates();const u=t.getUpdatedSections();return t.stop(),await t.worldDealloc([s,r,i],[d,l,h]),[u]}))}},1323:(t,e,s)=>{s.d(e,{c:()=>n});var r=s(62567),i=s(82323);const o=r.QK.createThread("world");class a extends i.Q{static instnace;parent=r.QK.parent;world=o;constructor(){super(),a.instnace=this,this.addThread(this.world),this.addThread(this.parent)}}class n{static environment="browser";static instance;TC=r.QK;threads=new a;constructor(){if(n.instance)return n.instance;n.instance=this}}},82671:(t,e,s)=>{s.d(e,{V:()=>xs});var r=s(24042),i=s(1323),o=s(62567),a=s(32005),n=s(1481),d=s(75852),l=s(4974),h=s(95305),c=s(67568),u=s(45733),g=s(15660),f=s(18048),p=(s(38903),s(91669)),m=s(35609);class y{static _brush=new f.l;static _sDataTool=new m.p;static _nDataTool=new m.p;static setVoxel(t,e,s,r,i,o,a){}static setDimension(t){}static removeVoxel(t,e,s,r){}static getFlowRate(t){return 0}static getVoxel(t,e,s){return this._sDataTool}static setLevel(t,e,s,r){}static getLevel(t,e,s,r){}static getLevelState(t,e,s,r){}static canFlowOutwardTest(t,e,s,r){}static flowDownTest(t,e,s,r){}static wait(t){return new Promise(((e,s)=>setTimeout(e,t)))}static _lightValues=[0,0,0,0];static getAbsorbLight(t,e,s){}static sunCheck(t,e,s,r){}}async function x(t,e=!0){}const v=new c.P,b=t=>{let e=l.i.doRGBPropagation,s=l.i.doSunPropagation;const[r,i,o,a]=t.origin;t.nDataCursor.setFocalPoint(r,i,o,a);for(const r of h.LE){const n=r[0]+i,d=r[1]+o,l=r[2]+a,h=t.nDataCursor.getVoxel(n,d,l);h&&(e&&h.hasRGBLight()&&t.rgb.update.push(n,d,l),s&&h.hasSunLight()&&t.sun.update.push(n,d,l))}};async function I(t){const[e,s,r,i]=t;v.setOrigin(t);let o=v.sDataCursor.getVoxel(s,r,i);if(!o)return!1;const a=o.getSubstanceData();if(!o.isAir()&&l.i.doFlow&&o.isRenderable()&&a.dve_is_liquid)return async function(){}(),v;o=v.sDataCursor.getVoxel(s,r,i);const n=o.getLight(),d=o.isLightSource();o.setSecondary(!0).setId(0).setSecondary(!1),o.setLight(n>0?n:0).setId(0).setLevel(0).setLevelState(0).setState(0).setMod(0).updateVoxel(1),l.i.doLight&&(l.i.doRGBPropagation&&d&&(v.rgb.remove.push(s,r,i),(0,u.Q)(v)),b(v),l.i.doRGBPropagation&&(0,u.D)(v),l.i.doSunPropagation&&(0,g.a)(v));for(let t=0;t<h.LE.length;t++)v.sDataCursor.getVoxel(h.LE[t][0]+s,h.LE[t][1]+r,h.LE[t][2]+i)?.updateVoxel(2);return v}async function w(t){const[e,s,r,i]=t[0];v.setOrigin(t[0]);let o=v.sDataCursor.getVoxel(s,r,i);if(!o)return!1;const a=t[1],n=o.isOpaque();let d=l.i.doRGBPropagation,c=l.i.doSunPropagation;t:if(l.i.doLight){if(o.getLight()<=0)break t;c&&o.hasSunLight()&&(v.sun.remove.push(s,r,i),(0,g.z)(v)),d&&o.hasRGBLight()&&n&&(v.rgb.remove.push(s,r,i),(0,u.Q)(v))}o=v.sDataCursor.getVoxel(s,r,i);const f=a[0];if(f<0)return!1;o.setId(f),o.setLevel(a[2]),o.setState(a[3]),o.setMod(a[4]),o.process(),a[3]>0&&o.canHaveSecondaryVoxel()&&(o.setSecondary(!0),o.setId(a[5]),o.setSecondary(!1)),o.isLightSource()&&o.getLightSourceValue()&&o.setLight(o.getLightSourceValue()),o.updateVoxel(0),l.i.doLight&&(b(v),d&&(v.rgb.update.push(s,r,i),(0,u.D)(v)),c&&(0,g.a)(v)),o=v.sDataCursor.getVoxel(s,r,i),l.i.doFlow&&!o.isAir()&&o.getSubstanceData().dve_is_liquid&&x();for(let t=0;t<h.LE.length;t++)v.sDataCursor.getVoxel(h.LE[t][0]+s,h.LE[t][1]+r,h.LE[t][2]+i)?.updateVoxel(2);return v}async function S(t){const[e,s,r,i]=t[0];v.setOrigin(t[0]);const o=v.sDataCursor.getVoxel(s,r,i);if(!o)return!1;let a=l.i.doRGBPropagation,n=l.i.doSunPropagation;return l.i.doLight&&(b(v),a&&(v.rgb.update.push(s,r,i),(0,u.D)(v)),n&&(v.sun.update.push(s,r,i),(0,g.a)(v))),l.i.doFlow&&o.getSubstanceData().dve_is_solid&&x(),v}var A=s(56059);class C{static getRelative(t){t=[...t];const e=A.k.section.bounds.x,s=A.k.section.bounds.z;let r=-1/0;const[i,o,a,n]=t;for(const i of h.vY){t[1]=i[0]*e+o,t[3]=i[1]*s+n;const a=this.getAbsolute(t);a>r&&(r=a)}return r}static getAbsolute(t){const e=n._.sectors.get(t[0],t[1],t[2],t[3]);if(!e)return A.k.world.bounds.MinY;if(0==e.sections.length)return A.k.world.bounds.MinY;let s=A.k.world.bounds.MinY,r=[t[1],t[2],t[3]][1];for(let t=0;t<e.sections.length;t++){const i=e.sections[t];if(!i)continue;const o=r+t*A.k.section.bounds.y;let[a,n]=i.getMinMax();Math.abs(n)!=1/0&&(n=o+n,s<n&&(s=n))}return s+1}}var B=s(96914),T=s(65053);const _=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]],z=[],D=new B.$;var k=s(31373);class L{_map=new Map;get size(){return this._map.size}_getKey(t,e,s){return`${t}_${e}_${s}`}inMap(t,e,s){return this._map.has(this._getKey(t,e,s))}add(t,e,s){this._map.set(this._getKey(t,e,s),!0)}remove(t,e,s){this._map.delete(this._getKey(t,e,s))}removeDiffernce(t){for(const[e]of t._map)this._map.has(e)&&this._map.delete(e);return t}clear(){this._map.clear()}}const V=new B.$,R={runExplosion(t,e){const[s,r,i,o]=t.origin;y.setDimension(s);const a=[],n=new L;for(a.push([r,i,o]);a.length;){const s=a.shift();if(!s)break;const d=s[0],l=s[1],c=s[2];!n.inMap(d+1,l,c)&&t.sDataCursor.getVoxel(d+1,l,c)&&((0,k.D)(r,i,o,d+1,l,c)<=e&&a.push([d+1,l,c]),n.add(d+1,l,c)),n.inMap(d-1,l,c)||(t.sDataCursor.getVoxel(d-1,l,c)&&(0,k.D)(r,i,o,d-1,l,c)<=e&&a.push([d-1,l,c]),n.add(d-1,l,c)),n.inMap(d,l,c+1)||(t.sDataCursor.getVoxel(d,l,c+1)&&(0,k.D)(r,i,o,d,l,c+1)<=e&&a.push([d,l,c+1]),n.add(d,l,c+1)),n.inMap(d,l,c-1)||(t.sDataCursor.getVoxel(d,l,c-1)&&(0,k.D)(r,i,o,d,l,c-1)<=e&&a.push([d,l,c-1]),n.add(d,l,c-1)),n.inMap(d,l+1,c)||(t.sDataCursor.getVoxel(d,l+1,c)&&(0,k.D)(r,i,o,d,l+1,c)<=e&&a.push([d,l+1,c]),n.add(d,l+1,c)),n.inMap(d,l-1,c)||(t.sDataCursor.getVoxel(d,l-1,c)&&(0,k.D)(r,i,o,d,l-1,c)<=e&&a.push([d,l-1,c]),n.add(d,l-1,c));const u=t.sDataCursor.getVoxel(d,l,c);if(u&&u.isRenderable()){for(const e of h.LE){const s=d+e[0],r=l+e[1],i=c+e[2],o=t.nDataCursor.getVoxel(d,l,c);if(o){const e=o.getLight();e>0&&(V.getS(e)>0&&t.sun.remove.push(s,r,i),V.hasRGBLight(e)&&t.rgb.remove.push(s,r,i))}}t.bounds.update(d,l,c),u.setAir().updateVoxel(1)}}(0,u.Q)(t),(0,g.z)(t),(0,u.D)(t),(0,g.a)(t)}};var F=s(94477),M=s(61e3),U=s(40892);class E extends U.s{_section;voxel=new F.$(this);_voxelIndex=0;_voxelPosition=M.Az.Create();_sectionPosition=M.Az.Create();inBounds(t,e,s){const r=this._sectionPosition.x+A.k.section.bounds.x,i=this._sectionPosition.y+A.k.section.bounds.y,o=this._sectionPosition.z+A.k.section.bounds.z;return!(t<this._sectionPosition.x||e<this._sectionPosition.y||s<this._sectionPosition.z||t>r||e>i||s>o)}setSection(t,e,s,r){if("object"==typeof t){this._section=t;const e=this._section.getPosition();return this._sectionPosition.x=e[0],this._sectionPosition.y=e[1],void(this._sectionPosition.z=e[2])}const i=n._.sectors.get(t,e||0,s||0,r||0);if(!i)return!1;this._section=i.getSection(s||0);const o=this._section.getPosition();return this._sectionPosition.x=o[0],this._sectionPosition.y=o[1],this._sectionPosition.z=o[2],!0}getVoxelAtIndex(t){return this._voxelIndex=t,A.k.voxel.getPositionFromIndex(t,this._voxelPosition),this.voxel.loadIn(),this.voxel}getVoxel(t,e,s){return this._section?(A.k.voxel.getPosition(t,e,s,this._voxelPosition),this._voxelIndex=A.k.voxel.getIndexFromPosition(this._voxelPosition.x,this._voxelPosition.y,this._voxelPosition.z),this.voxel.loadIn(),this.voxel):null}}const N=new E;var P=s(76132);class H{static flatIndex=M.F$.GetXYZOrder();static getIndex(t,e,s){return this.flatIndex.getIndexXYZ(t+1,e+1,s+1)}}H.flatIndex.setBounds(3,3,3);const G=[];for(let t=0;t<H.flatIndex.size;t++)G[t]=H.flatIndex.getXYZ(t).map((t=>t-1));const Q=H.flatIndex.size;function O(t,e,s){return t*s*Q+e*s}class Y{view;faceByteCount;constructor(t){this.view=new Uint16Array(t.buffer),this.faceByteCount=t.faceByteCount}getValue(t,e,s){const r=this.view[O(t,e,this.faceByteCount)+s];return 65535==r?-1:r}setValue(t,e,s,r=-1){return this.view[O(t,e,this.faceByteCount)+s]=r}getData(){return{buffer:this.view.buffer,faceByteCount:this.faceByteCount}}}var X=s(55935);const Z=H.flatIndex.size;function W(t,e,s){return t*s*Z+e*s}class q{view;vertexByteCount;constructor(t){this.vertexByteCount=t.vertexByteCount,this.view=new Uint8Array(t.buffer)}getValue(t,e,s){return X.u.getBitArrayIndex(this.view,W(t,e,this.vertexByteCount),s)}setValue(t,e,s,r=1){X.u.setBitArrayIndex(this.view,W(t,e,this.vertexByteCount),s,r)}getData(){return{buffer:this.view.buffer,vertexByteCount:this.vertexByteCount}}}var j;!function(t){t[t.Enabled=0]="Enabled",t[t.Fliped=1]="Fliped",t[t.Texture=2]="Texture",t[t.Rotation=3]="Rotation",t[t.Transparent=4]="Transparent",t[t.UVs=5]="UVs",t[t.Index=6]="Index"}(j||(j={}));const $=t=>{const e=[];return e[j.Enabled]=!0,e[j.Fliped]=!1,e[j.Texture]=0,e[j.Rotation]=0,e[j.Transparent]=!1,e[j.UVs]=[[1,1],[0,1],[0,0],[1,0]],e[j.Index]=t,e};class K{static ArgIndexes=j;static CreateArgs(){const t=[];for(let e=0;e<6;e++)t[e]=$(e);return t}}class J{geometryPaletteId;geomtry;data;transform;faceIndex=-1;vertexIndex=-1;faceCount=-1;vertexCount=-1;builder;constructor(t,e,s,r){this.geometryPaletteId=t,this.geomtry=e,this.data=s,this.transform=r}}var tt;!function(t){t[t.TopRight=0]="TopRight",t[t.TopLeft=1]="TopLeft",t[t.BottomLeft=2]="BottomLeft",t[t.BottomRight=3]="BottomRight"}(tt||(tt={}));const et=[tt.TopRight,tt.TopLeft,tt.BottomLeft,tt.BottomRight];var st;!function(t){t[t.Up=0]="Up",t[t.Down=1]="Down",t[t.North=2]="North",t[t.South=3]="South",t[t.East=4]="East",t[t.West=5]="West"}(st||(st={}));const rt=Object.freeze([st.Up,st.Down,st.North,st.South,st.East,st.West]),it=Object.freeze({[st.Up]:[0,1,0],[st.Down]:[0,-1,0],[st.North]:[0,0,1],[st.South]:[0,0,-1],[st.East]:[1,0,0],[st.West]:[-1,0,0]}),ot=(st.Up,st.Down,st.Down,st.Up,st.North,st.South,st.South,st.North,st.East,st.West,st.West,st.East,st.Up,M.$f.North,st.Down,M.$f.South,st.North,M.$f.North,st.South,M.$f.South,st.East,M.$f.East,st.West,M.$f.West,M.$f.North,st.North,M.$f.South,st.South,M.$f.West,st.West,M.$f.East,st.East,M.$f.NorthEast,st.Up,M.$f.NorthWest,st.Up,M.$f.SouthEast,st.Up,M.$f.SouthWest,st.Up,st.Up,st.Down,st.North,st.South,st.East,st.West,st.Up,st.Down,st.North,st.South,st.East,st.West,[]);ot[st.Up]=[],ot[st.Up][tt.TopRight]=[1,1,0,0,1,1,1,1,1],ot[st.Up][tt.TopLeft]=[-1,1,0,0,1,1,-1,1,1],ot[st.Up][tt.BottomLeft]=[-1,1,0,0,1,-1,-1,1,-1],ot[st.Up][tt.BottomRight]=[1,1,0,0,1,-1,1,1,-1],ot[st.Down]=[],ot[st.Down][tt.TopRight]=[-1,-1,0,0,-1,1,-1,-1,1],ot[st.Down][tt.TopLeft]=[1,-1,0,0,-1,1,1,-1,1],ot[st.Down][tt.BottomLeft]=[1,-1,0,0,-1,-1,1,-1,-1],ot[st.Down][tt.BottomRight]=[-1,-1,0,0,-1,-1,-1,-1,-1],ot[st.East]=[],ot[st.East][tt.TopRight]=[1,0,1,1,1,0,1,1,1],ot[st.East][tt.TopLeft]=[1,0,-1,1,1,0,1,1,-1],ot[st.East][tt.BottomLeft]=[1,0,-1,1,-1,0,1,-1,-1],ot[st.East][tt.BottomRight]=[1,0,1,1,-1,0,1,-1,1],ot[st.West]=[],ot[st.West][tt.TopRight]=[-1,0,-1,-1,1,0,-1,1,-1],ot[st.West][tt.TopLeft]=[-1,0,1,-1,1,0,-1,1,1],ot[st.West][tt.BottomLeft]=[-1,0,1,-1,-1,0,-1,-1,1],ot[st.West][tt.BottomRight]=[-1,0,-1,-1,-1,0,-1,-1,-1],ot[st.South]=[],ot[st.South][tt.TopRight]=[1,0,-1,0,1,-1,1,1,-1],ot[st.South][tt.TopLeft]=[-1,0,-1,0,1,-1,-1,1,-1],ot[st.South][tt.BottomLeft]=[-1,0,-1,0,-1,-1,-1,-1,-1],ot[st.South][tt.BottomRight]=[1,0,-1,0,-1,-1,1,-1,-1],ot[st.North]=[],ot[st.North][tt.TopRight]=[-1,0,1,0,1,1,-1,1,1],ot[st.North][tt.TopLeft]=[1,0,1,0,1,1,1,1,1],ot[st.North][tt.BottomLeft]=[1,0,1,0,-1,1,1,-1,1],ot[st.North][tt.BottomRight]=[-1,0,1,0,-1,1,-1,-1,1];const at=new Int8Array(216),nt=[tt.TopRight,tt.TopLeft,tt.BottomLeft,tt.BottomRight];for(const t of rt)for(let e=0;e<nt.length;e++)for(let s=0;s<9;s++)at[36*t+9*nt[e]+s]=ot[t][nt[e]][s];const dt=[];for(const t of rt){dt[t]??=[];for(let e=0;e<nt.length;e++){dt[t][nt[e]]??=[];let s=0;for(let r=0;r<9;r+=3){const i=ot[t][nt[e]][r],o=ot[t][nt[e]][r+1],a=ot[t][nt[e]][r+2];dt[t][nt[e]][s]=H.getIndex(i,o,a),s++}}}H.getIndex(0,0,0);const lt=[];function ht(t,e,s,r){return t>e&&t>s&&t>r}function ct(t,e,s,r){return o=r,!(t==(i=e)&&i==o&&o==s||ht(r,e,s,t)||ht(e,s,r,t)||!ht(t,e,s,r)&&!ht(s,e,r,t)&&!((t+s)/2>(e+r)/2));var i,o}function ut(t,e,s,r){let i,o,a=!1;switch(t){case st.Up:i=e,o=r;break;case st.Down:i=e,o=r,a=!0;break;case st.North:i=e,o=s,a=!0;break;case st.South:i=e,o=s;break;case st.East:i=r,o=s;break;case st.West:i=r,o=s,a=!0}return function(t,e,s=!1){let r=(1-(t=Math.max(0,Math.min(1,t))))*(1-(e=Math.max(0,Math.min(1,e)))),i=t*(1-e),o=t*e,a=(1-t)*e;return s?[a,o,i,r]:[o,a,r,i]}(i,o,a)}lt[st.Up]=H.getIndex(0,1,0),lt[st.Down]=H.getIndex(0,-1,0),lt[st.North]=H.getIndex(0,0,1),lt[st.South]=H.getIndex(0,0,-1),lt[st.East]=H.getIndex(1,0,0),lt[st.West]=H.getIndex(-1,0,0);const gt=new B.$;function ft(t,e){return gt.createLightValue(gt.getS(t[0])*e[0]+gt.getS(t[1])*e[1]+gt.getS(t[2])*e[2]+gt.getS(t[3])*e[3],gt.getR(t[0])*e[0]+gt.getR(t[1])*e[1]+gt.getR(t[2])*e[2]+gt.getR(t[3])*e[3],gt.getG(t[0])*e[0]+gt.getG(t[1])*e[1]+gt.getG(t[2])*e[2]+gt.getG(t[3])*e[3],gt.getB(t[0])*e[0]+gt.getB(t[1])*e[1]+gt.getB(t[2])*e[2]+gt.getB(t[3])*e[3])}const pt=(t,e)=>{const s=[];for(const r of et){const{x:i,y:o,z:a}=t.positions.vertices[r];s[r]=ut(e,i,o,a)}return s};class mt{vertices;constructor(t){this.vertices=t}getAsArray(){return[this.vertices[tt.TopRight],this.vertices[tt.TopLeft],this.vertices[tt.BottomLeft],this.vertices[tt.BottomRight]]}setVertex(t,e){this.vertices[t]=e}getVertex(t){return this.vertices[t]}setAll(t){this.vertices[tt.TopRight]=t,this.vertices[tt.TopLeft]=t,this.vertices[tt.BottomLeft]=t,this.vertices[tt.BottomRight]=t}set(t,e,s,r){this.vertices[tt.TopRight]=t,this.vertices[tt.TopLeft]=e,this.vertices[tt.BottomLeft]=s,this.vertices[tt.BottomRight]=r}isEqualTo(t,e,s,r){return this.vertices[tt.TopRight]==t&&this.vertices[tt.TopLeft]==e&&this.vertices[tt.BottomLeft]==s&&this.vertices[tt.BottomRight]==r}isAllEqualTo(t){return this.vertices[tt.TopRight]==t&&this.vertices[tt.TopLeft]==t&&this.vertices[tt.BottomLeft]==t&&this.vertices[tt.BottomRight]==t}[Symbol.iterator](){let t=tt.TopRight;const e=this.vertices;return{next:()=>t<tt.BottomRight?{value:e[t++],done:!1}:{value:void 0,done:!0}}}clone(){return new mt({[tt.TopRight]:structuredClone(this.vertices[tt.TopRight]),[tt.TopLeft]:structuredClone(this.vertices[tt.TopLeft]),[tt.BottomLeft]:structuredClone(this.vertices[tt.BottomLeft]),[tt.BottomRight]:structuredClone(this.vertices[tt.BottomRight])})}}class yt extends mt{vertices;constructor(t={[tt.TopRight]:M.Az.Create(),[tt.TopLeft]:M.Az.Create(),[tt.BottomLeft]:M.Az.Create(),[tt.BottomRight]:M.Az.Create()}){super(t),this.vertices=t}setFromQuadData(t){M.Az.Copy(this.vertices[tt.TopRight],t.vertices[tt.TopRight]),M.Az.Copy(this.vertices[tt.TopLeft],t.vertices[tt.TopLeft]),M.Az.Copy(this.vertices[tt.BottomLeft],t.vertices[tt.BottomLeft]),M.Az.Copy(this.vertices[tt.BottomRight],t.vertices[tt.BottomRight])}addToVertex(t,e){M.Az.AddInPlace(this.vertices[t],e)}subtractFromVertex(t,e){M.Az.SubtractInPlace(this.vertices[t],e)}addAll(t){this.addToVertex(tt.TopRight,t),this.addToVertex(tt.TopLeft,t),this.addToVertex(tt.BottomLeft,t),this.addToVertex(tt.BottomRight,t)}subtractAll(t){this.subtractFromVertex(tt.TopRight,t),this.subtractFromVertex(tt.TopLeft,t),this.subtractFromVertex(tt.BottomLeft,t),this.subtractFromVertex(tt.BottomRight,t)}isEqualTo(t,e,s,r){return M.Az.Equals(this.vertices[tt.TopRight],t)&&M.Az.Equals(this.vertices[tt.TopLeft],e)&&M.Az.Equals(this.vertices[tt.BottomLeft],s)&&M.Az.Equals(this.vertices[tt.BottomRight],r)}isAllEqualTo(t){return M.Az.Equals(this.vertices[tt.TopRight],t)&&M.Az.Equals(this.vertices[tt.TopLeft],t)&&M.Az.Equals(this.vertices[tt.BottomLeft],t)&&M.Az.Equals(this.vertices[tt.BottomRight],t)}clone(){return new yt({[tt.TopRight]:M.Az.Clone(this.vertices[tt.TopRight]),[tt.TopLeft]:M.Az.Clone(this.vertices[tt.TopLeft]),[tt.BottomLeft]:M.Az.Clone(this.vertices[tt.BottomLeft]),[tt.BottomRight]:M.Az.Clone(this.vertices[tt.BottomRight])})}}class xt extends mt{vertices;constructor(t={[tt.TopRight]:M.xt.Create(),[tt.TopLeft]:M.xt.Create(),[tt.BottomLeft]:M.xt.Create(),[tt.BottomRight]:M.xt.Create()}){super(t),this.vertices=t}setFromQuadData(t){M.xt.Copy(this.vertices[tt.TopRight],t.vertices[tt.TopRight]),M.xt.Copy(this.vertices[tt.TopLeft],t.vertices[tt.TopLeft]),M.xt.Copy(this.vertices[tt.BottomLeft],t.vertices[tt.BottomLeft]),M.xt.Copy(this.vertices[tt.BottomRight],t.vertices[tt.BottomRight])}addToVertex(t,e){M.xt.AddInPlace(this.vertices[t],e)}subtractFromVertex(t,e){M.xt.SubtractInPlace(this.vertices[t],e)}addAll(t){this.addToVertex(tt.TopRight,t),this.addToVertex(tt.TopLeft,t),this.addToVertex(tt.BottomLeft,t),this.addToVertex(tt.BottomRight,t)}subtractAll(t){this.subtractFromVertex(tt.TopRight,t),this.subtractFromVertex(tt.TopLeft,t),this.subtractFromVertex(tt.BottomLeft,t),this.subtractFromVertex(tt.BottomRight,t)}isEqualTo(t,e,s,r){return M.xt.Equals(this.vertices[tt.TopRight],t)&&M.xt.Equals(this.vertices[tt.TopLeft],e)&&M.xt.Equals(this.vertices[tt.BottomLeft],s)&&M.xt.Equals(this.vertices[tt.BottomRight],r)}isAllEqualTo(t){return M.xt.Equals(this.vertices[tt.TopRight],t)&&M.xt.Equals(this.vertices[tt.TopLeft],t)&&M.xt.Equals(this.vertices[tt.BottomLeft],t)&&M.xt.Equals(this.vertices[tt.BottomRight],t)}clone(){return new xt({[tt.TopRight]:M.xt.Clone(this.vertices[tt.TopRight]),[tt.TopLeft]:M.xt.Clone(this.vertices[tt.TopLeft]),[tt.BottomLeft]:M.xt.Clone(this.vertices[tt.BottomLeft]),[tt.BottomRight]:M.xt.Clone(this.vertices[tt.BottomRight])})}}class vt extends mt{vertices;constructor(t={[tt.TopRight]:0,[tt.TopLeft]:0,[tt.BottomLeft]:0,[tt.BottomRight]:0}){super(t),this.vertices=t}setFromQuadData(t){this.vertices[tt.TopRight]=t.vertices[tt.TopRight],this.vertices[tt.TopLeft]=t.vertices[tt.TopLeft],this.vertices[tt.BottomLeft]=t.vertices[tt.BottomLeft],this.vertices[tt.BottomRight]=t.vertices[tt.BottomRight]}subtractFromVertex(t,e){this.vertices[t]-=e}addAll(t){this.vertices[tt.TopRight]+=t,this.vertices[tt.TopLeft]+=t,this.vertices[tt.BottomLeft]+=t,this.vertices[tt.BottomRight]+=t}add(t,e,s,r){this.vertices[tt.TopRight]+=t,this.vertices[tt.TopLeft]+=e,this.vertices[tt.BottomLeft]+=s,this.vertices[tt.BottomRight]+=r}subtractAll(t){this.vertices[tt.TopRight]-=t,this.vertices[tt.TopLeft]-=t,this.vertices[tt.BottomLeft]-=t,this.vertices[tt.BottomRight]-=t}subtract(t,e,s,r){this.vertices[tt.TopRight]+=t,this.vertices[tt.TopLeft]+=e,this.vertices[tt.BottomLeft]+=s,this.vertices[tt.BottomRight]+=r}isGreaterThan(t,e,s,r){return!(this.vertices[tt.TopRight]<t||this.vertices[tt.TopLeft]<e||this.vertices[tt.BottomLeft]<s||this.vertices[tt.BottomRight]<r)}isAllGreaterThan(t){return!(this.vertices[tt.TopRight]<t||this.vertices[tt.TopLeft]<t||this.vertices[tt.BottomLeft]<t||this.vertices[tt.BottomRight]<t)}isLessThan(t,e,s,r){return!(this.vertices[tt.TopRight]>t||this.vertices[tt.TopLeft]>e||this.vertices[tt.BottomLeft]>s||this.vertices[tt.BottomRight]>r)}isAllLessThan(t){return!(this.vertices[tt.TopRight]>t||this.vertices[tt.TopLeft]>t||this.vertices[tt.BottomLeft]>t||this.vertices[tt.BottomRight]>t)}clone(){return new vt({[tt.TopRight]:this.vertices[tt.TopRight],[tt.TopLeft]:this.vertices[tt.TopLeft],[tt.BottomLeft]:this.vertices[tt.BottomLeft],[tt.BottomRight]:this.vertices[tt.BottomRight]})}}class bt{static FullUVs=Object.freeze([[1,1],[0,1],[0,0],[1,0]]);static RotateUvs(t,e){const s=M.Jd.RotationZ(e),r=[.5,.5];return[M.xt.RotateAroundPivotArray(s,t[0],r),M.xt.RotateAroundPivotArray(s,t[1],r),M.xt.RotateAroundPivotArray(s,t[2],r),M.xt.RotateAroundPivotArray(s,t[3],r)]}static Create(t,e,s,r){return new bt({positions:t,uvs:e,doubleSided:s,orientation:r})}static RotateVertices90Degrees(t,e=1){for(;e--;)t=[t[1],t[2],t[3],t[0]];return t}static GetQuadNormalRightHanded(t,e,s,r){const i=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],o=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],a=M.Az.NormalizeArray(M.Az.CrossArray(i,o)),n=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],d=[r[0]-t[0],r[1]-t[1],r[2]-t[2]],l=M.Az.NormalizeArray(M.Az.CrossArray(n,d)),h=[M.Az.NormalizeArray([(a[0]+l[0])/2,(a[1]+l[1])/2,(a[2]+l[2])/2]),a,M.Az.NormalizeArray([(a[0]+l[0])/2,(a[1]+l[1])/2,(a[2]+l[2])/2]),l];for(let t=0;t<h.length;t++){const e=h[t];for(let t=0;t<3;t++)0===Math.abs(e[t])&&(e[t]=0)}return h}static GetQuadNormalLeftHanded(t,e,s,r){const i=[e[0]-t[0],e[1]-t[1],e[2]-t[2]],o=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],a=M.Az.MultiplyScalarArray(M.Az.NormalizeArray(M.Az.CrossArray(i,o)),-1),n=[s[0]-t[0],s[1]-t[1],s[2]-t[2]],d=[r[0]-t[0],r[1]-t[1],r[2]-t[2]],l=M.Az.MultiplyScalarArray(M.Az.NormalizeArray(M.Az.CrossArray(n,d)),-1),h=[M.Az.NormalizeArray([(a[0]+l[0])/2,(a[1]+l[1])/2,(a[2]+l[2])/2]),a,M.Az.NormalizeArray([(a[0]+l[0])/2,(a[1]+l[1])/2,(a[2]+l[2])/2]),l];for(let t=0;t<h.length;t++){const e=h[t];for(let t=0;t<3;t++)0===Math.abs(e[t])&&(e[t]=0)}return h}static CalculateQuadPoints(t,e){const s=t.map(((t,s)=>e[s]!==t?s:-1)).filter((t=>-1!==t));let r,i;const o=e,a=t;s.includes(0)&&s.includes(2)?(r=[t[0],t[1],e[2]],i=[e[0],t[1],t[2]]):s.includes(0)&&s.includes(1)?(r=[t[0],e[1],t[2]],i=[e[0],t[1],t[2]]):s.includes(1)&&s.includes(2)&&(r=[t[0],e[1],t[2]],i=[t[0],t[1],e[2]]);const n=[e[0]-t[0],e[1]-t[1],e[2]-t[2]];let d=[0,0,0];return 0===n[0]?d[0]=1:0===n[1]?d[1]=1:0===n[2]&&(d[2]=1),{points:[o,r,a,i],normal:d}}static OrderQuadVertices(t,e){const s={north:t=>[t[0],t[1]],south:t=>[t[0],t[1]],east:t=>[t[2],t[1]],west:t=>[t[2],t[1]],up:t=>[t[0],t[2]],down:t=>[t[0],t[2]]},r=t.map((t=>s[e](t))),i=[(r[0][0]+r[1][0]+r[2][0]+r[3][0])/4,(r[0][1]+r[1][1]+r[2][1]+r[3][1])/4],o=t=>Math.atan2(t[1]-i[1],t[0]-i[0]),a=t.map(((t,e)=>({vertex:t,angle:o(r[e])})));return a.sort(((t,e)=>t.angle-e.angle)),[a[2].vertex,a[3].vertex,a[0].vertex,a[1].vertex]}positions=new yt;normals=new yt;uvs=new xt;flip=!1;doubleSided=!1;orientation=0;constructor(t){t.positions&&this.setPositions(t.positions),t.uvs&&this.setUVs(t.uvs),t.doubleSided&&(this.doubleSided=t.doubleSided),void 0!==t.orientation&&(this.orientation=t.orientation)}setUVs([t,e,s,r]){return this.uvs.set(M.xt.FromArray(t),M.xt.FromArray(e),M.xt.FromArray(s),M.xt.FromArray(r)),this}scale(t,e,s){const r=M.Az.Create(t,e,s);for(const t of this.positions)M.Az.MultiplyInPlace(t,r);return this}transform(t,e,s){const r=M.Az.Create(t,e,s);for(const t of this.positions)M.Az.AddInPlace(t,r);return this}setPositions(t){if(2==t.length){const{points:e,normal:s}=bt.CalculateQuadPoints(t[0],t[1]);this.positions.set(M.Az.FromArray(e[0]),M.Az.FromArray(e[1]),M.Az.FromArray(e[2]),M.Az.FromArray(e[3])),this.normals.set(M.Az.FromArray(s),M.Az.FromArray(s),M.Az.FromArray(s),M.Az.FromArray(s))}if(4==t.length){const[e,s,r,i]=bt.GetQuadNormalLeftHanded(...t);this.positions.set(M.Az.FromArray(t[0]),M.Az.FromArray(t[1]),M.Az.FromArray(t[2]),M.Az.FromArray(t[3])),this.normals.set(M.Az.FromArray(e),M.Az.FromArray(s),M.Az.FromArray(r),M.Az.FromArray(i))}return this}clone(){return bt.Create(this.positions.getAsArray().map((t=>M.Az.ToArray(t))),this.uvs.getAsArray().map((t=>M.xt.ToArray(t))))}}function It(t){return t*Math.PI/180}function wt(t){let e=1/0,s=1/0,r=1/0,i=-1/0,o=-1/0,a=-1/0;for(let n=0;n<t.length;n++){const[d,l,h]=t[n];d<e&&(e=d),l<s&&(s=l),h<r&&(r=h),d>i&&(i=d),l>o&&(o=l),h>a&&(a=h)}return[[e,s,r],[i,o,a]]}function St(t,e){const s=[],r=M.Az.Create(...t[0]),i=M.Az.Create(...t[1]),o=[];o[st.Up]=bt.Create([[i.x,i.y,i.z],[r.x,i.y,i.z],[r.x,i.y,r.z],[i.x,i.y,r.z]]),o[st.Down]=bt.Create([[r.x,r.y,i.z],[i.x,r.y,i.z],[i.x,r.y,r.z],[r.x,r.y,r.z]]),o[st.North]=bt.Create([[r.x,i.y,i.z],[i.x,i.y,i.z],[i.x,r.y,i.z],[r.x,r.y,i.z]]),o[st.South]=bt.Create([[i.x,i.y,r.z],[r.x,i.y,r.z],[r.x,r.y,r.z],[i.x,r.y,r.z]]),o[st.East]=bt.Create([[i.x,i.y,i.z],[i.x,i.y,r.z],[i.x,r.y,r.z],[i.x,r.y,i.z]]),o[st.West]=bt.Create([[r.x,i.y,r.z],[r.x,i.y,i.z],[r.x,r.y,i.z],[r.x,r.y,r.z]]),function(t,e){const s=new Map;for(const e of t){const t=[e.positions.vertices[tt.TopRight],e.positions.vertices[tt.TopLeft],e.positions.vertices[tt.BottomLeft],e.positions.vertices[tt.BottomRight]];for(const e of t){const t=`${e.x},${e.y},${e.z}`;s.has(t)||s.set(t,{...e})}}const r=Array.from(s.values()),i={x:0,y:0,z:0};for(const t of r)i.x+=t.x,i.y+=t.y,i.z+=t.z;i.x/=r.length,i.y/=r.length,i.z/=r.length;let o=!1,a=1,n=1,d=1;if(e.scale){const[t,s,r]=e.scale;a=t,n=s,d=r,o=!0}if(e.flip){const[t,s,r]=e.flip;t&&(a*=-1),s&&(n*=-1),r&&(d*=-1),o=!0}const l=a*n*d;if(o)for(const t of r)t.x=i.x+(t.x-i.x)*a,t.y=i.y+(t.y-i.y)*n,t.z=i.z+(t.z-i.z)*d;if(e.rotation){const[t,s,o]=e.rotation,a=It(t),n=It(s),d=It(o),l=e.rotationPivot?{x:e.rotationPivot[0],y:e.rotationPivot[1],z:e.rotationPivot[2]}:i;for(const t of r){let e=t.x-l.x,s=t.y-l.y,r=t.z-l.z;if(a){const t=Math.cos(a),e=Math.sin(a),i=s*e+r*t;s=s*t-r*e,r=i}if(n){const t=Math.cos(n),s=Math.sin(n),i=-e*s+r*t;e=e*t+r*s,r=i}if(d){const t=Math.cos(d),r=Math.sin(d),i=e*r+s*t;e=e*t-s*r,s=i}t.x=e+l.x,t.y=s+l.y,t.z=r+l.z}}if(e.position){const[t,s,i]=e.position;for(const e of r)e.x+=t,e.y+=s,e.z+=i}for(const e of t){const t=[e.positions.vertices[tt.TopRight],e.positions.vertices[tt.TopLeft],e.positions.vertices[tt.BottomLeft],e.positions.vertices[tt.BottomRight]].map((t=>{const e=`${t.x},${t.y},${t.z}`;return s.get(e)}));l<0&&t.reverse(),e.setPositions(t.map((t=>M.Az.ToArray(t))))}}(o,e);const a=new Array(o.length);for(let t=0;t<o.length;t++){const e=[],s=o[t].positions.getAsArray();for(let t=0;t<4;t++)e.push([s[t].x,s[t].y,s[t].z]);a[t]=wt(e)}return s[st.Up]=pt(o[st.Up],st.Up),s[st.Down]=pt(o[st.Down],st.Down),s[st.North]=pt(o[st.North],st.North),s[st.South]=pt(o[st.South],st.South),s[st.East]=pt(o[st.East],st.East),s[st.West]=pt(o[st.West],st.West),{quads:o,vertexWeights:s,quadBounds:a}}var At;!function(t){t[t.Panel=1]="Panel",t[t.CrossPanel=2]="CrossPanel",t[t.Box=3]="Box"}(At||(At={}));class Ct{static AnimationStates={WindAffected:At};static LightMask=65535;static AOMask=15;static AnimationMask=4095;static TextureIndexMax=65535;static createTextureIndex(t,e){let s=0;return s=s&~this.TextureIndexMax|t&this.TextureIndexMax,s=s&~(this.TextureIndexMax<<16)|(e&this.TextureIndexMax)<<16,s}static createAttribute(t,e,s){let r=0;return r=r&~this.LightMask|t&this.LightMask,r=r&~(this.AOMask<<16)|(e&this.AOMask)<<16,r=r&~(this.AnimationMask<<20)|(s&this.AnimationMask)<<20,r}}class Bt{static VertexFloatSize=24;static VertexByteSize=4*this.VertexFloatSize;static PositionOffset=0;static NormalOffset=4;static TextureIndexOffset=8;static UVOffset=12;static ColorOffset=14;static VoxelDataOFfset=18;get positionX(){return this.data[this.trueIndex+Bt.PositionOffset]}set positionX(t){this.data[this.trueIndex+Bt.PositionOffset]=t}get positionY(){return this.data[this.trueIndex+Bt.PositionOffset+1]}set positionY(t){this.data[this.trueIndex+Bt.PositionOffset+1]=t}get positionZ(){return this.data[this.trueIndex+Bt.PositionOffset+2]}set positionZ(t){this.data[this.trueIndex+Bt.PositionOffset+2]=t}get normalX(){return this.data[this.trueIndex+Bt.NormalOffset]}set normalX(t){this.data[this.trueIndex+Bt.NormalOffset]=t}get normalY(){return this.data[this.trueIndex+Bt.NormalOffset+1]}set normalY(t){this.data[this.trueIndex+Bt.NormalOffset+1]=t}get normalZ(){return this.data[this.trueIndex+Bt.NormalOffset+2]}set normalZ(t){this.data[this.trueIndex+Bt.NormalOffset+2]=t}get voxelData(){return this.data[this.trueIndex+Bt.VoxelDataOFfset]}set voxelData(t){this.data[this.trueIndex+Bt.VoxelDataOFfset]=t}get textureIndexX(){return this.data[this.trueIndex+Bt.TextureIndexOffset]}set textureIndexX(t){this.data[this.trueIndex+Bt.TextureIndexOffset]=t}get textureIndexY(){return this.data[this.trueIndex+Bt.TextureIndexOffset+1]}set textureIndexY(t){this.data[this.trueIndex+Bt.TextureIndexOffset+1]=t}get textureIndexZ(){return this.data[this.trueIndex+Bt.TextureIndexOffset+2]}set textureIndexZ(t){this.data[this.trueIndex+Bt.TextureIndexOffset+2]=t}get uvX(){return this.data[this.trueIndex+Bt.UVOffset]}set uvX(t){this.data[this.trueIndex+Bt.UVOffset]=t}get uvY(){return this.data[this.trueIndex+Bt.UVOffset+1]}set uvY(t){this.data[this.trueIndex+Bt.UVOffset+1]=t}get colorR(){return this.data[this.trueIndex+Bt.ColorOffset]}set colorR(t){this.data[this.trueIndex+Bt.ColorOffset]=t}get colorG(){return this.data[this.trueIndex+Bt.ColorOffset+1]}set colorG(t){this.data[this.trueIndex+Bt.ColorOffset+1]=t}get colorB(){return this.data[this.trueIndex+Bt.ColorOffset+2]}set colorB(t){this.data[this.trueIndex+Bt.ColorOffset+2]=t}trueIndex=0;_index=0;data;get index(){return this._index}set index(t){this._index=t,this.trueIndex=t*Bt.VertexFloatSize}constructor(t){t&&(this.data=t)}toJSON(){return{position:[this.positionX,this.positionY,this.positionZ],normal:[this.normalX,this.normalY,this.normalZ],voxelData:this.voxelData,textureIndex:[this.textureIndexX,this.textureIndexY,this.textureIndexZ],uv:[this.uvX,this.uvY],color:[this.colorR,this.colorG,this.colorB]}}}const Tt=new Bt;class _t{static addQuad(t,e,s){if(!t.mesh)return;const r=t.vars.light,i=t.vars.ao,o=t.vars.animation,a=t.vars.textureIndex,n=t.vars.overlayTextures,d=s.positions.vertices[0],l=s.positions.vertices[1],h=s.positions.vertices[2],c=s.positions.vertices[3],u=s.normals.vertices[0],g=s.normals.vertices[1],f=s.normals.vertices[2],p=s.normals.vertices[3],m=Ct.createAttribute(r.vertices[tt.TopRight],i.vertices[tt.TopRight],o.vertices[tt.TopRight]),y=Ct.createAttribute(r.vertices[tt.TopLeft],i.vertices[tt.TopLeft],o.vertices[tt.TopLeft]),x=Ct.createAttribute(r.vertices[tt.BottomLeft],i.vertices[tt.BottomLeft],o.vertices[tt.BottomLeft]),v=Ct.createAttribute(r.vertices[tt.BottomRight],i.vertices[tt.BottomRight],o.vertices[tt.BottomRight]),b=t.mesh.indices;let I=t.mesh.indicieCount,w=s.doubleSided?2:1;const S=s.flip;let A=s.orientation;for(;w--;){const r=t.mesh.vertexCount;S||(t.mesh.buffer.setIndex(r),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,d,u,s.uvs.vertices[tt.TopRight],m,a,n),t.mesh.buffer.setIndex(r+1),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,l,g,s.uvs.vertices[tt.TopLeft],y,a,n),t.mesh.buffer.setIndex(r+2),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,h,f,s.uvs.vertices[tt.BottomLeft],x,a,n),t.mesh.buffer.setIndex(r+3),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,c,p,s.uvs.vertices[tt.BottomRight],v,a,n)),S&&(t.mesh.buffer.setIndex(r),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,l,g,s.uvs.vertices[tt.TopLeft],y,a,n),t.mesh.buffer.setIndex(r+1),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,d,u,s.uvs.vertices[tt.TopRight],m,a,n),t.mesh.buffer.setIndex(r+2),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,c,p,s.uvs.vertices[tt.BottomRight],v,a,n),t.mesh.buffer.setIndex(r+3),Tt.data=t.mesh.buffer.currentArray,Tt.index=t.mesh.buffer.curentIndex,zt(t.mesh.buffer.curentIndex,t.mesh.buffer.currentArray,e,h,f,s.uvs.vertices[tt.BottomLeft],x,a,n)),A||S?!A&&S&&(b.setIndex(I).currentArray[b.curentIndex]=r,b.setIndex(I+1).currentArray[b.curentIndex]=r+3,b.setIndex(I+2).currentArray[b.curentIndex]=r+2,b.setIndex(I+3).currentArray[b.curentIndex]=r+2,b.setIndex(I+4).currentArray[b.curentIndex]=r+1,b.setIndex(I+5).currentArray[b.curentIndex]=r):(b.setIndex(I).currentArray[b.curentIndex]=r,b.setIndex(I+1).currentArray[b.curentIndex]=r+1,b.setIndex(I+2).currentArray[b.curentIndex]=r+2,b.setIndex(I+3).currentArray[b.curentIndex]=r+2,b.setIndex(I+4).currentArray[b.curentIndex]=r+3,b.setIndex(I+5).currentArray[b.curentIndex]=r),A&&!S?(b.setIndex(I).currentArray[b.curentIndex]=r,b.setIndex(I+1).currentArray[b.curentIndex]=r+3,b.setIndex(I+2).currentArray[b.curentIndex]=r+2,b.setIndex(I+3).currentArray[b.curentIndex]=r+2,b.setIndex(I+4).currentArray[b.curentIndex]=r+1,b.setIndex(I+5).currentArray[b.curentIndex]=r):A&&S&&(b.setIndex(I).currentArray[b.curentIndex]=r,b.setIndex(I+1).currentArray[b.curentIndex]=r+1,b.setIndex(I+2).currentArray[b.curentIndex]=r+2,b.setIndex(I+3).currentArray[b.curentIndex]=r+2,b.setIndex(I+4).currentArray[b.curentIndex]=r+3,b.setIndex(I+5).currentArray[b.curentIndex]=r),t.mesh.addVerticies(4,6)}}}const zt=(t,e,s,r,i,o,a,n,d)=>{e[0+(t*=24)]=r.x+s.x,e[0+t+1]=r.y+s.y,e[0+t+2]=r.z+s.z,e[12+t]=o.x,e[12+t+1]=o.y,e[4+t]=i.x,e[4+t+1]=i.y,e[4+t+2]=i.z,e[8+t]=Ct.createTextureIndex(n,d.x),e[8+t+1]=Ct.createTextureIndex(d.y,d.z),e[8+t+2]=Ct.createTextureIndex(d.w,0),e[18+t]=a},Dt=K.ArgIndexes;class kt extends J{quads;quadBounds=[];vertexWeights;lightData=new B.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:t,vertexWeights:e,quadBounds:s}=St(this.data.points,this.transform);this.quads=t,this.vertexWeights=e,this.quadBounds=s}isExposed(t){const e=t+this.faceIndex,s=this.geomtry.faceCullMap[e];if(!s)return!0;const r=this.builder;for(let t=0;t<s.length;t++){const i=s[t],o=G[i],a=this.builder.space.getHash(r.nVoxel,r.position.x+o[0],r.position.y+o[1],r.position.z+o[2]);if(this.builder.space.foundHash[a]<2)continue;const n=this.builder.space.getGeomtry(a),d=this.builder.space.getConditionalGeomtry(a);if(n)for(let t=0;t<n.length;t++){const s=n[t];if(Qt.rulesless[s])continue;const r=this.geomtry.cullIndex.getValue(s,i,e);if(r>-1&&!this.builder.space.getConstructor(a)?.isShapeStateFaceTransparent(this.builder.space.modCache[a],this.builder.space.stateCache[a],s,r))return!1}if(d)for(let t=0;t<d.length;t++){const s=d[t];for(let t=0;t<s.length;t++){const r=s[t];if(Qt.rulesless[r])continue;const o=this.geomtry.cullIndex.getValue(r,i,e);if(o>-1&&!this.builder.space.getConstructor(a)?.isCondtionalStateFaceTransparent(this.builder.space.modCache[a],this.builder.space.stateCache[a],r,o))return!1}}}return!0}determineShading(t){const e=this.builder,s=e.lightData[t],r=this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),i=this.builder.vars.light,o=this.builder.vars.ao;for(let a=0;a<4;a++){if(o.vertices[a]=0,i.vertices[a]=ft(s,this.vertexWeights[t][a]),r)continue;const n=this.vertexIndex+4*t+a,d=this.geomtry.vertexHitMap[n];if(d)for(let t=0;t<d.length;t++){const s=d[t],r=G[s],i=this.builder.space.getHash(e.nVoxel,e.position.x+r[0],e.position.y+r[1],e.position.z+r[2]);if(this.builder.space.foundHash[i]<2||1===this.builder.space.noCastAO[i])continue;const l=this.builder.space.getGeomtry(i),h=this.builder.space.getConditionalGeomtry(i);if(!l&&!h)continue;let c=0,u=!1;if(l){c=l.length;for(let t=0;t<c;t++)if(this.geomtry.aoIndex.getValue(l[t],s,n)){o.vertices[a]=1,u=!0;break}}if(h){c=h.length;for(let t=0;t<c;t++){const e=h[t].length;for(let r=0;r<e;r++)if(this.geomtry.aoIndex.getValue(h[t][r],s,n)){o.vertices[a]=1;break}}}}}}shouldFlip(){const t=this.builder.vars.ao,e=this.builder.vars.light;return!!ct(t.vertices[0],t.vertices[1],t.vertices[2],t.vertices[3])||ct(this.lightData.getS(e.vertices[0]),this.lightData.getS(e.vertices[1]),this.lightData.getS(e.vertices[2]),this.lightData.getS(e.vertices[3]))||ct(this.lightData.sumRGB(e.vertices[0]),this.lightData.sumRGB(e.vertices[1]),this.lightData.sumRGB(e.vertices[2]),this.lightData.sumRGB(e.vertices[3]))}add(t){let e=!1;const s=this.builder;for(let r=0;r<6;r++)if(t[r][Dt.Enabled]&&this.isExposed(r)){e=!0,s.calculateFaceData(r),this.determineShading(r);const i=t[r],o=this.quads[r];o.flip=this.shouldFlip()||i[Dt.Fliped],s.vars.textureIndex=i[Dt.Texture];const a=i[Dt.UVs];o.uvs.vertices[0].x=a[0][0],o.uvs.vertices[0].y=a[0][1],o.uvs.vertices[1].x=a[1][0],o.uvs.vertices[1].y=a[1][1],o.uvs.vertices[2].x=a[2][0],o.uvs.vertices[2].y=a[2][1],o.uvs.vertices[3].x=a[3][0],o.uvs.vertices[3].y=a[3][1],_t.addQuad(s,this.builder.origin,o),s.updateBounds(this.quadBounds[r])}return this.builder.vars.ao.setAll(0),this.builder.vars.light.setAll(0),e}}var Lt;!function(t){t[t.Enabled=0]="Enabled",t[t.Fliped=1]="Fliped",t[t.Texture=2]="Texture",t[t.Rotation=3]="Rotation",t[t.Transparent=4]="Transparent",t[t.DoubleSided=5]="DoubleSided",t[t.UVs=6]="UVs"}(Lt||(Lt={}));class Vt{static ArgIndexes=Lt;static CreateArgs(){const t=[];return t[Lt.Enabled]=!0,t[Lt.Fliped]=!1,t[Lt.Texture]=0,t[Lt.Rotation]=0,t[Lt.Transparent]=!1,t[Lt.DoubleSided]=!1,t[Lt.UVs]=[[1,1],[0,1],[0,0],[1,0]],t}}function Rt(t,e){const s=function(t,e){const s={...t.positions.vertices[tt.TopRight]},r={...t.positions.vertices[tt.TopLeft]},i={...t.positions.vertices[tt.BottomLeft]},o={...t.positions.vertices[tt.BottomRight]},a=[s,r,i,o],n={x:(s.x+r.x+i.x+o.x)/4,y:(s.y+r.y+i.y+o.y)/4,z:(s.z+r.z+i.z+o.z)/4};let d=1,l=1,h=1;if(e.scale){const[t,s,r]=e.scale;d=t,l=s,h=r}if(e.flip){const[t,s,r]=e.flip;t&&(d*=-1),s&&(l*=-1),r&&(h*=-1)}const c=d*l*h;for(const t of a)t.x=n.x+(t.x-n.x)*d,t.y=n.y+(t.y-n.y)*l,t.z=n.z+(t.z-n.z)*h;if(e.rotation){const[t,s,r]=e.rotation,i=It(t),o=It(s),d=It(r),l=e.rotationPivot?{x:e.rotationPivot[0],y:e.rotationPivot[1],z:e.rotationPivot[2]}:n;for(const t of a){let e=t.x-l.x,s=t.y-l.y,r=t.z-l.z;if(i){const t=Math.cos(i),e=Math.sin(i),o=s*e+r*t;s=s*t-r*e,r=o}if(o){const t=Math.cos(o),s=Math.sin(o),i=-e*s+r*t;e=e*t+r*s,r=i}if(d){const t=Math.cos(d),r=Math.sin(d),i=e*r+s*t;e=e*t-s*r,s=i}t.x=e+l.x,t.y=s+l.y,t.z=r+l.z}}if(e.position){const[t,s,r]=e.position;for(const e of a)e.x+=t,e.y+=s,e.z+=r}return c<0&&a.reverse(),bt.Create(a.map((t=>M.Az.ToArray(t))))}(bt.Create(t.points),e);s.orientation=0;const r=s.normals.getAsArray(),i=[0,0,0];for(let t=0;t<r.length;t++)i[0]+=r[t].x,i[1]+=r[t].y,i[2]+=r[t].z;i[0]/=r.length,i[1]/=r.length,i[2]/=r.length;const o=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);0!==o&&(i[0]/=o,i[1]/=o,i[2]/=o);const a=function(t){const[e,s,r]=t;let i=-1/0,o=[0,0,0];for(const t of[-1,0,1])for(const a of[-1,0,1])for(const n of[-1,0,1]){if(0===t&&0===a&&0===n)continue;const d=(e*t+s*a+r*n)/Math.sqrt(t*t+a*a+n*n);d>i&&(i=d,o=[t,a,n])}const a=Math.sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);return[o[0]/a,o[1]/a,o[2]/a]}(i);let n=st.Up;return 1==a[0]&&(n=st.East),-1==a[0]&&(n=st.West),1==a[1]&&(n=st.Up),-1==a[1]&&(n=st.Down),1==a[2]&&(n=st.North),-1==a[2]&&(n=st.South),{quad:s,vertexWeights:pt(s,n),closestFace:n,quadBounds:wt(s.positions.getAsArray().map((t=>M.Az.ToArray(t))))}}const Ft=Vt.ArgIndexes;class Mt extends J{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;closestFace;lightData=new B.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:t,quadBounds:e,closestFace:s,vertexWeights:r}=Rt(this.data,this.transform);this.quad=t,this.quadBounds=e,this.vertexWeights=r,this.closestFace=s}isExposed(){const t=this.faceIndex,e=this.geomtry.faceCullMap[t];if(!e)return!0;const s=this.builder;for(let r=0;r<e.length;r++){const i=e[r],o=G[i],a=this.builder.space.getHash(s.nVoxel,s.position.x+o[0],s.position.y+o[1],s.position.z+o[2]),n=this.builder.space.getGeomtry(a),d=this.builder.space.getConditionalGeomtry(a);if(n)for(let e=0;e<n.length;e++){const s=this.geomtry.cullIndex.getValue(n[e],i,t);if(s>-1&&!this.builder.space.getConstructor(a)?.isShapeStateFaceTransparent(this.builder.space.modCache[a],this.builder.space.stateCache[a],n[e],s))return!1}if(d)for(let e=0;e<d.length;e++){const s=d[e];for(let r=0;r<s.length;r++){const o=this.geomtry.cullIndex.getValue(s[r],i,t);if(o>-1&&!this.builder.space.getConstructor(a)?.isCondtionalStateFaceTransparent(this.builder.space.modCache[a],this.builder.space.stateCache[a],s[e],o))return!1}}}return!0}determineShading(){const t=this.builder,e=t.lightData[st.Up],s=this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),r=t.vars.light,i=t.vars.ao;for(let o=0;o<4;o++){if(i.vertices[o]=0,r.vertices[o]=ft(e,this.vertexWeights[o]),s)continue;const a=this.vertexIndex+4+o,n=this.geomtry.vertexHitMap[a];if(n)for(let e=0;e<n.length;e++){const s=n[e],r=G[s],d=this.builder.space.getHash(t.nVoxel,t.position.x+r[0],t.position.y+r[1],t.position.z+r[2]);if(1===this.builder.space.noCastAO[d])continue;const l=this.builder.space.getGeomtry(d),h=this.builder.space.getConditionalGeomtry(d);if(!l&&!h)continue;let c=0,u=!1;if(l){c=l.length;for(let t=0;t<c;t++)if(this.geomtry.aoIndex.getValue(l[t],s,a)){i.vertices[o]=1,u=!0;break}}if(h){c=h.length;for(let t=0;t<c;t++){const e=h[t].length;for(let r=0;r<e;r++)if(this.geomtry.aoIndex.getValue(h[t][r],s,a)){i.vertices[o]=1;break}}}}}}shouldFlip(){const t=this.builder.vars.ao,e=this.builder.vars.light;return!!ct(t.vertices[0],t.vertices[1],t.vertices[2],t.vertices[3])||ct(this.lightData.getS(e.vertices[0]),this.lightData.getS(e.vertices[1]),this.lightData.getS(e.vertices[2]),this.lightData.getS(e.vertices[3]))||ct(this.lightData.sumRGB(e.vertices[0]),this.lightData.sumRGB(e.vertices[1]),this.lightData.sumRGB(e.vertices[2]),this.lightData.sumRGB(e.vertices[3]))}add(t){if(!t[Ft.Enabled])return!1;if(!this.isExposed())return!1;this.builder.calculateFaceData(this.closestFace),this.determineShading();const e=this.quad;e.flip=this.shouldFlip()||t[Ft.Fliped],this.builder.vars.textureIndex=t[Ft.Texture],e.doubleSided=t[Ft.DoubleSided];const s=t[Ft.UVs];return e.uvs.vertices[0].x=s[0][0],e.uvs.vertices[0].y=s[0][1],e.uvs.vertices[1].x=s[1][0],e.uvs.vertices[1].y=s[1][1],e.uvs.vertices[2].x=s[2][0],e.uvs.vertices[2].y=s[2][1],e.uvs.vertices[3].x=s[3][0],e.uvs.vertices[3].y=s[3][1],_t.addQuad(this.builder,this.builder.origin,e),this.builder.updateBounds(this.quadBounds),this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),!0}}const Ut=Vt.ArgIndexes;class Et extends J{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;closestFace;lightData=new B.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:t,closestFace:e,vertexWeights:s,quadBounds:r}=Rt(this.data,this.transform);this.quad=t,this.quadBounds=r,this.vertexWeights=s,this.closestFace=e}determineShading(){const t=this.builder.lightData[st.Up],e=(this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),this.builder.vars.light),s=this.builder.vars.ao;for(let r=0;r<4;r++)s.vertices[r]=0,e.vertices[r]=ft(t,this.vertexWeights[r])}shouldFlip(){const t=this.builder.vars.light,e=this.builder.vars.ao;return!!ct(e.vertices[0],e.vertices[1],e.vertices[2],e.vertices[3])||ct(this.lightData.getS(t.vertices[0]),this.lightData.getS(t.vertices[1]),this.lightData.getS(t.vertices[2]),this.lightData.getS(t.vertices[3]))||ct(this.lightData.sumRGB(t.vertices[0]),this.lightData.sumRGB(t.vertices[1]),this.lightData.sumRGB(t.vertices[2]),this.lightData.sumRGB(t.vertices[3]))}add(t){if(!t[Ut.Enabled])return!1;const e=this.builder;e.calculateFaceData(this.closestFace),this.determineShading();const s=this.quad;s.flip=this.shouldFlip()||t[Ut.Fliped],e.vars.textureIndex=t[Ut.Texture],s.doubleSided=t[Ut.DoubleSided];const r=t[Ut.UVs];return s.uvs.vertices[0].x=r[0][0],s.uvs.vertices[0].y=r[0][1],s.uvs.vertices[1].x=r[1][0],s.uvs.vertices[1].y=r[1][1],s.uvs.vertices[2].x=r[2][0],s.uvs.vertices[2].y=r[2][1],s.uvs.vertices[3].x=r[3][0],s.uvs.vertices[3].y=r[3][1],_t.addQuad(e,e.position,s),this.builder.updateBounds(this.quadBounds),this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),!0}}const Nt=K.ArgIndexes;class Pt extends J{quads;quadBounds=[];vertexWeights;lightData=new B.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:t,vertexWeights:e,quadBounds:s}=St(this.data.points,this.transform);this.quads=t,this.quadBounds=s,this.vertexWeights=e}determineShading(t){const e=this.builder.lightData[t],s=(this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),this.builder.vars.light),r=this.builder.vars.ao;for(let i=0;i<4;i++)r.vertices[i]=0,s.vertices[i]=ft(e,this.vertexWeights[t][i])}shouldFlip(){const t=this.builder.vars.light,e=this.builder.vars.ao;return!!ct(e.vertices[0],e.vertices[1],e.vertices[2],e.vertices[3])||ct(this.lightData.getS(t.vertices[0]),this.lightData.getS(t.vertices[1]),this.lightData.getS(t.vertices[2]),this.lightData.getS(t.vertices[3]))||ct(this.lightData.sumRGB(t.vertices[0]),this.lightData.sumRGB(t.vertices[1]),this.lightData.sumRGB(t.vertices[2]),this.lightData.sumRGB(t.vertices[3]))}add(t){const e=this.builder;let s=!1;for(let r=0;r<6;r++)if(t[r][Nt.Enabled]){s=!0,e.calculateFaceData(r),this.determineShading(r);const i=t[r],o=this.quads[r];o.flip=this.shouldFlip()||i[Nt.Fliped],e.vars.textureIndex=i[Nt.Texture];const a=i[Nt.UVs];o.uvs.vertices[0].x=a[0][0],o.uvs.vertices[0].y=a[0][1],o.uvs.vertices[1].x=a[1][0],o.uvs.vertices[1].y=a[1][1],o.uvs.vertices[2].x=a[2][0],o.uvs.vertices[2].y=a[2][1],o.uvs.vertices[3].x=a[3][0],o.uvs.vertices[3].y=a[3][1],_t.addQuad(e,e.position,o),this.builder.updateBounds(this.quadBounds[r])}return this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),s}}class Ht{geometryPaletteId;nodes=[];faceCullMap;vertexHitMap;cullIndex;aoIndex;constructor(t,e){this.geometryPaletteId=t;for(const s of e.nodes)if("custom"==s.node.type){const e=new(Qt.getCustomNode(s.node.id))(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if(e?.ruleless)for(const s of e.nodes){if("box"==s.node.type){const e=new Pt(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if("quad"==s.node.type){const e=new Et(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}}else{this.faceCullMap=e.faceCullMap,this.vertexHitMap=e.vertexHitMap,this.cullIndex=new Y(e.cullIndex),this.aoIndex=new q(e.aoIndex);for(const s of e.nodes){if("box"==s.node.type){const e=new kt(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}if("quad"==s.node.type){const e=new Mt(t,this,s.node,s.tranform);e.init(),this.nodes.push(e)}}}let s=0,r=0;for(const t of this.nodes)t.faceIndex=s,t.vertexIndex=r,s+=t.faceCount,r+=t.vertexCount}}var Gt=s(13163);class Qt{static geometryPalette;static geometry=[];static rulesless=[];static setGeometryPalette(t){this.geometryPalette=new P.N(t)}static modelData=new Map;static customNodes=new Map;static registerModels(t){t.forEach((t=>this.modelData.set(t.id,t)))}static registerCustomNode(t,e){this.customNodes.set(t,e)}static getCustomNode(t){const e=this.customNodes.get(t);if(!e)throw new Error(`Custom geometry node [${t}] does not exist.`);return e}static constructorsPaltte=[];static constructors=new Map;static getConstructor(t){return this.constructors.get(t)}static registerVoxel(t){if(Array.isArray(t))for(const e of t)this.constructors.set(e.id,e),this.constructorsPaltte[Gt.A.voxels.getNumberId(e.id)]=e;else this.constructorsPaltte[Gt.A.voxels.getNumberId(t.id)]=t,this.constructors.set(t.id,t)}static registerGeometry(t){for(const e of t){const t=this.geometryPalette.getNumberId(e.id);this.geometry[t]=new Ht(t,e),1==e.ruleless?this.rulesless[t]=!0:this.rulesless[t]=!1}}}var Ot=s(43214),Yt=s(13632);class Xt{bounds;foundHash;voxelCache;lightCache;modCache;stateCache;conditonalStateCache;noCastAO;offset=[0,0,0];voxelCursor=new Ot.x;constructor(t){this.bounds=t;const e=t.x*t.y*t.z;this.foundHash=new Uint8Array(e),this.lightCache=new Int32Array(e),this.voxelCache=new Uint16Array(e),this.modCache=new Int32Array(e),this.stateCache=new Int32Array(e),this.conditonalStateCache=new Int32Array(e),this.noCastAO=new Uint8Array(e)}start(t,e,s){this.offset[0]=t,this.offset[1]=e,this.offset[2]=s,this.lightCache.fill(-1),this.foundHash.fill(0),this.voxelCache.fill(0),this.modCache.fill(-1),this.stateCache.fill(-1),this.conditonalStateCache.fill(-1),this.noCastAO.fill(0)}getIndex(t,e,s){return(0,Yt.BN)(t-this.offset[0],e-this.offset[1],s-this.offset[2],this.bounds.x,this.bounds.y,this.bounds.z)}getConstructor(t){return this.foundHash[t]<2?null:Qt.constructorsPaltte[this.voxelCache[t]]}getGeomtry(t){return!(this.foundHash[t]<2)&&Qt.constructorsPaltte[this.voxelCache[t]].data.shapeStateGeometryMap[this.stateCache[t]]}getConditionalGeomtry(t){return!(this.foundHash[t]<2)&&Qt.constructorsPaltte[this.voxelCache[t]].data.condiotnalShapeStateGeometryMap[this.conditonalStateCache[t]]}getHash(t,e,s,r){const i=this.getIndex(e,s,r);return 0==this.foundHash[i]&&this.hashState(t,i,e,s,r),i}getLight(t,e,s,r){const i=this.getIndex(e,s,r);if(-1==this.lightCache[i]){this.lightCache[i]=0;const o=t.getVoxel(e,s,r);if(o){const t=o.getLight();t>0&&(this.lightCache[i]=t)}}return this.lightCache[i]}hashState(t,e,s,r,i){if(1==this.foundHash[e])return-1;if(2==this.foundHash[e])return this.stateCache[e];const o=t.getVoxel(s,r,i);if(o){const t=o.getLight();t>0&&(this.lightCache[e]=t)}if(!o||!o.isRenderable())return this.foundHash[e]=1,-1;const a=o.getId(),n=Qt.constructorsPaltte[a];if(!n)return this.foundHash[e]=1,-1;this.voxelCache[e]=a,this.foundHash[e]=2,this.noCastAO[e]=o.isLightSource()||o.noAO()?1:0;const d=n.shapeStateTree.getState(o.getState());this.stateCache[e]=d;const l=n.modTree.getState(o.getMod());this.modCache[e]=l,this.voxelCursor.copy(o).process(),n.schema.position.x=s,n.schema.position.y=r,n.schema.position.z=i,n.schema.voxel=this.voxelCursor,n.schema.dataCursor=t;const h=n.condtioanlShapeStateTree.getState();return this.conditonalStateCache[e]=h,1}}new Bt;const Zt=new Float32Array([1/0])[0];class Wt{levels;constructor(t){this.levels=t}getLevelSize(t){if(t<0||t>=this.levels)throw new Error("Invalid level");return 1<<t}getIndexAtLevel(t,e){if(t<0||t>=this.levels)throw new Error("Invalid level");const s=this.getLevelSize(t);if(e<0||e>=s)throw new Error("Invalid node index at the given level");return(1<<t)-1+e}getLevelAndIndex(t){const e=(1<<this.levels)-1;if(t<0||t>=e)throw new Error("Invalid node index");const s=Math.floor(Math.log2(t+1));return[s,t-((1<<s)-1)]}getLeftChildAtLevel(t,e){if(t+1>=this.levels)return-1;const s=this.getIndexAtLevel(t,e);return this.getLeftChild(s)}getRightChildAtLevel(t,e){if(t+1>=this.levels)return-1;const s=this.getIndexAtLevel(t,e);return this.getRightChild(s)}getParentAtLevel(t,e){if(0===t)return-1;const s=this.getIndexAtLevel(t,e);return this.getParent(s)}getLeftChild(t){const e=2*t+1;return e<(1<<this.levels)-1?e:-1}getRightChild(t){const e=2*t+2;return e<(1<<this.levels)-1?e:-1}getParent(t){return 0===t?-1:Math.floor((t-1)/2)}getTotalSize(){return(1<<this.levels)-1}}class qt{data;get minX(){return this.data[this.trueIndex]}get minY(){return this.data[this.trueIndex+1]}get minZ(){return this.data[this.trueIndex+2]}get maxX(){return this.data[this.trueIndex+4]}get maxY(){return this.data[this.trueIndex+5]}get maxZ(){return this.data[this.trueIndex+6]}get voxelIndex(){return this.data[this.trueIndex+3]}get active(){return this.data[this.trueIndex+3]}get nodeType(){return this.data[this.trueIndex+7]}trueIndex=0;index=0;setIndex(t){this.trueIndex=8*t}constructor(t){this.data=t}setActive(){this.data[this.trueIndex+3]=1}setVoxelIndex(t){this.data[this.trueIndex+3]=t}setInnerNode(){this.data[this.trueIndex+7]=1}setGeomtryNode(){this.data[this.trueIndex+7]=2}updateMin(t,e,s){const r=this.trueIndex,i=this.trueIndex+1,o=this.trueIndex+2;(t<this.data[r]||this.data[r]==-Zt)&&(this.data[r]=t),(e<this.data[i]||this.data[i]==-Zt)&&(this.data[i]=e),(s<this.data[o]||this.data[o]==-Zt)&&(this.data[o]=s)}updateMax(t,e,s){const r=this.trueIndex+4,i=this.trueIndex+5,o=this.trueIndex+6;(t>this.data[r]||this.data[r]==-Zt)&&(this.data[r]=t),(e>this.data[i]||this.data[i]==-Zt)&&(this.data[i]=e),(s>this.data[o]||this.data[o]==-Zt)&&(this.data[o]=s)}}class jt{static AABBStructByteSize=32;treeIndex=new Wt(13);tree=new Float32Array(new ArrayBuffer(this.treeIndex.getTotalSize()*jt.AABBStructByteSize));structCursor=new qt(this.tree);indices=new Uint32Array(2*this.treeIndex.getLevelSize(12));reset(){this.tree.fill(-Zt),this.indices.fill(0)}updateVoxel(t,e,s,r,i,o,a,n,d,l,h,c){const u=A.k.voxel.getIndex(t,e,s),g=this.treeIndex.getIndexAtLevel(12,u);this.indices[2*u]=i,this.indices[2*u+1]=o,this.structCursor.setIndex(g),this.structCursor.updateMin(a,n,d),this.structCursor.updateMax(l,h,c),this.structCursor.setVoxelIndex(u),this.structCursor.setGeomtryNode();let f=g;for(let t=1;t<13;t++){let t=this.treeIndex.getParent(f);this.structCursor.setIndex(t),this.structCursor.updateMin(a,n,d),this.structCursor.updateMax(l,h,c),this.structCursor.setActive(),this.structCursor.setInnerNode(),f=t}}}class $t{vertexFloatSize;sectorVertexSize;_buffers=[];sectorSize=0;constructor(t,e,s=4){this.vertexFloatSize=t,this.sectorVertexSize=e,this.sectorSize=t*e;for(let t=0;t<s;t++)this._buffers.push(new Float32Array(this.sectorSize))}currentArray;curentIndex=0;_index=0;setIndex(t){this._index=t;const e=Math.floor(t*this.vertexFloatSize/this.sectorSize);this._buffers[e]||(this._buffers[e]=new Float32Array(this.sectorSize)),this.curentIndex=(t*this.vertexFloatSize-e*this.sectorSize)/this.vertexFloatSize,this.currentArray=this._buffers[e]}}class Kt{sectorSize;_buffers=[];constructor(t,e=4){this.sectorSize=t;for(let s=0;s<e;s++)this._buffers.push(new Uint32Array(t))}currentArray;curentIndex=0;_index=0;setIndex(t){this._index=t;const e=Math.floor(t/this.sectorSize);return this._buffers[e]||(this._buffers[e]=new Uint32Array(this.sectorSize)),this.curentIndex=t-e*this.sectorSize,this.currentArray=this._buffers[e],this}}class Jt{indicieCount=0;vertexCount=0;minBounds=M.Az.Create(1/0,1/0,1/0);maxBounds=M.Az.Create(-1/0,-1/0,-1/0);buffer=new $t(Bt.VertexFloatSize,1e3);indices=new Kt(1e3);addVerticies(t,e){this.vertexCount+=t,this.indicieCount+=e}clear(){this.indicieCount=0,this.vertexCount=0,this.minBounds.x=1/0,this.minBounds.y=1/0,this.minBounds.z=1/0,this.maxBounds.x=-1/0,this.maxBounds.y=-1/0,this.maxBounds.z=-1/0}}class te{segments=new Map;mesh=null;startNewMesh(t){this.mesh=t||new Jt}clear(){return this.mesh?.clear(),this}}const ee=new B.$,se=new Uint16Array([0,0,0,0]),re=new Uint16Array([0,0,0,0]);class ie{faceFlipped=!1;textureIndex=0;overlayTextures=M.ZS.Create();light=new vt;ao=new vt;animation=new vt;level=new vt;reset(){this.faceFlipped=!1,this.textureIndex=0,this.overlayTextures.x=0,this.overlayTextures.y=0,this.overlayTextures.z=0}}class oe extends te{id;materialIndex;space;voxel;nVoxel;position=M.Az.Create();origin=M.Az.Create();mesh=new Jt;bvhTool=null;vars=new ie;dataCalculated;condiotnalGeometryData;lightData;effects;constructor(t,e){super(),this.id=t,this.materialIndex=e,this.dataCalculated=[];for(const t of rt)this.dataCalculated[t]=!1;this.condiotnalGeometryData=[];for(const t of rt)this.condiotnalGeometryData[t]=[],this.condiotnalGeometryData[t][tt.TopRight]=[[],[],[]],this.condiotnalGeometryData[t][tt.TopLeft]=[[],[],[]],this.condiotnalGeometryData[t][tt.BottomLeft]=[[],[],[]],this.condiotnalGeometryData[t][tt.BottomRight]=[[],[],[]];this.lightData=[];for(const t of rt)this.lightData[t]=[],this.lightData[t][tt.TopRight]=0,this.lightData[t][tt.TopLeft]=0,this.lightData[t][tt.BottomLeft]=0,this.lightData[t][tt.BottomRight]=0;this.startNewMesh(new Jt)}bounds={min:[0,0,0],max:[0,0,0]};_indexStart=0;startConstruction(){this._indexStart=this.mesh.indicieCount,this.bounds.min[0]=1/0,this.bounds.min[1]=1/0,this.bounds.min[2]=1/0,this.bounds.max[0]=-1/0,this.bounds.max[1]=-1/0,this.bounds.max[2]=-1/0,this._boundsUpdate=!0}endConstruction(){if(this.vars.reset(),this.bvhTool){if(!this._boundsUpdate)return!1;this.bvhTool.updateVoxel(this.position.x,this.position.y,this.position.z,this._indexStart,this.materialIndex,this.mesh.indicieCount,this.bounds.min[0],this.bounds.min[1],this.bounds.min[2],this.bounds.max[0],this.bounds.max[1],this.bounds.max[2])}return!0}_boundsUpdate=!1;updateBounds(t){const e=this.origin;e.x+t[0][0]<this.bounds.min[0]&&(this.bounds.min[0]=e.x+t[0][0]),e.y+t[0][1]<this.bounds.min[1]&&(this.bounds.min[1]=e.y+t[0][1]),e.z+t[0][2]<this.bounds.min[2]&&(this.bounds.min[2]=e.z+t[0][2]),e.x+t[1][0]>this.bounds.max[0]&&(this.bounds.max[0]=e.x+t[1][0]),e.y+t[1][1]>this.bounds.max[1]&&(this.bounds.max[1]=e.y+t[1][1]),e.z+t[1][2]>this.bounds.max[2]&&(this.bounds.max[2]=e.z+t[1][2]),this._boundsUpdate=!0}calculateFaceData(t){if(this.dataCalculated[t])return!0;!function(t,e){let s=e.voxel.getLight();const r=it[t],i=e.position.x,o=e.position.y,a=e.position.z,n=e.lightData[t],d=e.nVoxel,l=ot[t],h=e.space.getLight(e.nVoxel,i+r[0],o+r[1],a+r[2])||0;s=h>=0?h:s>=0?s:0;for(let t=0;t<4;t++){n[t]=s,ee.getLightValuesArrayToRef(s,se);for(let s=0;s<9;s+=3){const r=e.space.getLight(d,l[t][s]+i,l[t][s+1]+o,l[t][s+2]+a);r<=0||(ee.getLightValuesArrayToRef(r,re),se[0]=se[0]<re[0]?re[0]:se[0],se[1]=se[1]<re[1]?re[1]:se[1],se[2]=se[2]<re[2]?re[2]:se[2],se[3]=se[3]<re[3]?re[3]:se[3])}n[t]=ee.setLightValues(se)}}(t,this),this.dataCalculated[t]=!0}clearCalculatedData(){this.dataCalculated[st.Up]=!1,this.dataCalculated[st.Down]=!1,this.dataCalculated[st.North]=!1,this.dataCalculated[st.South]=!1,this.dataCalculated[st.East]=!1,this.dataCalculated[st.West]=!1}clear(){return this.vars.reset(),this.mesh.clear(),this}}class ae{static meshersMap=new Map;static meshers=[];static register(t){for(let e=0;e<t.length;e++){const s=new oe(t[e],e);this.meshersMap.set(t[e],s),this.meshers[e]=s}}}const ne=new E,de=new m.p;let le;const he=new jt;function ce(t,e,s,r){let i=!1;const o=Qt.constructorsPaltte[r.getId()],a=o.builder;return a.origin.x=ne._voxelPosition.x,a.origin.y=ne._voxelPosition.y,a.origin.z=ne._voxelPosition.z,a.position.x=t,a.position.y=e,a.position.z=s,a.voxel=r,a.nVoxel=de,a.startConstruction(),i=o.process(),a.endConstruction(),i}const ue=M.Az.Create(5,5,5);function ge(t,e=[]){le||(le=new Xt({x:A.k.section.bounds.x+ue.x,y:A.k.section.bounds.y+ue.y,z:A.k.section.bounds.z+ue.z}));const[s,r,i,o]=t,a=n._.sectors.get(s,r,i,o);if(!a)return null;const d=a.getSection(i);de.setFocalPoint(...t),ne.setSection(...t);let[l,h]=d.getMinMax();if(Math.abs(l)==1/0&&Math.abs(h)==1/0)return null;le.start(r-(ue.x-1),i-(ue.y-1),o-(ue.z-1)),he.reset();const c={};for(let t=0;t<ae.meshers.length;t++){const e=ae.meshers[t];e.space=le,e.bvhTool=he,e.effects=c}const u=A.k.section.volumne,g=A.k.section.bounds.x*A.k.section.bounds.z;for(let t=0;t<u;t++){if(!(t%g)){const e=t/g;if(!d.getHasVoxel(e)&&!d.getHasVoxelDirty(e)){t+=g;continue}}if(!d.ids[t]||d.getBuried(t))continue;const e=ne.getVoxelAtIndex(t),s=r+ne._voxelPosition.x,a=i+ne._voxelPosition.y,n=o+ne._voxelPosition.z;let l=!1;ce(s,a,n,e)&&(l=!0),e.hasSecondaryVoxel()&&(e.setSecondary(!0),ce(s,a,n,e)&&(l=!0),e.setSecondary(!1)),d.setBuried(t,!l)}const f=[],p=[t,[],f,0],m=[];for(let t=0;t<ae.meshers.length;t++){const s=ae.meshers[t];for(const t in s.effects){const r=Float32Array.from(s.effects[t]);e.push(r.buffer),f.push([t,r])}s.mesh.vertexCount?m.push(s):(s.clear(),s.bvhTool=null)}const y=function(t,e=[]){const s=[0,[]];for(let r=0;r<t.length;r++){const i=t[r];if(!i.mesh.vertexCount)continue;const o=i.mesh.vertexCount*Bt.VertexFloatSize,a=new Float32Array(o),n=i.mesh.buffer._buffers;let d=0,l=!1;for(let t=0;t<n.length;t++){const e=n[t];for(let t=0;t<e.length;t++)if(a[d]=e[t],d++,d>o){l=!0;break}if(l)break}const h=i.mesh.indicieCount>65535?new Uint32Array(i.mesh.indicieCount):new Uint16Array(i.mesh.indicieCount),c=i.mesh.indices._buffers;d=0,l=!1;for(let t=0;t<c.length;t++){const e=c[t];for(let t=0;t<e.length;t++)if(h[d]=e[t],d++,d>i.mesh.indicieCount){l=!0;break}if(l)break}const u=i.mesh.minBounds,g=i.mesh.maxBounds;s[1].push([i.id,a,h,[u.x,u.y,u.z],[g.x,g.y,g.z]]),e.push(a.buffer,h.buffer)}return s}(m,e);p[1]=y;for(let t=0;t<m.length;t++)m[t].clear(),m[t].bvhTool=null;return p}var fe,pe,me=s(30729),ye=s(78259);!function(t){t[t.None=0]="None",t[t.Down=1]="Down",t[t.Up=2]="Up"}(fe||(fe={})),function(t){t[t.NorthEast=0]="NorthEast",t[t.NorthWest=1]="NorthWest",t[t.SouthWest=2]="SouthWest",t[t.SouthEsat=3]="SouthEsat"}(pe||(pe={}));const xe={[pe.NorthEast]:[1,0,0,1,1,1],[pe.NorthWest]:[-1,0,0,1,-1,1],[pe.SouthWest]:[-1,0,0,-1,-1,-1],[pe.SouthEsat]:[1,0,0,-1,1,-1]};function ve(t,e,s,r){const i=t.nVoxel.getVoxel(e,s,r);if(!i||!i.isRenderable())return-1;if(!t.voxel.isSameVoxel(i))return-1;const o=i.getLevel();return i.getLevelState()>0?7:o}const be=[M.xH.East,0],Ie=new vt,we=new vt,Se=new B.$,Ae=6/7,Ce={[M.xH.North]:bt.RotateUvs(bt.FullUVs,M.xH.North),[M.xH.South]:bt.RotateUvs(bt.FullUVs,M.xH.South),[M.xH.East]:bt.RotateUvs(bt.FullUVs,M.xH.East),[M.xH.West]:bt.RotateUvs(bt.FullUVs,M.xH.West),[M.xH.NorthWest]:bt.RotateUvs(bt.FullUVs,M.xH.NorthWest),[M.xH.NorthEast]:bt.RotateUvs(bt.FullUVs,M.xH.NorthEast),[M.xH.SouthWest]:bt.RotateUvs(bt.FullUVs,M.xH.SouthWest),[M.xH.SouthEast]:bt.RotateUvs(bt.FullUVs,M.xH.SouthEast)},Be=[[1,1],[0,1],[0,0],[1,0]],{quads:Te,vertexWeights:_e,quadBounds:ze}=St([[0,0,0],[1,Ae,1]],{});Te[st.Up].setUVs(Be),Te[st.Down].setUVs(Be);class De extends J{init(){this.faceCount=1,this.vertexCount=0}isExposed(t){const e=this.builder.nVoxel.getVoxel(it[t][0]+this.builder.position.x,it[t][1]+this.builder.position.y,it[t][2]+this.builder.position.z);return!(e&&!e.isAir()&&(this.builder.voxel.isSameVoxel(e)||t!=st.Up))}determineShading(t){const e=this.builder.lightData[t],s=this.builder.vars.light;for(let t=0;t<4;t++)s.vertices[t]=e[t]}shouldFlip(){const t=this.builder.vars.light;return ct(Se.getS(t.vertices[0]),Se.getS(t.vertices[1]),Se.getS(t.vertices[2]),Se.getS(t.vertices[3]))||ct(Se.sumRGB(t.vertices[0]),Se.sumRGB(t.vertices[1]),Se.sumRGB(t.vertices[2]),Se.sumRGB(t.vertices[3]))}add(t){we.setAll(15),Ie.setAll(0);const e=this.builder;let s=!1,r=!1;if(this.isExposed(st.Up)){r=!0,s=!0,function(t,e){const s=t.voxel.getLevel(),r=t.voxel.getLevelState();for(let i=0;i<=3;i++){const o=xe[i];let a=s,n=0;for(let s=0;s<6;s+=2){const r=o[s]+t.position.x,d=o[s+1]+t.position.z;if(ve(t,r,t.position.y+1,d)>0){e.vertices[i]=9,a=9;break}const l=ve(t,r,t.position.y,d);-1==l&&n++,a<l&&(a=l)}(a<7&&a>3||1==r)&&n>=2&&(a=3),e.vertices[i]=a}}(e,we);const i=Te[st.Up];e.calculateFaceData(st.Up),this.determineShading(st.Up),i.flip=this.shouldFlip(),e.vars.textureIndex=t.stillTexture,Ie.set(we.vertices[0]/7,we.vertices[1]/7,we.vertices[2]/7,we.vertices[3]/7);const o=function(t){if(t.isAllEqualTo(7))return be[0]=0,be[1]=fe.None,be;const e=t.vertices[tt.TopRight],s=t.vertices[tt.TopLeft],r=t.vertices[tt.BottomLeft],i=t.vertices[tt.BottomRight],o=e==i,a=s==r;if(e==s&&i==r){if(e<i)return be[0]=M.xH.North,be[1]=fe.Up,be;if(e>i)return be[0]=M.xH.South,be[1]=fe.Up,be}if(o&&a){if(e<s)return be[0]=M.xH.East,be[1]=fe.Up,be;if(e>s)return be[0]=M.xH.West,be[1]=fe.Up,be}return i<e&&i<s&&i<r||s>e&&s>i&&s>r?(be[0]=M.xH.SouthEast,be[1]=fe.Up,be):s<e&&s<i&&s<r||i>e&&i>s&&i>r?(be[0]=M.xH.NorthWest,be[1]=fe.Up,be):e<i&&e<s&&e<r||r>i&&r>s&&r>e?(be[0]=M.xH.NorthEast,be[1]=fe.Up,be):r<i&&r<s&&r<e||e>i&&e>s&&e>r?(be[0]=M.xH.SouthWest,be[1]=fe.Up,be):(be[0]=M.xH.North,be[1]=fe.Up,be)}(we),a=Ce[o[0]];e.vars.animation.setAll(o[1]),i.uvs.vertices[tt.TopRight].x=a[0][0],i.uvs.vertices[tt.TopRight].y=a[0][1],i.uvs.vertices[tt.TopLeft].x=a[1][0],i.uvs.vertices[tt.TopLeft].y=a[1][1],i.uvs.vertices[tt.BottomLeft].x=a[2][0],i.uvs.vertices[tt.BottomLeft].y=a[2][1],i.uvs.vertices[tt.BottomRight].x=a[3][0],i.uvs.vertices[tt.BottomRight].y=a[3][1],i.positions.vertices[0].y=Ie.vertices[0]*Ae,i.positions.vertices[1].y=Ie.vertices[1]*Ae,i.positions.vertices[2].y=Ie.vertices[2]*Ae,i.positions.vertices[3].y=Ie.vertices[3]*Ae,_t.addQuad(e,e.origin,i),e.updateBounds(ze[st.Up])}if(this.isExposed(st.Down)){s=!0,e.vars.textureIndex=t.stillTexture;const r=Te[st.Down];e.calculateFaceData(st.Down),this.determineShading(st.Down),r.flip=this.shouldFlip(),e.vars.textureIndex=t.stillTexture,_t.addQuad(e,e.origin,r),e.updateBounds(ze[st.Down])}if(this.isExposed(st.North)){s=!0,e.vars.textureIndex=t.stillTexture;const i=Te[st.North];e.vars.animation.setAll(1),e.calculateFaceData(st.North),this.determineShading(st.North),i.flip=this.shouldFlip(),r?(i.positions.vertices[tt.TopRight].y=Ie.vertices[pe.NorthWest]*Ae,i.positions.vertices[tt.TopLeft].y=Ie.vertices[pe.NorthEast]*Ae,i.uvs.vertices[tt.TopRight].y=Ie.vertices[pe.NorthWest],i.uvs.vertices[tt.TopLeft].y=Ie.vertices[pe.NorthEast]):(i.positions.vertices[tt.TopRight].y=1,i.positions.vertices[tt.TopLeft].y=1,i.setUVs(Be)),_t.addQuad(e,e.origin,i),e.updateBounds(ze[st.North])}if(this.isExposed(st.South)){s=!0,e.vars.textureIndex=t.stillTexture;const i=Te[st.South];e.vars.animation.setAll(1),e.calculateFaceData(st.South),this.determineShading(st.South),i.flip=this.shouldFlip(),r?(i.positions.vertices[tt.TopRight].y=Ie.vertices[pe.SouthEsat]*Ae,i.positions.vertices[tt.TopLeft].y=Ie.vertices[pe.SouthWest]*Ae,i.uvs.vertices[tt.TopRight].y=Ie.vertices[pe.SouthEsat],i.uvs.vertices[tt.TopLeft].y=Ie.vertices[pe.SouthWest]):(i.positions.vertices[tt.TopLeft].y=1,i.positions.vertices[tt.TopRight].y=1,i.setUVs(Be)),_t.addQuad(e,e.origin,i),e.updateBounds(ze[st.South])}if(this.isExposed(st.East)){s=!0,e.vars.textureIndex=t.stillTexture;const i=Te[st.East];e.vars.animation.setAll(1),e.calculateFaceData(st.East),this.determineShading(st.East),r?(i.positions.vertices[tt.TopRight].y=Ie.vertices[pe.NorthEast]*Ae,i.positions.vertices[tt.TopLeft].y=Ie.vertices[pe.SouthEsat]*Ae,i.uvs.vertices[tt.TopRight].y=Ie.vertices[pe.SouthEsat],i.uvs.vertices[tt.TopLeft].y=Ie.vertices[pe.NorthEast]):(i.positions.vertices[tt.TopLeft].y=1,i.positions.vertices[tt.TopRight].y=1,i.setUVs(Be)),_t.addQuad(e,e.origin,i),e.updateBounds(ze[st.East])}if(this.isExposed(st.West)){s=!0,e.vars.textureIndex=t.stillTexture;const i=Te[st.West];e.vars.animation.setAll(1),e.calculateFaceData(st.West),this.determineShading(st.West),i.flip=this.shouldFlip(),r?(i.positions.vertices[tt.TopRight].y=Ie.vertices[pe.SouthWest]*Ae,i.positions.vertices[tt.TopLeft].y=Ie.vertices[pe.NorthWest]*Ae,i.uvs.vertices[tt.TopRight].y=Ie.vertices[pe.SouthWest],i.uvs.vertices[tt.TopLeft].y=Ie.vertices[pe.NorthWest]):(i.positions.vertices[tt.TopLeft].y=1,i.positions.vertices[tt.TopRight].y=1,i.setUVs(Be)),_t.addQuad(e,e.origin,i),e.updateBounds(ze[st.West])}return this.builder.vars.light.setAll(0),s}}var ke,Le,Ve=s(28421),Re=s(81233);class Fe{data;view;constructor(t){this.data=t,this.view=new Uint8Array(t.buffer)}getValue(t,e,s){return X.u.getBitArrayIndex(this.view,this.data.resultsSize*t+e,s)}setValue(t,e,s,r=1){X.u.setBitArrayIndex(this.view,this.data.resultsSize*t+e,s,r)}}class Me{model;effects=[];constructor(t){this.model=t;for(const e of t.data.effects)"fx-points"==e.type&&this.effects.push({id:e.effectId,reader:new Re.z(t.schema,0,e.tree),palette:e.treePalette})}addEffects(t,e,s){if(this.effects.length)for(let r=0;r<this.effects.length;r++){const i=this.effects[r];let o=s[i.id];o||(o=[],s[i.id]=o);const a=i.reader.getState(t);if(-1==a)continue;const n=i.palette[a];if(!n)continue;let d=o.length;for(let t=0;t<n.length;t++){const s=n[t];o[d]=e.x+s[0],o[d+1]=e.y+s[1],o[d+2]=e.z+s[2],d+=3}}}}!function(t){t[t.Equals=0]="Equals",t[t.NotEquals=1]="NotEquals",t[t.GreaterThan=2]="GreaterThan",t[t.LessThan=3]="LessThan"}(ke||(ke={})),function(t){t[t.And=0]="And",t[t.Or=1]="Or"}(Le||(Le={})),ke.Equals,ke.NotEquals,ke.GreaterThan,ke.LessThan,Le.And,Le.Or;class Ue{schema;statement;constructor(t,e){this.schema=t,this.statement=e}getValue(t){let e=-1,s=!1,r=!1;for(let t=0;t<this.statement.length;t++){const i=this.statement[t];if(i==Le.And||i==Le.Or){e=i;continue}const o=this.schema.nodes[i[0]].getValue(this.schema.voxel.getState());switch(i[1]){case ke.Equals:r=o==i[2];break;case ke.NotEquals:r=o!=i[2];break;case ke.GreaterThan:r=o>=i[2];break;case ke.LessThan:r=o<=i[2]}if(-1!=e)switch(e){case Le.And:s=s&&r;break;case Le.Or:s=s||r}else s=r}return s}}class Ee{schema;tree;statements=[];constructor(t,e,s){this.schema=t,this.tree=s;for(const s of e)this.statements.push(new Ue(t,s))}getState(){if(!this.tree.length)return-1;let t=this.tree;for(let e=0;e<this.statements.length;e++)t=t[this.statements[e].getValue(this)?1:0];return t}}class Ne{id;builder;data;isModel=!0;geometries=[];modSchema;modTree;transparentIndex;baseInputMap;conditonalInputMap;schema;effects;shapeStateTree;condtioanlShapeStateTree;constructor(t,e,s,r){this.id=t,this.builder=e,this.data=s,this.baseInputMap=r.baseGeometryInputMap,this.conditonalInputMap=r.condiotnalGeometryInputMap,this.transparentIndex=new Fe(r.transparentFaceIndex),this.schema=new Ve.X(s.schema),this.shapeStateTree=new Re.z(this.schema,0,s.shapeStateTree),this.condtioanlShapeStateTree=new Ee(this.schema,s.condiotnalStatements,s.condiotnalStateTree),this.modSchema=new Ve.X(r.modSchema),this.modTree=new Re.z(this.modSchema,0,r.modStateTree),this.effects=new Me(this)}isShapeStateFaceTransparent(t,e,s,r){return 1==this.transparentIndex.getValue(t,this.data.relativeGeometryByteIndexMap[this.data.shapeStateRelativeGeometryMap[e][s]],r)}isCondtionalStateFaceTransparent(t,e,s,r){return 1==this.transparentIndex.getValue(t,this.data.relativeGeometryByteIndexMap[this.data.condiotnalShapeStateRelativeGeometryMap[e][s]],r)}process(){let t=!1;const e=this.builder,s=e.space.getHash(e.nVoxel,e.position.x,e.position.y,e.position.z),r=e.space.stateCache[s],i=e.space.modCache[s];if(r>-1){const e=this.data.shapeStateMap[r],s=this.data.shapeStateGeometryMap[r],o=e.length,a=this.baseInputMap[i][r];for(let r=0;r<o;r++){const i=a[e[r]],o=Qt.geometry[s[r]],n=o.nodes.length;for(let e=0;e<n;e++){const s=o.nodes[e];s.builder=this.builder,s.add(i[e])&&(t=!0)}}}const o=e.space.conditonalStateCache[s];if(o>-1){const e=this.data.condiotnalShapeStateMap[o],s=e.length;for(let r=0;r<s;r++){const s=e[r],o=s.length,a=this.conditonalInputMap[i][r];for(let e=0;e<o;e++){const r=s[e],i=a[e],o=Qt.geometry[this.data.geoLinkMap[r]],n=o.nodes.length;for(let e=0;e<n;e++){const s=o.nodes[e];s.builder=this.builder,s.add(i[e])&&(t=!0)}}}}return this.effects.addEffects(e.voxel.getState(),e.origin,e.effects),e.clearCalculatedData(),t}}var Pe=s(25012),He=s(41986),Ge=s(50489),Qe=s(83066);const Oe=t=>({section:t,palettes:{ids:new Pe.h,level:new Pe.h,light:new Pe.h,state:new Pe.h,mod:new Pe.h,secondaryId:new Pe.h,secondaryState:new Pe.h},ids:new Uint16Array(t.ids.length),idsAllTheSame:!0,remappedIds:!1,light:new Uint16Array(t.light.length),lightAllTheSame:!0,isLightPaletted:!1,remappedLight:!1,level:new Uint8Array(t.level.length),levelAllTheSame:!0,isLevelPaletted:!1,remappedLevel:!1,state:new Uint16Array(t.state.length),stateAllTheSame:!0,isStatePaletted:!1,remappedState:!1,mod:new Uint16Array(t.mod.length),modAllTheSame:!0,isModPaletted:!1,remappedMod:!1,secondary:new Uint16Array(t.secondary.length),isSecondaryPaletted:!1,secondaryAllTheSame:!0,remappedSecondary:!1});function Ye(t,e){const s={};return t.remappedIds&&(s.id=Uint16Array.from(t.palettes.ids._palette)),t.remappedLevel&&(s.level=Uint8Array.from(t.palettes.level._palette)),t.remappedLight&&(s.light=Uint16Array.from(t.palettes.light._palette)),t.remappedState&&(s.state=Uint16Array.from(t.palettes.state._palette)),t.remappedMod&&(s.mod=Uint16Array.from(t.palettes.mod._palette)),t.remappedSecondary&&(s.secondaryId=Uint16Array.from(t.palettes.secondaryId._palette),s.secondaryState=Uint16Array.from(t.palettes.secondaryState._palette)),{state:{},palettes:s,buffers:{id:t.idsAllTheSame?t.ids[0]:(0,He.S)(t.remappedIds?t.palettes.ids.size:e.ids.size,t.ids),level:t.isLevelPaletted?t.level[0]:t.isLevelPaletted?(0,He.S)(t.remappedLevel?t.palettes.level.size:e.level.size,t.level):new Uint8Array(t.section.level.slice()),light:t.lightAllTheSame?t.light[0]:t.isLightPaletted?(0,He.S)(t.remappedLight?t.palettes.light.size:e.light.size,t.light):new Uint16Array(t.section.light.slice()),state:t.stateAllTheSame?t.state[0]:t.isStatePaletted?(0,He.S)(t.remappedState?t.palettes.state.size:e.state.size,t.state):new Uint16Array(t.section.state.slice()),mod:t.modAllTheSame?t.mod[0]:t.isModPaletted?(0,He.S)(t.remappedMod?t.palettes.mod.size:e.mod.size,t.mod):new Uint16Array(t.section.mod.slice()),secondary:t.secondaryAllTheSame?t.secondary[0]:t.isSecondaryPaletted?(0,He.S)(t.remappedSecondary?Math.max(t.palettes.secondaryState.size,t.palettes.secondaryId.size):Math.max(e.secondaryState.size,e.secondaryId.size),t.secondary):new Uint16Array(t.secondary)}}}function Xe(t){const e=n._.sectors.get(t.location[0],t.location[1],t.location[2],t.location[3]);if(!e)throw new Error(`Column at location ${location} does not exist when trying to arhicve it.`);const s={ids:new P.N,level:new Pe.h,light:new Pe.h,stateIdMap:[],state:new Pe.h,modIdMap:[],mod:new Pe.h,secondaryId:new P.N,secondaryState:new Pe.h},r=[];for(const t of e.sections){const e=t.ids.length;let i=-1,o=-1,a=-1,n=-1,d=-1,l=-1;const h=Oe(t);for(let r=0;r<e;r++){const e=Gt.A.voxels.getStringId(t.ids[r]),c=s.ids.isRegistered(e)?s.ids.getNumberId(e):s.ids.register(e);h.palettes.ids.isRegistered(c)||h.palettes.ids.register(c),-1==i&&(i=c);const u=Qe.L.VoxelTags[t.ids[r]].dve_can_have_secondary&&Gt.A.voxels.getStringId(t.secondary[r]),g=u?s.secondaryId.isRegistered(u)?s.secondaryId.getNumberId(u):s.secondaryId.register(u):s.secondaryState.isRegistered(t.secondary[r])?s.secondaryState.getId(t.secondary[r]):s.secondaryState.register(t.secondary[r]);u?!h.palettes.secondaryId.isRegistered(g)&&h.palettes.secondaryId.register(g):!h.palettes.secondaryState.isRegistered(g)&&h.palettes.secondaryState.register(g),-1==l&&(l=t.secondary[r]);const f=s.level.isRegistered(t.level[r])?s.level.getId(t.level[r]):s.level.register(t.level[r]);h.palettes.level.isRegistered(t.level[r])||h.palettes.level.register(t.level[r]),-1==a&&(a=f);let p=-1;s.state.isRegistered(t.state[r])?p=s.state.getId(t.state[r]):(p=s.state.register(t.state[r]),s.stateIdMap[p]=u?t.secondary[r]:t.ids[r]),h.palettes.state.isRegistered(p)||h.palettes.state.register(p),-1==n&&(n=p);let m=-1;s.mod.isRegistered(t.mod[r])?m=s.mod.getId(t.mod[r]):(m=s.mod.register(t.mod[r]),s.stateIdMap[m]=u?t.secondary[r]:t.ids[r]),h.palettes.mod.isRegistered(m)||h.palettes.mod.register(m),-1==d&&(d=m);const y=s.light.isRegistered(t.light[r])?s.light.getId(t.light[r]):s.light.register(t.light[r]);h.palettes.light.isRegistered(t.light[r])||h.palettes.light.register(t.light[r]),-1==o&&(o=y),c!=i&&(h.idsAllTheSame=!1),f!=a&&(h.levelAllTheSame=!1),p!=n&&(h.stateAllTheSame=!1),m!=d&&(h.modAllTheSame=!1),y!=o&&(h.lightAllTheSame=!1),g!=l&&(h.secondaryAllTheSame=!1),h.ids[r]=c,h.level[r]=f,h.state[r]=p,h.mod[r]=m,h.secondary[r]=g,h.light[r]=y}r.push(h)}for(const t of r){const e=t.palettes.ids.size<s.ids.size&&t.palettes.ids.size<=255&&!t.idsAllTheSame,r=t.palettes.level.size<s.level.size&&t.palettes.level.size<=255&&!t.levelAllTheSame,i=t.palettes.state.size<s.state.size&&t.palettes.state.size<=255&&!t.stateAllTheSame,o=t.palettes.mod.size<s.mod.size&&t.palettes.mod.size<=255&&!t.modAllTheSame,a=t.palettes.light.size<s.light.size&&t.palettes.light.size<=255&&!t.lightAllTheSame,n=Math.max(t.palettes.secondaryId.size,t.palettes.secondaryState.size)<Math.max(s.secondaryState.size,s.secondaryId.size)&&Math.max(t.palettes.secondaryId.size,t.palettes.secondaryState.size)<=255&&!t.secondaryAllTheSame;if(t.isLightPaletted=s.light.size<65535&&t.palettes.light.size<255,t.isLevelPaletted=s.level.size<255&&t.palettes.level.size<255,t.isStatePaletted=s.state.size<65535&&t.palettes.state.size<255,t.isModPaletted=s.mod.size<65535&&t.palettes.mod.size<255,t.isSecondaryPaletted=s.secondaryState.size<65535&&t.palettes.secondaryState.size<255&&t.palettes.secondaryId.size<255,t.remappedIds=e,t.remappedLight=a&&t.isLightPaletted,t.remappedState=i&&t.isStatePaletted,t.remappedMod=o&&t.isModPaletted,t.remappedSecondary=n&&t.isSecondaryPaletted,!(e||a||n||i))continue;const d=t.section.ids.length;for(let l=0;l<d;l++)e&&(t.ids[l]=t.palettes.ids.getId(t.ids[l])),a&&(t.light[l]=t.palettes.light.getId(t.section.light[l])),r&&(t.level[l]=t.palettes.level.getId(t.section.level[l])),i&&(t.state[l]=t.palettes.state.getId(s.state.getId(t.section.state[l]))),o&&(t.mod[l]=t.palettes.mod.getId(s.mod.getId(t.section.mod[l]))),n&&(t.secondary[l]=Qe.L.VoxelTags[t.ids[l]].dve_can_have_secondary?t.palettes.secondaryId.getId(t.secondary[l]):t.palettes.secondaryState.getId(t.secondary[l]))}const i={};for(let t=0;t<s.state._palette.length;t++){const e=s.state._palette[t],r=Gt.A.voxels.getStringId(s.stateIdMap[t]);if(!Ge.r.hasVoxelSchema(r))continue;const o=Ge.r.getVoxelSchemas(r);i[t]=o.state.getStateObject(e)}const o={};for(let t=0;t<s.mod._palette.length;t++){const e=s.mod._palette[t],r=Gt.A.voxels.getStringId(s.modIdMap[t]);if(!Ge.r.hasVoxelSchema(r))continue;const i=Ge.r.getVoxelSchemas(r);o[t]=i.mod.getStateObject(e)}const a=[];for(const t of r)a.push(Ye(t,s));const d={id:s.ids._palette,stateMap:i,modMap:o,state:new Uint16Array(s.state._palette),mod:new Uint16Array(s.mod._palette)};return s.light.size<255&&(d.light=new Uint16Array(s.light._palette)),s.level.size<255&&(d.level=new Uint8Array(s.level._palette)),s.light.size<255&&(d.light=new Uint16Array(s.light._palette)),s.secondaryId.size>0&&(d.secondaryId=s.secondaryId._palette),s.secondaryState.size<255&&(d.secondaryState=new Uint16Array(s.secondaryState._palette)),{version:"",location:[...t.location],sectorState:{},buffers:{},keys:{sectionState:[]},palettes:d,sections:a}}const Ze=(t,e)=>{(t.palettes.id.length<=15||e.palettes.id&&e.palettes.id.length<=15)&&ArrayBuffer.isView(e.buffers.id)&&(e.buffers.id=(0,He.f)(Math.min(e.palettes.id?.length||1/0,t.palettes.id?.length||0),e.buffers.id)),(e.palettes.light&&e.palettes.light.length<=15||t.palettes.light&&t.palettes.light.length<=15)&&ArrayBuffer.isView(e.buffers.light)&&(e.buffers.light=(0,He.f)(Math.min(e.palettes.light?.length||1/0,t.palettes.light?.length||0),e.buffers.light)),(e.palettes.state&&e.palettes.state.length<=15||t.palettes.state&&t.palettes.state.length<=15)&&ArrayBuffer.isView(e.buffers.state)&&(e.buffers.state=(0,He.f)(Math.min(e.palettes.state?.length||1/0,t.palettes.state?.length||0),e.buffers.state)),(e.palettes.mod&&e.palettes.mod.length<=15||t.palettes.mod&&t.palettes.mod.length<=15)&&ArrayBuffer.isView(e.buffers.mod)&&(e.buffers.mod=(0,He.f)(Math.min(e.palettes.mod?.length||1/0,t.palettes.mod?.length||0),e.buffers.mod)),(e.palettes.secondaryState&&e.palettes.secondaryState.length<=15||t.palettes.secondaryState&&t.palettes.secondaryState.length<=15)&&(e.palettes.secondaryId&&e.palettes.secondaryId.length<=15||t.palettes.secondaryId&&t.palettes.secondaryId.length<=15)&&ArrayBuffer.isView(e.buffers.secondary)&&(e.buffers.secondary=(0,He.f)(Math.max(Math.min(e.palettes.secondaryId?.length||1/0,t.palettes.secondaryId?.length||0),Math.min(e.palettes.secondaryState?.length||1/0,t.palettes.secondaryState?.length||0)),e.buffers.secondary))},We=t=>({sector:t,idPalette:new P.N(t.palettes.id),secondaryId:t.palettes.secondaryId?new P.N(t.palettes.secondaryId):void 0,lightPalette:t.palettes.light?new Pe.h(t.palettes.light):void 0,statePalette:t.palettes.state?new Pe.h(t.palettes.state):void 0,modPalette:t.palettes.mod?new Pe.h(t.palettes.mod):void 0,secondaryState:t.palettes.secondaryState?new Pe.h(t.palettes.secondaryState):void 0}),qe=t=>({section:t,idPalette:t.palettes.id?new Pe.h(t.palettes.id):void 0,lightPalette:t.palettes.light?new Pe.h(t.palettes.light):void 0,statePalette:t.palettes.state?new Pe.h(t.palettes.state):void 0,modPalette:t.palettes.mod?new Pe.h(t.palettes.mod):void 0,secondaryState:t.palettes.secondaryState?new Pe.h(t.palettes.secondaryState):void 0,secondaryId:t.palettes.secondaryId?new Pe.h(t.palettes.secondaryId):void 0}),je=(t,e,s)=>s.section.buffers.state instanceof Uint16Array?t:"number"==typeof s.section.buffers.id?Gt.A.voxels.getNumberId(e.sector.palettes.id[s.section.buffers.id]):s.idPalette?Gt.A.voxels.getNumberId(e.idPalette.getStringId(s.idPalette.getValue(t))):Gt.A.voxels.getNumberId(e.idPalette.getStringId(t)),$e=(t,e,s)=>s.section.buffers.light instanceof Uint16Array||"number"==typeof s.section.buffers.light?t:s.lightPalette?s.lightPalette.getValue(t):e.lightPalette?e.lightPalette.getValue(t):t,Ke=(t,e,s,r,i)=>{const o=Gt.A.voxels.getStringId(t);if(!Ge.r.hasVoxelSchema(o))return e;let a=-1;return(i.section.buffers.state instanceof Uint16Array||"number"==typeof i.section.buffers.state)&&(a=e),i.statePalette?a=i.statePalette.getValue(e):r.statePalette&&(a=e),void 0!==s[a]?s[a]:(e=Ge.r.getVoxelSchemas(o).state.fromStateObject(r.sector.palettes.stateMap[a]),s[a]=e,e)},Je=(t,e,s,r,i)=>{const o=Gt.A.voxels.getStringId(t);if(!Ge.r.hasVoxelSchema(o))return e;let a=-1;return(i.section.buffers.state instanceof Uint16Array||"number"==typeof i.section.buffers.state)&&(a=e),i.modPalette?a=i.modPalette.getValue(e):r.modPalette&&(a=e),void 0!==s[a]?s[a]:(e=Ge.r.getVoxelSchemas(o).mod.fromStateObject(r.sector.palettes.modMap[a]),s[a]=e,e)},ts=(t,e,s,r)=>Qe.L.VoxelTags[t].dve_can_have_secondary?"number"==typeof r.section.buffers.secondary?Gt.A.voxels.getNumberId(s.sector.palettes.secondaryId[r.section.buffers.secondary]):r.secondaryId?Gt.A.voxels.getNumberId(s.secondaryId.getStringId(r.secondaryId.getValue(e))):Gt.A.voxels.getNumberId(s.sector.palettes.secondaryId[e]):"number"==typeof r.section.buffers.secondary?e:r.secondaryState&&s.secondaryState?s.secondaryState.getValue(r.secondaryState.getValue(e)):s.secondaryState?s.secondaryState.getId(e):e;function es(t,e){const s=new p.h(p.h.CreateNew());s.position[0]=t.location[1],s.position[1]=t.location[2],s.position[2]=t.location[3],e.loadColumnState&&e.loadColumnState(t.sectorState,s);const r=We(t),i={},o={};for(let e=0;e<t.sections.length;e++){const a=t.sections[e],n=qe(a),d=s.sections[e],l={};for(let e=0;e<t.keys.sectionState.length;e++)l[t.keys.sectionState[e]]=a.state[e];Ze(t,a);for(let t=0;t<d.ids.length;t++){d.ids[t]=je("number"==typeof a.buffers.id?a.buffers.id:a.buffers.id[t],r,n),d.light[t]=$e("number"==typeof a.buffers.light?a.buffers.light:a.buffers.light[t],r,n),d.secondary[t]=ts(d.ids[t],"number"==typeof a.buffers.secondary?a.buffers.secondary:a.buffers.secondary[t],r,n);let e=Qe.L.VoxelTags[d.ids[t]].dve_can_have_secondary&&d.secondary[t]>0;d.state[t]=Ke(e?d.secondary[t]:d.ids[t],"number"==typeof a.buffers.state?a.buffers.state:a.buffers.state[t],i,r,n),d.mod[t]=Je(e?d.secondary[t]:d.ids[t],"number"==typeof a.buffers.mod?a.buffers.mod:a.buffers.mod[t],o,r,n)}s.sections[e]=d}return s}var ss,rs=s(48493);!function(t){t[t.Name=0]="Name",t[t.Object=1]="Object",t[t.ObjectEnd=2]="ObjectEnd",t[t.Array=3]="Array",t[t.ArrayEnd=4]="ArrayEnd",t[t.Int8=5]="Int8",t[t.Uint8=6]="Uint8",t[t.Uint8Clamped=7]="Uint8Clamped",t[t.Int16=8]="Int16",t[t.Uint16=9]="Uint16",t[t.Float32=10]="Float32",t[t.Int32=11]="Int32",t[t.Uint32=12]="Uint32",t[t.Float64=13]="Float64",t[t.BigInt=14]="BigInt",t[t.BigUint=15]="BigUint",t[t.String=16]="String",t[t.Boolean=17]="Boolean",t[t.Undefined=18]="Undefined",t[t.ArrayBuffer=19]="ArrayBuffer",t[t.TypedArray=20]="TypedArray",t[t.Json=21]="Json",t[t.Blob=22]="Blob"}(ss||(ss={}));const is={[ss.Int8]:rs.QI.Int8,[ss.Uint8]:rs.QI.Uint8,[ss.Uint8Clamped]:rs.QI.Uint8Clamped,[ss.Int16]:rs.QI.Int16,[ss.Uint16]:rs.QI.Uint16,[ss.Float32]:rs.QI.Float32,[ss.Int32]:rs.QI.Int32,[ss.Uint32]:rs.QI.Uint32,[ss.Float64]:rs.QI.Float64,[ss.BigInt]:rs.QI.BigInt,[ss.BigUint]:rs.QI.BigUint};class os{data;get length(){return this.data[2]}get marker(){return this.data[0]}get numberType(){return is[this.marker]}get listType(){return this.data[1]}get value(){return this.data[3]}set value(t){this.data[3]=t}constructor(t,e,s=0,r=0){this.data=[t,s,r,e]}}class as{static json(t){return new os(ss.Json,t)}static object(t){return new os(ss.Object,t)}static array(t){if(!Array.isArray(t))throw new Error("Data for array must be an array.");return new os(ss.Array,t)}static int8(t){return new os(ss.Int8,t)}static uIint8(t){return new os(ss.Uint8,t)}static int16(t){return new os(ss.Int16,t)}static uint16(t){return new os(ss.Uint16,t)}static uint32(t){return new os(ss.Uint32,t)}static int32(t){return new os(ss.Int32,t)}static float32(t){return new os(ss.Float32,t)}static float64(t){return new os(ss.Float64,t)}static bingInt(t){return new os(ss.BigInt,t)}static bigUint(t){return new os(ss.BigUint,t)}static boolean(t){return new os(ss.Boolean,t)}static undefined(){return new os(ss.Undefined,void 0)}static arrayBuffer(t){return new os(ss.ArrayBuffer,t)}static typedArray(t,e){return new os(ss.TypedArray,ArrayBuffer.isView(e)?e:TypedArrayMap[t].from(e),t)}static string(t){return new os(ss.String,t)}}var ns=s(34676);const ds={[rs.QI.Int8]:(t,e=!1)=>new Int8Array(e?new SharedArrayBuffer(t*Int8Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Int8Array.BYTES_PER_ELEMENT)),[rs.QI.Uint8]:(t,e=!1)=>new Uint8Array(e?new SharedArrayBuffer(t*Uint8Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Uint8Array.BYTES_PER_ELEMENT)),[rs.QI.Uint8Clamped]:(t,e=!1)=>new Uint8ClampedArray(e?new SharedArrayBuffer(t*Uint8ClampedArray.BYTES_PER_ELEMENT):new ArrayBuffer(t*Uint8ClampedArray.BYTES_PER_ELEMENT)),[rs.QI.Int16]:(t,e=!1)=>new Int16Array(e?new SharedArrayBuffer(t*Int16Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Int16Array.BYTES_PER_ELEMENT)),[rs.QI.Uint16]:(t,e=!1)=>new Uint16Array(e?new SharedArrayBuffer(t*Uint16Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Uint16Array.BYTES_PER_ELEMENT)),[rs.QI.Int32]:(t,e=!1)=>new Int32Array(e?new SharedArrayBuffer(t*Int32Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Int32Array.BYTES_PER_ELEMENT)),[rs.QI.Uint32]:(t,e=!1)=>new Uint32Array(e?new SharedArrayBuffer(t*Uint32Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Uint32Array.BYTES_PER_ELEMENT)),[rs.QI.Float32]:(t,e=!1)=>new Float32Array(e?new SharedArrayBuffer(t*Float32Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Float32Array.BYTES_PER_ELEMENT)),[rs.QI.Float64]:(t,e=!1)=>new Float64Array(e?new SharedArrayBuffer(t*Float64Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*Float64Array.BYTES_PER_ELEMENT)),[rs.QI.BigInt]:(t,e=!1)=>new BigInt64Array(e?new SharedArrayBuffer(t*BigInt64Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*BigInt64Array.BYTES_PER_ELEMENT)),[rs.QI.BigUint]:(t,e=!1)=>new BigUint64Array(e?new SharedArrayBuffer(t*BigUint64Array.BYTES_PER_ELEMENT):new ArrayBuffer(t*BigUint64Array.BYTES_PER_ELEMENT))};class ls{static _mode="object";static _sharedMemory=!1;static _cobj={};static _parents=[];static _objArray=[];static _name="";static _length=0;static _objCount=0;static _inOject=!1;static _newTypedNode(t,e,s=0){return new os(t,e,s)}static _assign(t){"object"==this._mode||"json"==this._mode?Array.isArray(this._cobj)?this._cobj.push(t):this._cobj[this._name]=t:Array.isArray(this._cobj.value)?this._cobj.value.push(t):this._cobj.value[this._name]=t}static markFunctions={[ss.Name]:(t,e)=>{this._name="";const s=Number(ns.n[rs.QI.Uint8](t,e+1));for(let r=e+=2*rs.bI.Uint8;r<e+s;r++)this._name+=String.fromCharCode(ns.n[rs.QI.Uint8](t,r));return e+s*rs.bI.Uint8},[ss.Object]:(t,e)=>{let s;return s="object"==this._mode?{}:this._newTypedNode(ss.Object,{}),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,rs.bI.Uint8+e},[ss.ObjectEnd]:(t,e)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),rs.bI.Uint8+e),[ss.Array]:(t,e)=>{let s;return s="object"==this._mode?[]:this._newTypedNode(ss.Array,[]),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,rs.bI.Uint8+e},[ss.ArrayEnd]:(t,e)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),rs.bI.Uint8+e),[ss.Boolean]:(t,e)=>{const s=ns.n[rs.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(!s):this._assign(this._newTypedNode(ss.Boolean,!s)),rs.bI.Uint8+rs.bI.Int8+e},[ss.Undefined]:(t,e)=>("type-node"!=this._mode?this._assign(void 0):this._assign(this._newTypedNode(ss.Undefined,void 0)),rs.bI.Uint8+e),[ss.Int8]:(t,e)=>{const s=ns.n[rs.QI.Int8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Int8,s)),rs.bI.Uint8+rs.bI.Int8+e},[ss.Uint8]:(t,e)=>{const s=ns.n[rs.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Uint8,s)),rs.bI.Uint8+rs.bI.Uint8+e},[ss.Uint8Clamped]:(t,e)=>{const s=ns.n[rs.QI.Uint8](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Uint8,s)),rs.bI.Uint8+rs.bI.Uint8+e},[ss.Int16]:(t,e)=>{const s=ns.n[rs.QI.Int16](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Int16,s)),rs.bI.Uint8+rs.bI.Int16+e},[ss.Uint16]:(t,e)=>{const s=ns.n[rs.QI.Uint16](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Uint16,s)),rs.bI.Uint8+rs.bI.Uint16+e},[ss.Float32]:(t,e)=>{const s=ns.n[rs.QI.Float32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Float32,s)),rs.bI.Uint8+rs.bI.Float32+e},[ss.Int32]:(t,e)=>{const s=ns.n[rs.QI.Int32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Int32,s)),rs.bI.Uint8+rs.bI.Int32+e},[ss.Uint32]:(t,e)=>{const s=ns.n[rs.QI.Uint32](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Uint32,s)),rs.bI.Uint8+rs.bI.Uint8+rs.bI.Uint32+e+1},[ss.Float64]:(t,e)=>{const s=ns.n[rs.QI.Float64](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.Float64,s)),rs.bI.Uint8+rs.bI.Float64+e},[ss.BigInt]:(t,e)=>{const s=ns.n[rs.QI.BigInt](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.BigInt,s)),rs.bI.Uint8+rs.bI.BigInt+e},[ss.BigUint]:(t,e)=>{const s=ns.n[rs.QI.BigUint](t,e+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(ss.BigUint,s)),rs.bI.Uint8+rs.bI.BigUint+e},[ss.String]:(t,e)=>{const s=ns.n[rs.QI.Uint32](t,e+1);let r="";for(let i=e+=rs.bI.Uint32+rs.bI.Uint8;i<e+s;i++)r+=String.fromCharCode(ns.n[rs.QI.Uint8](t,i));return"type-node"!=this._mode?this._assign(r):this._assign(this._newTypedNode(ss.String,r)),e+s*rs.bI.Uint8},[ss.TypedArray]:(t,e)=>{const s=ns.n[rs.QI.Uint8](t,e+1);if(void 0===s)throw new Error(`Not a valid type for a typed array ${s}`);const r=ns.n[rs.QI.Uint32](t,e+2);let i;e+=2*rs.bI.Uint8+rs.bI.Uint32,i="json"==this._mode?[]:ds[s](r,this._sharedMemory);const o=ns.n[s];for(let a=0;a<r;a++)i[a]=o(t,e),e+=rs.Yd[s];return"type-node"!=this._mode?this._assign(i):this._assign(this._newTypedNode(ss.TypedArray,i,s)),e},[ss.Blob]:(t,e)=>("type-node"!=this._mode?this._assign(Blob):this._assign(this._newTypedNode(ss.Blob,void 0)),rs.bI.Uint8+e),[ss.ArrayBuffer]:(t,e)=>{const s=ns.n[rs.QI.Uint32](t,e+1);e+=rs.bI.Uint8+rs.bI.Uint32;const r=new Uint8Array(this._sharedMemory?new SharedArrayBuffer(s):new ArrayBuffer(s));for(let i=0;i<s;i++)r[i]=ns.n[rs.QI.Uint8](t,e),e+=rs.QI.Uint8;return"type-node"!=this._mode?this._assign(r.buffer):this._assign(this._newTypedNode(ss.ArrayBuffer,r.buffer)),e},[ss.Json]:(t,e)=>{const s=ns.n[rs.QI.Uint32](t,e+1);let r="";for(let i=e+=rs.bI.Float32+rs.bI.Uint8;i<e+s;i++)r+=String.fromCharCode(ns.n[rs.QI.Uint8](t,i));const i=JSON.parse(r);return"type-node"!=this._mode?this._assign(i):this._assign(this._newTypedNode(ss.Json,i)),e+s*rs.bI.Uint8}};static setUseSharedMemory(t){this._sharedMemory=t}static toObject(t,e=0,s=0){let r;this._mode="object",r=0==s?t.byteLength:s;const i=new DataView(t);this._objCount=0;let o=e,a=ss.Object;for(;o<r;)a=ns.n[rs.QI.Uint8](i,o),o=this.markFunctions[a](i,o);return this._cobj}static toJSON(t,e=0,s=0){let r;this._mode="json",r=0==s?t.byteLength:s;const i=new DataView(t);this._objCount=0;let o=e,a=ss.Object;for(;o<r;)a=ns.n[rs.QI.Uint8](i,o),o=this.markFunctions[a](i,o);return this._cobj}static toTypedNodes(t,e=0,s=0){let r;this._mode="type-node",r=0==s?t.byteLength:s,this._mode="object";const i=new DataView(t);this._objCount=0;let o=e,a=ss.Object;for(;o<r;)a=ns.n[rs.QI.Uint8](i,o),o=this.markFunctions[a](i,o);return this._cobj}}rs.QI.Int8,Int8Array,rs.QI.Uint8,Uint8Array,rs.QI.Uint8Clamped,Uint8ClampedArray,rs.QI.Int16,Int16Array,rs.QI.Uint16,Uint16Array,rs.QI.Float32,Float32Array,rs.QI.Int32,Int32Array,rs.QI.Uint32,Uint32Array,rs.QI.Float64,Float64Array,rs.QI.BigInt,BigInt64Array,rs.QI.BigUint,BigUint64Array;const hs=new Map([[Int8Array,rs.QI.Int8],[Uint8Array,rs.QI.Uint8],[Uint8ClampedArray,rs.QI.Uint8Clamped],[Int16Array,rs.QI.Int16],[Uint16Array,rs.QI.Uint16],[Int32Array,rs.QI.Int32],[Uint32Array,rs.QI.Uint32],[Float32Array,rs.QI.Float32],[Float64Array,rs.QI.Float64],[BigInt64Array,rs.QI.BigInt],[BigUint64Array,rs.QI.BigUint]]);var cs,us=s(85648);class gs{static view=new DataView(new ArrayBuffer(8));static count=0;static value=0;static setValue(t,e){return this.value=e,us.v[t](this.view,0,e),this.count=rs.Yd[t],this}static addBytes(t){for(let e=0;e<this.count;e++)t.push(this.view.getUint8(e))}}class fs{static _proto=[];static _tokenizeString(t){for(let e=0;e<t.length;e++)this._addToken(rs.QI.Uint8,t.charCodeAt(e))}static _traverseObj(t){this._addMarker(ss.Object);for(const e of Object.keys(t.value)){if(e.length>255)throw new Error("An object key cannot be longer then 255 chars.");this._addMarker(ss.Name),this._addToken(rs.QI.Uint8,e.length),this._tokenizeString(e);const s=t.value[e];s.marker!=ss.Object||ArrayBuffer.isView(s.value)?s.marker!=ss.Array||ArrayBuffer.isView(s.value)?this._tokenizePrimiives(s):this._traverseArray(s):this._traverseObj(s)}this._addMarker(ss.ObjectEnd)}static _traverseArray(t){this._addMarker(ss.Array);const e=t.value;for(const t of e)"object"!=typeof t.value||Array.isArray(t.value)||ArrayBuffer.isView(t.value)?"object"!=typeof t.value||!Array.isArray(t.value)||ArrayBuffer.isView(t.value)?this._tokenizePrimiives(t):this._traverseArray(t):this._traverseObj(t);this._addMarker(ss.ArrayEnd)}static _tokenizePrimiives(t){if(t.marker!=ss.String){if("number"==typeof t.value)return this._addMarker(t.marker),void this._addToken(t.numberType,t.value);if("boolean"==typeof t.value)return this._addMarker(t.marker),void this._addToken(rs.QI.Uint8,t.value?0:1);if(void 0!==t.value)if(t.marker!=ss.ArrayBuffer){if(t.marker==ss.TypedArray){this._addMarker(ss.TypedArray),this._addToken(rs.QI.Uint8,t.listType),this._addToken(rs.QI.Uint32,t.value.length);let e=t.value;for(let s=0;s<e.length;s++)this._addToken(t.listType,e[s])}if(t.marker!=ss.Json);else{let e="";e="object"==typeof t.value?JSON.stringify(t.value):t.value,this._addMarker(ss.Json),this._addToken(rs.QI.Uint32,e.length);for(let t=0;t<e.length;t++)this._addToken(rs.QI.Uint8,e.charCodeAt(t))}}else{this._addMarker(ss.ArrayBuffer);const e=new Uint8Array(t.value);this._addToken(rs.QI.Uint32,e.length);for(let t=0;t<e.length;t++)this._addToken(rs.QI.Uint8,e[t])}else this._addMarker(ss.Undefined)}else{this._addMarker(ss.String),this._addToken(rs.QI.Uint32,t.value.length);for(let e=0;e<t.value.length;e++)this._addToken(rs.QI.Uint8,t.value.charCodeAt(e))}}static _tokenize(t){t.marker!=ss.Object||Array.isArray(t.value)||this._traverseObj(t),t.marker==ss.Array&&Array.isArray(t.value)&&this._traverseArray(t)}static toBuffer(t){this._tokenize(t);const e=Uint8Array.from(this._proto);return this._proto=[],e.buffer}static _addMarker(t){gs.setValue(rs.QI.Uint8,t).addBytes(this._proto)}static _addToken(t,e){gs.setValue(t,e).addBytes(this._proto)}}class ps{static _name="";static _traverseObj(t){const e=as.object({});for(const s of Object.keys(t)){const r=t[s];this._name=s,r instanceof os?e.value[s]=r:ArrayBuffer.isView(r)||r instanceof ArrayBuffer||r instanceof SharedArrayBuffer?e.value[s]=this._addPrimitive(r):r instanceof Blob||"undefined"!=typeof File&&r instanceof File||("object"!=typeof r||Array.isArray(r)?"object"==typeof r&&Array.isArray(r)?e.value[s]=this._traverseArray(r):e.value[s]=this._addPrimitive(r):e.value[s]=this._traverseObj(r))}return e}static _traverseArray(t){const e=as.array([]);for(const s of t)s instanceof os?e.value.push(s):ArrayBuffer.isView(s)?e.value.push(this._addPrimitive(s)):"object"!=typeof s||Array.isArray(s)?"object"!=typeof s||!Array.isArray(s)||ArrayBuffer.isView(s)?e.value.push(this._addPrimitive(s)):e.value.push(this._traverseArray(s)):e.value.push(this._traverseObj(s));return e}static _addPrimitive(t){if("string"==typeof t)return as.string(t);if("number"==typeof t)return as.float64(t);if("boolean"==typeof t)return as.boolean(t);if(void 0===t)return as.undefined();if(t instanceof ArrayBuffer||t instanceof SharedArrayBuffer)return as.arrayBuffer(t);if(ArrayBuffer.isView(t)&&hs.has(t.constructor))return as.typedArray(hs.get(t.constructor),t);if(t instanceof os)return t;throw new Error("Unsuppourted type for DBO parser.")}static tokTypedNodes(t){if("object"==typeof t&&!Array.isArray(t)){const e=as.object({});return e.value=this._traverseObj(t).value,e}if("object"==typeof t&&Array.isArray(t)){const e=as.array([]);return e.value=this._traverseArray(t).value,e}return this._addPrimitive(t)}static toBuffer(t){const e=this.tokTypedNodes(t);return fs.toBuffer(e)}}class ms{static nodes=as;static setUseSharedMemory(t){ls.setUseSharedMemory(t)}static bufferToObject(t,e=0,s=0){return ls.toObject(t,e,s)}static objectToBuffer(t){return ps.toBuffer(t)}static objectToTypedNodes(t){return ps.tokTypedNodes(t)}static typedNodeToBuffer(t){return fs.toBuffer(t)}static bufferToTypedNodes(t,e=0,s=0){return ls.toTypedNodes(t,e,s)}}function ys(t){if(!n._.sectors.get(t[0],t[1],t[2],t[3]))throw new Error(`Sector at location ${t.toString()} does not exist`);const e=Xe({location:t}),s=[];e.palettes.light&&s.push(e.palettes.light.buffer),e.palettes.state&&s.push(e.palettes.state.buffer),e.palettes.secondaryState&&s.push(e.palettes.secondaryState.buffer);for(const t of e.sections)"number"!=typeof t.buffers.id&&s.push(t.buffers.id.buffer),"number"!=typeof t.buffers.light&&s.push(t.buffers.light.buffer),"number"!=typeof t.buffers.state&&s.push(t.buffers.state.buffer),"number"!=typeof t.buffers.secondary&&s.push(t.buffers.secondary.buffer),"number"!=typeof t.buffers.mod&&s.push(t.buffers.mod.buffer),t.palettes.id&&s.push(t.palettes.id.buffer),t.palettes.light&&s.push(t.palettes.light.buffer),t.palettes.state&&s.push(t.palettes.state.buffer),t.palettes.mod&&s.push(t.palettes.mod.buffer),t.palettes.secondaryState&&s.push(t.palettes.secondaryState.buffer),t.palettes.secondaryId&&s.push(t.palettes.secondaryId.buffer);return[e,s]}async function xs(t={}){const e=new i.c;i.c.environment=a.O.isNode()?"node":"browser";let s="render";"node"==i.c.environment&&(s="server"),await o.QK.init("constructor",self,s);let g=!1;var f,p;return(0,r.A)({onSync(t){!function(t,e){ae.register(t),Qt.registerCustomNode("liquid",De),Qt.setGeometryPalette(e.geometryPalette),Qt.registerGeometry(e.geometry),Qt.registerModels(e.models);for(const t of e.voxels)Qt.registerVoxel(new Ne(t.id,ae.meshersMap.get(t.materialId),Qt.modelData.get(t.modelId),t))}(t.voxels.materials.palette,t.voxels.models),g=!0}}),o.QK.registerTask("clear-all",(()=>{n._.clearAll()})),await new Promise((t=>{const e=()=>{if(g)return t(!0);setTimeout(e,10)};e()})),function(t){o.QK.registerTask("archive-sector",(async t=>ys(t))),o.QK.registerTask("archive-sector-binary",(async t=>{const[e]=ys(t),s=await async function(t){return await new Response(new Blob([ms.objectToBuffer(t)]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()}(e);return[s,[s]]})),o.QK.registerTask("import-sector",(async e=>{const s=es(e,{});await t.worldThread.runTaskAsync("load-sector",[e.location,s])})),o.QK.registerTask("import-sector-binary",(async([e,s])=>{const r=es(await async function(t,e=!1){const s=await new Response(new Blob([t]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer();ms.setUseSharedMemory(e);const r=ms.bufferToObject(s);return ms.setUseSharedMemory(!1),r}(s,!0),{});await t.worldThread.runTaskAsync("load-sector",[e,r])}))}({worldThread:e.threads.world}),o.QK.registerTask(ye.U.SyncDimension,(t=>{n._.dimensions.add(t.id)})),o.QK.registerTask(ye.U.UnSyncDimension,(t=>{})),o.QK.registerTask(ye.U.SyncSector,(t=>{n._.sectors.add(t[0][0],t[0][1],t[0][2],t[0][3],t[1])})),o.QK.registerTask(ye.U.UnSyncSector,(t=>{n._.sectors.remove(t[0],t[1],t[2],t[3])})),o.QK.registerTask(d.z.Propagation,(async t=>{const e=new c.P;e.setOrigin(t),function(t){if(!l.i.doLight)return!1;const e=n._.sectors.get(t.origin[0],t.origin[1],t.origin[2],t.origin[3]);if(!e)return console.error(`Tried running world rgb on a sector that does not exist ${t.origin.toString()}`),!1;let s=A.k.section.bounds.x+e.position[0],r=A.k.section.bounds.z+e.position[2];for(let i=0;i<e.sections.length;i++){const o=e.sections[i];if(!o)continue;N.setSection(o);let[a,n]=o.getMinMax();const d=e.position[0],l=e.position[1]+i*A.k.section.bounds.y,h=e.position[2];if(Math.abs(a)!=1/0||Math.abs(n)!=1/0)for(let e=l+a;e<=l+n;e++)for(let i=d;i<s;i++)for(let s=h;s<r;s++){const r=N.getVoxel(i,e,s);r&&!r.isAir()&&r.isLightSource()&&t.rgb.update.push(i,e,s)}}(0,u.D)(t)}(e)})),o.QK.registerTask(d.z.Explosion,(async t=>{const e=t[0],s=A.k.sector.getPosition(e[1],e[2],e[3]),r=new c.P;r.setOrigin([e[0],s.x,s.y,s.z]),R.runExplosion(r,t[1])})),o.QK.registerTask(d.z.WorldSun,(t=>{const e=A.k.sector.getPosition(t[1],t[2],t[3]),s=new c.P;s.setOrigin([t[0],e.x,e.y,e.z]),function(t){const[e,s,r,i]=t.origin,o=C.getRelative(t.origin),a=C.getAbsolute(t.origin),n=s+A.k.sector.bounds.x,d=A.k.world.bounds.MaxY,l=i+A.k.sector.bounds.z,c=t.nDataCursor.getSector(t.origin[1],t.origin[2],t.origin[3]);if(!c)return void console.warn("Could not load sector when running world sun at ",t.origin.toString());const u=a-1<0?0:a,g=c.getSection(s,u,i).getPosition()[1]+A.k.section.bounds.y;for(let t=u;t<g;t++)for(let e=s;e<n;e++)for(let s=i;s<l;s++){const r=c.getVoxel(e,t,s);if(!r)continue;const i=r.getLight();i<0||r.setLight(D.setS(15,i))}for(let t=g;t<d;t+=A.k.section.bounds.y){const e=c.getSection(s,t,i),r=e.light.length;for(let t=0;t<r;t++)e.light[t]=D.setS(15,e.light[t])}const f=a==o?o+1:o;let p=z.length;for(let e=u;e<=f;e++)for(let r=s;r<n;r++)for(let s=i;s<l;s++){const i=c.getVoxel(r,e,s)?.getLight();if(!(i&&i<0&&15!=D.getS(i)))for(let i=0;i<h.LE.length;i++){const o=h.LE[i],a=r+o[0],n=e+o[1],d=s+o[2],l=t.nDataCursor.getVoxel(a,n,d);if(!l)continue;const c=l.getLight();if(c>-1&&D.getS(c)<15){z[p++]=r,z[p++]=e,z[p++]=s;break}}}for(;z.length;){const e=z.shift(),s=z.shift(),r=z.shift(),i=t.sDataCursor.getVoxel(e,s,r)?.getLight();if(!i||i<0)continue;for(let o=0;o<5;o++){const a=e+_[o][0],n=s+_[o][1],d=r+_[o][2],l=t.nDataCursor.getVoxel(a,n,d);if(l){const t=l.getLight();t>-1&&(0,T.j4)(t,i)&&(z.push(a),z.push(n),z.push(d),l.setLight((0,T.ig)(i,t)))}}const o=t.nDataCursor.getVoxel(e,s-1,r);if(o){const t=o.getLight();t>-1&&(0,T.jg)(t,i)&&(o.isAir()?(z.push(e),z.push(s-1),z.push(r),o.setLight((0,T.Kl)(i,t))):o.isOpaque()||(z.push(e),z.push(s-1),z.push(r),o.setLight((0,T.ig)(i,t))))}}}(s)})),f=e.threads.parent,o.QK.registerTask(d.z.BuildSection,(t=>{const e=[],s=ge(t,e);s&&f.runTask("set-section",s,e)})),o.QK.registerTask(d.z.BuildSector,(t=>{const e=A.k.sector.getPosition(t[1],t[2],t[3]),s=n._.sectors.get(t[0],e.x,e.y,e.z);if(!s)return void console.warn("Tried building a sector that does not exists.",[e.x,e.y,e.z]);if(0==s.sections.length)return void console.warn("Tried building a sector with no sections.",s.position);const r=[];for(let e=0;e<s.sections.length;e++){const i=s.sections[e];if(!i)continue;let[o,a]=i.getMinMax();if(Math.abs(o)==1/0&&Math.abs(a)==1/0)continue;r.length=0;const n=ge([t[0],s.position[0],s.position[1]+e*A.k.section.bounds.y,s.position[2]],r);n&&f.runTask("set-section",n,r)}})),p={onDone(t,e){e.runTask("build-queue",[t.origin[0],t.bounds.getSections()])}},o.QK.registerTask(d.z.VoxelUpdate,(async(t,e)=>{const s=await S(t);s&&p.onDone(s,e)})),o.QK.registerTask(d.z.VoxelErease,(async(t,e)=>{const s=await I(t);s&&p.onDone(s,e)})),o.QK.registerTask(d.z.VoxelPaint,(async(t,e)=>{const s=await w(t);s&&p.onDone(s,e)})),o.QK.registerTask(d.z.Generate,(t=>new Promise((e=>me.J.generate(t,"generate",e))))),o.QK.registerTask(d.z.Decorate,(t=>new Promise((e=>me.J.generate(t,"decorate",e))))),e}s(36713),function(t){t[t.Boolean=0]="Boolean",t[t.TypedNumber=1]="TypedNumber",t[t.TypedNumberArray=2]="TypedNumberArray",t[t.BitArray=3]="BitArray",t[t.Vector2=4]="Vector2",t[t.Vector3=5]="Vector3",t[t.Vector4=6]="Vector4"}(cs||(cs={})),s(87706),rs.bI.Uint32,rs.bI.Uint8},95305:(t,e,s)=>{s.d(e,{LE:()=>o,vY:()=>i});const r=[],i=[[0,0],[1,0],[0,1],[1,1],[-1,0],[0,-1],[-1,-1],[1,-1],[-1,1]],o=[[0,1,0],[0,-1,0],[1,0,0],[-1,0,0],[0,0,-1],[0,0,1]];for(let t=-1;t<2;t++)for(const e of i)r.push([e[0],t,e[1]])},65053:(t,e,s)=>{s.d(e,{Hp:()=>u,Hx:()=>f,IH:()=>I,In:()=>g,Kl:()=>v,QT:()=>w,We:()=>m,Zk:()=>S,ig:()=>b,j4:()=>y,jg:()=>x,pq:()=>p,tr:()=>A});let r=2;function i(t){return 15&t}function o(t){return(240&t)>>4}function a(t){return(3840&t)>>8}function n(t){return(61440&t)>>12}function d(t,e){return-16&e|t}function l(t,e){return-241&e|t<<4}function h(t,e){return-3841&e|t<<8}function c(t,e){return-61441&e|t<<12}function u(t,e){let s=o(t),r=a(t),i=n(t),d=o(e),l=a(e),h=n(e);return s<d||r<l||i<h}function g(t,e){let s=o(t)+2,r=a(t)+2,i=n(t)+2,d=o(e),l=a(e),h=n(e);return s<=d||r<=l||i<=h}function f(t,e){let s=o(t),r=a(t),i=n(t),d=o(e),l=a(e),h=n(e);return s>=d||r>=l||i>=h}function p(t,e){let s=i(e),r=o(t)-1;r<0&&(r=0);let u=o(e);r<u&&(r=u);let g=a(t)-1;g<0&&(g=0);let f=a(e);g<f&&(g=f);let p=n(t)-1;p<0&&(p=0);let m=n(e);p<m&&(p=m);let y=0;return y=d(s,y),y=l(r,y),y=h(g,y),y=c(p,y),y}function m(t){let e=i(t),s=0;return s=l(0,s),s=h(0,s),s=c(0,s),s=d(e,s),s}function y(t,e){let s=i(t),o=i(e);return s+r<o}function x(t,e){let s=i(t),o=i(e);return 15==o?s<o:s+r<o}function v(t,e){let s=i(t),u=i(e);15==s&&(u=s),s<15&&(u=s-r);let g=o(e),f=a(e),p=n(e),m=0;return m=d(u,m),m=l(g,m),m=h(f,m),m=c(p,m),m}function b(t,e){let s=i(t)-r;s<0&&(s=0);let u=i(e);s<u&&(s=u);let g=o(e),f=a(e),p=n(e),m=0;return m=d(s,m),m=l(g,m),m=h(f,m),m=c(p,m),m}function I(t,e){return i(t)<i(e)}function w(t,e){return i(t)>=i(e)}function S(t,e){let s=i(e);return 15==s||i(t)<s}function A(t){return d(0,t)}},45733:(t,e,s)=>{s.d(e,{D:()=>o,Q:()=>a});var r=s(95305),i=s(65053);function o(t){const e=t.rgb.update;for(;e.length;){const s=e.shift(),o=e.shift(),a=e.shift(),n=t.sDataCursor.getVoxel(s,o,a);if(!n)continue;const d=n.getLight();if(!(d<=0)){for(let n=0;n<6;n++){const l=r.LE[n][0]+s,h=r.LE[n][1]+o,c=r.LE[n][2]+a;if(!t.nDataCursor.inBounds(l,h,c))continue;const u=t.nDataCursor.getVoxel(l,h,c);if(!u)continue;const g=u.getLight();g>-1&&(0,i.In)(g,d)&&(e.push(l,h,c),u.setLight((0,i.pq)(d,g)))}t.bounds.update(s,o,a)}}}function a(t){const e=t.rgb.remove,s=t.rgb.update,o=t.rgb.removeMap,a=t.sun.updateMap;for(;e.length;){const n=e.shift(),d=e.shift(),l=e.shift();if(o.has(n,d,l))continue;o.add(n,d,l);const h=t.sDataCursor.getVoxel(n,d,l);if(!h)continue;const c=h.getLight();if(!(c<=0)){for(let o=0;o<6;o++){const h=r.LE[o][0]+n,u=r.LE[o][1]+d,g=r.LE[o][2]+l;if(!t.nDataCursor.inBounds(h,u,g))continue;const f=t.nDataCursor.getVoxel(h,u,g);if(!f)continue;const p=f.getLight(),m=f.hasRGBLight();m&&(0,i.Hp)(p,c)?(e.push(h,u,g),f.isLightSource()&&s.push(h,u,g)):m&&(0,i.Hx)(p,c)&&!a.has(h,u,g)&&(a.add(h,u,g),s.push(h,u,g))}t.bounds.update(n,d,l),h.setLight((0,i.We)(c))}}o.clear()}},15660:(t,e,s)=>{s.d(e,{a:()=>o,z:()=>a});var r=s(65053);const i=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]];function o(t){const e=t.sun.update;for(;e.length;){const s=e.shift(),o=e.shift(),a=e.shift(),n=t.sDataCursor.getVoxel(s,o,a);if(!n)continue;const d=n.getLight();if(!(d<=0)){for(let n=0;n<5;n++){const l=i[n][0]+s,h=i[n][1]+o,c=i[n][2]+a;if(!t.nDataCursor.inBounds(l,h,c))continue;const u=t.nDataCursor.getVoxel(l,h,c);if(u){const t=u.getLight();t>-1&&(0,r.j4)(t,d)&&(e.push(l,h,c),u.setLight((0,r.ig)(d,t)))}}if(t.nDataCursor.inBounds(s,o-1,a)){const i=t.nDataCursor.getVoxel(s,o-1,a);if(i){const t=i.getLight();t>-1&&(0,r.jg)(t,d)&&(i.isAir()?(e.push(s,o-1,a),i.setLight((0,r.Kl)(d,t))):i.isOpaque()||(e.push(s,o-1,a),i.setLight((0,r.ig)(d,t))))}}t.bounds.update(s,o,a)}}}function a(t,e=!0){const s=t.sun.remove,o=t.sun.update,a=t.sun.removeMap,n=t.sun.updateMap;for(;s.length;){const e=s.shift(),d=s.shift(),l=s.shift();if(a.has(e,d,l))continue;a.add(e,d,l);const h=t.sDataCursor.getVoxel(e,d,l);if(!h)continue;const c=h.getLight();if(!(c<=0)){for(let a=0;a<5;a++){const h=i[a][0]+e,u=i[a][1]+d,g=i[a][2]+l;if(!t.nDataCursor.inBounds(h,u,g))continue;const f=t.nDataCursor.getVoxel(h,u,g);if(f){const t=f.getLight();t>0&&((0,r.IH)(t,c)?s.push(h,u,g):(0,r.QT)(t,c)&&!n.has(h,u,g)&&(n.add(h,u,g),o.push(h,u,g)))}}if(t.nDataCursor.inBounds(e,d-1,l)){const i=t.nDataCursor.getVoxel(e,d-1,l);if(i){const t=i.getLight();t>0&&((0,r.Zk)(t,c)?s.push(e,d-1,l):(0,r.QT)(t,c)&&!n.has(e,d-1,l)&&(n.add(e,d-1,l),o.push(e,d-1,l)))}}t.bounds.update(e,d,l),h.setLight((0,r.tr)(c))}}a.clear()}},67568:(t,e,s)=>{s.d(e,{P:()=>c});var r=s(35609),i=s(61e3),o=s(56059);class a{_map=[];get size(){return this._map.length}origin=i.Az.Create();start(t,e,s){this._map.length=0,this.origin.x=t,this.origin.y=e,this.origin.z=s}has(t,e,s){return void 0!==this._map[i.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]}add(t,e,s){this._map[i.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]=!0}delete(t,e,s){this._map[i.Az.HashXYZ(t-this.origin.x,e-this.origin.y,s-this.origin.z)]=void 0}clear(){this._map.length=0}}const n=i.Az.Create(-1/0,-1/0,-1/0),d=i.Az.Create(1/0,1/0,1/0),l=i.Az.Create();class h{_task;min=i.Az.Clone(d);max=i.Az.Clone(n);constructor(t){this._task=t}reset(){i.Az.Copy(this.min,d),i.Az.Copy(this.max,n)}update(t,e,s){t<this.min.x&&(this.min.x=t),e<this.min.y&&(this.min.y=e),s<this.min.z&&(this.min.z=s),t>this.max.x&&(this.max.x=t),e>this.max.y&&(this.max.y=e),s>this.max.z&&(this.max.z=s)}getSections(){const t=o.k.section.getPosition(this.min.x-1,this.min.y-1,this.min.z-1,l),e=t.x,s=t.y,r=t.z,i=o.k.section.getPosition(this.max.x+1,this.max.y+1,this.max.z+1,l),a=i.x,n=i.y,d=i.z,h=[];for(let t=e;t<=a;t+=o.k.section.bounds.x)for(let e=s;e<=n;e+=o.k.section.bounds.y)for(let s=r;s<=d;s+=o.k.section.bounds.z)this._task.nDataCursor.inBounds(t,e,s)&&h.push([t,e,s]);return h}}class c{flow=new u;rgb=new g;sun=new g;bounds=new h(this);sDataCursor=new r.p;nDataCursor=new r.p;origin;setOrigin(t){this.sDataCursor.setFocalPoint(...t),this.nDataCursor.setFocalPoint(...t),this.origin=t,this.rgb.removeMap.start(t[1],t[2],t[3]),this.sun.removeMap.start(t[1],t[2],t[3]),this.rgb.updateMap.start(t[1],t[2],t[3]),this.sun.updateMap.start(t[1],t[2],t[3]),this.flow.update.map.start(t[1],t[2],t[3]),this.flow.remove.map.start(t[1],t[2],t[3]),this.flow.remove.noRemoveMap.start(t[1],t[2],t[3]),this.clear()}clear(){this.rgb.clear(),this.sun.clear(),this.flow.clear(),this.bounds.reset()}}class u{update={queue:[],map:new a};remove={queue:[],map:new a,noRemoveMap:new a};clear(){this.update.queue.length=0,this.update.map.clear(),this.remove.queue.length=0,this.remove.map.clear(),this.remove.noRemoveMap.clear()}}class g{update=[];remove=[];removeMap=new a;updateMap=new a;clear(){this.update.length=0,this.remove.length=0,this.removeMap.clear(),this.updateMap.clear()}}},93693:(t,e,s)=>{s.d(e,{T:()=>u});var r=s(1054),i=s(18048),o=s(96914),a=s(30729),n=s(1323),d=s(67568),l=s(45733),h=s(15660);const c=new o.$;class u extends i.l{constructor(){super(),a.J._brushes.push(this)}requestsId;tasks=new d.P;start(t,e,s,r){return this.dataCursor.setFocalPoint(t,e,s,r),this.tasks.setOrigin([t,e,s,r]),this.dimension=t,this.x=e,this.y=s,this.z=r,this}paint(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t){if(""!=this.requestsId)return r.o.addToRequest(this.requestsId,[this.dimension,this.x,this.y,this.z],this.voxelCursor.getRaw()),this;throw new Error(`Tried painting in an unloaded location ${[this.dimension,this.x,this.y,this.z].toString()}`)}const e=t.getLight();return(e>0||!t.isAir())&&(this._erase(),t.setLight(e<0?0:e),c.hasRGBLight(e)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,l.Q)(this.tasks)),c.hasSunLight(e)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,h.z)(this.tasks))),this._paint(),this.tasks.bounds.update(this.x,this.y,this.z),this}getUpdatedSections(){const t=this.tasks.bounds.getSections();return this.tasks.bounds.reset(),t}update(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t)return!1;const e=t.getLight();t.updateVoxel(2),c.hasRGBLight(e)&&this.tasks.rgb.update.push(this.x,this.y,this.z),c.hasSunLight(e)&&this.tasks.sun.update.push(this.x,this.y,this.z),this.tasks.bounds.update(this.x,this.y,this.z)}erase(){let t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t)return this;const e=t.getLight();return this._erase(),t=this.dataCursor.getVoxel(this.x,this.y,this.z),t.setLight(e>0?e:0),c.hasRGBLight(e)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,l.Q)(this.tasks)),c.hasSunLight(e)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,h.z)(this.tasks)),this.tasks.bounds.update(this.x,this.y,this.z),this}runUpdates(){(0,l.D)(this.tasks),(0,h.a)(this.tasks),this.tasks.rgb.removeMap.clear(),this.tasks.sun.removeMap.clear()}worldAlloc(t,e){return n.c.instance.threads.world.runTaskAsync("world-alloc",[this.dimension,t,e])}worldDealloc(t,e){return n.c.instance.threads.world.runTaskAsync("world-dealloc",[this.dimension,t,e])}}},1054:(t,e,s)=>{s.d(e,{o:()=>d});var r=s(56059),i=s(18048),o=s(1323),a=s(1481);const n=new i.l;n.voxelCursor;class d{static MAX_ATTEMPTS=100;static _requests=new Map;static registerRequest(t){const e=t.toString();return this._requests.set(e,{attempts:0,sections:new Map,dimension:t[0],voxels:[]}),e}static addToRequest(t,e,s){if(e[2]<r.k.world.bounds.MinY||e[2]>=r.k.world.bounds.MaxY)return!1;const i=this._requests.get(t);if(!i)return;if(!a._.sectors.get(e[0],e[1],e[2],e[3])){const t=r.k.sector.getPosition(e[1],e[2],e[3]),s=r.k.hash.hashVec3(t);i.sections.has(s)||(o.c.instance.threads.world.runTask("add-sector",[i.dimension,t.x,t.y,t.z]),i.sections.set(s,[t.x,t.y,t.z]))}const[n,d,l,h]=e;i.voxels.push([d,l,h,s])}static attemptRequestFullFill(t){const e=this._requests.get(t);if(!e||!e.voxels.length)return!0;let s=!0;for(const[t,i]of e.sections)r.k.world.inBounds(i[0],i[1],i[2])&&(a._.sectors.get(e.dimension,i[0],i[1],i[2])||(s=!1,o.c.instance.threads.world.runTask("add-sector",[e.dimension,i[0],i[1],i[2]])));return s?(n.stop(),this._requests.delete(t),!0):(e.attempts++,e.attempts>=this.MAX_ATTEMPTS&&(console.error("World gen requests cancled after max attempts",e),this._requests.delete(t),!0))}}},30729:(t,e,s)=>{s.d(e,{J:()=>o});var r=s(1054),i=s(93693);class o{static worldGen=null;static register=r.o;static _brushes=[];static setWorldGen(t){this.worldGen=t}static async generate(t,e,s){if(!this.worldGen)throw new Error("A World Generator must be set.");const i=r.o.registerRequest(t[0]);for(const t of this._brushes)t.requestsId=i;if("generate"==e&&await this.worldGen.generate(t),"decorate"==e&&await this.worldGen.decorate(t),r.o.attemptRequestFullFill(i))s();else{const t=()=>{r.o.attemptRequestFullFill(i)?s():setTimeout(t,10)};t()}}static getBrush(){return new i.T}}},41986:(t,e,s)=>{s.d(e,{S:()=>n,f:()=>d});var r=s(87706),i=s(55935);class o{buffer;data;constructor(t){return this.buffer=t,this.data=new DataView(ArrayBuffer.isView(t)?t.buffer:t),new Proxy(this,{get:(t,e)=>{if("string"==typeof e&&!isNaN(Number(e))){const s=Number(e);return t.get(s)}return t[e]},set:(t,e,s)=>{if("string"==typeof e&&!isNaN(Number(e))){const r=Number(e);return t.set(r,s),!0}return t[e]=s,!0}})}get length(){return 4*this.buffer.byteLength}get(t){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);return i.u.getHalfNibbleArrayIndex(this.data,0,t)}set(t,e){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);if(e<0||e>3)throw new RangeError(`Value ${e} is out of bounds for a half nibble`);i.u.setHalfNibbleArrayIndex(this.data,0,t,e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.get(t++),done:!1}:{value:void 0,done:!0}}}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}}class a{buffer;data;constructor(t){return this.buffer=t,this.data=new DataView(ArrayBuffer.isView(t)?t.buffer:t),new Proxy(this,{get:(t,e)=>{if("string"==typeof e&&!isNaN(Number(e))){const s=Number(e);return t.get(s)}return t[e]},set:(t,e,s)=>{if("string"==typeof e&&!isNaN(Number(e))){const r=Number(e);return t.set(r,s),!0}return t[e]=s,!0}})}get length(){return 2*this.buffer.byteLength}get(t){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);return i.u.getNibbleArrayIndex(this.data,0,t)}set(t,e){if(t<0||t>=this.length)throw new RangeError(`Index ${t} is out of bounds`);if(e<0||e>15)throw new RangeError(`Value ${e} is out of bounds for a nibble`);i.u.setNibbleArrayIndex(this.data,0,t,e)}[Symbol.iterator](){let t=0;return{next:()=>t<this.length?{value:this.get(t++),done:!1}:{value:void 0,done:!0}}}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e,this)}}const n=(t,e,s=!1)=>{let i=e;if(t>15&&t<=255)i=Uint8Array.from(e);else if(t>4&&t<=15){i=new Uint8Array(e.length/2);const t=new a(i);for(let s=0;s<e.length;s++)t[s]=e[s]}else if(t>2&&t<=4){i=new Uint8Array(e.length/4);const t=new o(i);for(let s=0;s<e.length;s++)t[s]=e[s]}else if(2==t){i=new Uint8Array(e.length/8);const t=new r.P(i);for(let s=0;s<e.length;s++)t[s]=e[s]}if(s&&!(i.buffer instanceof SharedArrayBuffer)){const t=new SharedArrayBuffer(i.byteLength),e=new Uint8Array(t);return e.set(i),e}return i},d=(t,e)=>2==t?new r.P(e):t>2&&t<=4?new o(e):t>4&&t<=15?new a(e):e},25012:(t,e,s)=>{s.d(e,{h:()=>r});class r{_count=0;_palette=[];_map={};get size(){return this._count}constructor(t){if(t){let e=t.length;for(let s=0;s<e;s++)this.register(t[s])}}register(t){const e=this._count;return this._palette[e]=t,this._map[t]=e,this._count++,e}get(){return this._palette}getMap(){return this._map}isRegistered(t){return void 0!==this._map[t]}getId(t){return this._map[t]}getValue(t){return this._palette[t]}}},35609:(t,e,s)=>{s.d(e,{p:()=>l});var r=s(61e3),i=s(9879),o=s(56059),a=s(40892);let n=[];const d=r.Az.Create();class l extends a.s{sectorCursors=new Map;origin={x:0,y:0,z:0};dimension="";setFocalPoint(t,e,s,r){const i=o.k.sector.getPosition(e,s,r,d);for(const[t,e]of this.sectorCursors)for(const[t,s]of e)n.push(s);this.sectorCursors.clear(),this.dimension=t,this.origin.x=i.x/o.k.sector.bounds.x,this.origin.y=i.y/o.k.sector.bounds.y,this.origin.z=i.z/o.k.sector.bounds.z}inBounds(t,e,s){return o.k.world.inBounds(t,e,s)}getSector(t,e,s){if(!this.inBounds(t,e,s))return null;const r=o.k.sector.getPosition(t,e,s,d),a=r.x/o.k.sector.bounds.x-this.origin.x,l=r.z/o.k.sector.bounds.z-this.origin.z;let h=this.sectorCursors.get(a),c=h?.get(l);if(!c){if(c=n.length?n.shift():new i.j,!c.setSector(this.dimension,r.x,r.y,r.z))return n.push(c),null;h||(h=new Map,this.sectorCursors.set(a,h)),h.set(l,c)}return c}getVoxel(t,e,s){const r=this.getSector(t,e,s);return r?r.getVoxel(t,e,s):null}}}},n={};function d(t){var e=n[t];if(void 0!==e)return e.exports;var s=n[t]={exports:{}};return a[t].call(s.exports,s,s.exports,d),s.exports}d.m=a,d.x=()=>{var t=d.O(void 0,[419,738,920],(()=>d(99497)));return d.O(t)},t="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",e="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",s="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=t=>{t&&t.d<1&&(t.d=1,t.forEach((t=>t.r--)),t.forEach((t=>t.r--?t.r++:t())))},d.a=(i,o,a)=>{var n;a&&((n=[]).d=-1);var d,l,h,c=new Set,u=i.exports,g=new Promise(((t,e)=>{h=e,l=t}));g[e]=u,g[t]=t=>(n&&t(n),c.forEach(t),g.catch((t=>{}))),i.exports=g,o((i=>{var o;d=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[t])return i;if(i.then){var o=[];o.d=0,i.then((t=>{a[e]=t,r(o)}),(t=>{a[s]=t,r(o)}));var a={};return a[t]=t=>t(o),a}}var n={};return n[t]=t=>{},n[e]=i,n})))(i);var a=()=>d.map((t=>{if(t[s])throw t[s];return t[e]})),l=new Promise((e=>{(o=()=>e(a)).r=0;var s=t=>t!==n&&!c.has(t)&&(c.add(t),t&&!t.d&&(o.r++,t.push(o)));d.map((e=>e[t](s)))}));return o.r?l:a()}),(t=>(t?h(g[s]=t):l(u),r(n)))),n&&n.d<0&&(n.d=0)},i=[],d.O=(t,e,s,r)=>{if(!e){var o=1/0;for(h=0;h<i.length;h++){for(var[e,s,r]=i[h],a=!0,n=0;n<e.length;n++)(!1&r||o>=r)&&Object.keys(d.O).every((t=>d.O[t](e[n])))?e.splice(n--,1):(a=!1,r<o&&(o=r));if(a){i.splice(h--,1);var l=s();void 0!==l&&(t=l)}}return t}r=r||0;for(var h=i.length;h>0&&i[h-1][2]>r;h--)i[h]=i[h-1];i[h]=[e,s,r]},d.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return d.d(e,{a:e}),e},d.d=(t,e)=>{for(var s in e)d.o(e,s)&&!d.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},d.f={},d.e=t=>Promise.all(Object.keys(d.f).reduce(((e,s)=>(d.f[s](t,e),e)),[])),d.u=t=>t+".bundle.js",d.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),d.p="/",(()=>{var t={63:1};d.f.i=(e,s)=>{t[e]||importScripts(d.p+d.u(e))};var e=self.webpackChunkdivinecraft=self.webpackChunkdivinecraft||[],s=e.push.bind(e);e.push=e=>{var[r,i,o]=e;for(var a in i)d.o(i,a)&&(d.m[a]=i[a]);for(o&&o(d);r.length;)t[r.pop()]=1;s(e)}})(),o=d.x,d.x=()=>Promise.all([419,738,920].map(d.e,d)).then(o),d.x()})();