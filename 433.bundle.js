"use strict";(self.webpackChunkdivinecraft=self.webpackChunkdivinecraft||[]).push([[433],{78441:(t,e,a)=>{a.d(e,{x:()=>r});class r{x;y;static ApplyMatrix(t,e){return{x:t[0]*e.x+t[1]*e.y+t[2],y:t[3]*e.x+t[4]*e.y+t[5]}}static ApplyMatrixArray(t,e){return[t[0]*e[0]+t[1]*e[1]+t[2],t[3]*e[0]+t[4]*e[1]+t[5]]}static RotateAroundPivot(t,e,a){const i={x:e.x-a.x,y:e.y-a.y},s=r.ApplyMatrix(t,i);return{x:s.x+a.x,y:s.y+a.y}}static RotateAroundPivotArray(t,e,a){const i=[e[0]-a[0],e[1]-a[1]],s=r.ApplyMatrixArray(t,i);return[s[0]+a[0],s[1]+a[1]]}static Create(t=0,e=0){return new r(t,e)}static Add(t,e){return{x:t.x+e.x,y:t.y+e.y}}static AddToRef(t,e,a){a.x=t.x+e.x,a.y=t.y+e.y}static AddInPlace(t,e){t.x+=e.x,t.y+=e.y}static AddArray(t,e){return[t[0]+e[0],t[1]+e[1]]}static AddArrayToRef(t,e,a){a[0]=t[0]+e[0],a[1]=t[1]+e[1]}static AddArrayInPlace(t,e){t[0]+=e[0],t[1]+=e[1]}static AddScalar(t,e){return{x:t.x+e,y:t.y+e}}static AddScalarToRef(t,e,a){a.x=t.x+e,a.y=t.y+e}static AddScalarInPlace(t,e){t.x+=e,t.y+=e}static AddScalarArray(t,e){return[t[0]+e,t[1]+e]}static AddScalarArrayToRef(t,e,a){a[0]=t[0]+e,a[1]=t[1]+e}static AddScalarArrayInPlace(t,e){t[0]+=e,t[1]+=e}static Subtract(t,e){return{x:t.x-e.x,y:t.y-e.y}}static SubtractToRef(t,e,a){a.x=t.x-e.x,a.y=t.y-e.y}static SubtractInPlace(t,e){t.x-=e.x,t.y-=e.y}static SubtractArray(t,e){return[t[0]-e[0],t[1]-e[1]]}static SubtractArrayToRef(t,e,a){a[0]=t[0]-e[0],a[1]=t[1]-e[1]}static SubtractArrayInPlace(t,e){t[0]-=e[0],t[1]-=e[1]}static SubtractScalar(t,e){return{x:t.x-e,y:t.y-e}}static SubtractScalarToRef(t,e,a){a.x=t.x-e,a.y=t.y-e}static SubtractScalarInPlace(t,e){t.x-=e,t.y-=e}static SubtractScalarArray(t,e){return[t[0]-e,t[1]-e]}static SubtractScalarArrayToRef(t,e,a){a[0]=t[0]-e,a[1]=t[1]-e}static SubtractScalarArrayInPlace(t,e){t[0]-=e,t[1]-=e}static Multiply(t,e){return{x:t.x*e.x,y:t.y*e.y}}static MultiplyToRef(t,e,a){a.x=t.x*e.x,a.y=t.y*e.y}static MultiplyInPlace(t,e){t.x*=e.x,t.y*=e.y}static MultiplyArray(t,e){return[t[0]*e[0],t[1]*e[1]]}static MultiplyArrayToRef(t,e,a){a[0]=t[0]*e[0],a[1]=t[1]*e[1]}static MultiplyArrayInPlace(t,e){t[0]*=e[0],t[1]*=e[1]}static MultiplyScalar(t,e){return{x:t.x*e,y:t.y*e}}static MultiplyScalarToRef(t,e,a){a.x=t.x*e,a.y=t.y*e}static MultiplyScalarInPlace(t,e){t.x*=e,t.y*=e}static MultiplyScalarArray(t,e){return[t[0]*e,t[1]*e]}static MultiplyScalarArrayToRef(t,e,a){a[0]=t[0]*e,a[1]=t[1]*e}static MultiplyScalarArrayInPlace(t,e){t[0]*=e,t[1]*=e}static Divide(t,e){return{x:t.x/e.x,y:t.y/e.y}}static DivideToRef(t,e,a){a.x=t.x/e.x,a.y=t.y/e.y}static DivideInPlace(t,e){t.x/=e.x,t.y/=e.y}static DivideArray(t,e){return[t[0]/e[0],t[1]/e[1]]}static DivideArrayToRef(t,e,a){a[0]=t[0]/e[0],a[1]=t[1]/e[1]}static DivideArrayInPlace(t,e){t[0]/=e[0],t[1]/=e[1]}static DivideScalar(t,e){return{x:t.x/e,y:t.y/e}}static DivideScalarToRef(t,e,a){a.x=t.x/e,a.y=t.y/e}static DivideScalarInPlace(t,e){t.x/=e,t.y/=e}static DivideScalarArray(t,e){return[t[0]/e,t[1]/e]}static DivideScalarArrayToRef(t,e,a){a[0]=t[0]/e,a[1]=t[1]/e}static DivideScalarArrayInPlace(t,e){t[0]/=e,t[1]/=e}static Dot(t,e){return t.x*e.x+t.y*e.y}static DotArray(t,e){return t[0]*e[0]+t[1]*e[1]}static Length(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static LengthArray(t){return Math.sqrt(t[0]*t[0]+t[1]*t[1])}static Normalize(t){const e=r.Length(t);return 0===e?{x:0,y:0}:{x:t.x/e,y:t.y/e}}static NormalizeToRef(t,e){const a=r.Length(t);0===a?(e.x=0,e.y=0):(e.x=t.x/a,e.y=t.y/a)}static NormalizeInPlace(t){const e=r.Length(t);0===e?(t.x=0,t.y=0):(t.x/=e,t.y/=e)}static NormalizeArray(t){const e=r.LengthArray(t);return 0===e?[0,0]:[t[0]/e,t[1]/e]}static NormalizeArrayToRef(t,e){const a=r.LengthArray(t);0===a?(e[0]=0,e[1]=0):(e[0]=t[0]/a,e[1]=t[1]/a)}static NormalizeArrayInPlace(t){const e=r.LengthArray(t);0===e?(t[0]=0,t[1]=0):(t[0]/=e,t[1]/=e)}static Distance(t,e){return r.Length(r.Subtract(t,e))}static DistanceArray(t,e){return r.LengthArray(r.SubtractArray(t,e))}static Lerp(t,e,a){return{x:t.x+a*(e.x-t.x),y:t.y+a*(e.y-t.y)}}static LerpToRef(t,e,a,r){r.x=t.x+a*(e.x-t.x),r.y=t.y+a*(e.y-t.y)}static LerpInPlace(t,e,a){t.x+=a*(e.x-t.x),t.y+=a*(e.y-t.y)}static LerpArray(t,e,a){return[t[0]+a*(e[0]-t[0]),t[1]+a*(e[1]-t[1])]}static LerpArrayToRef(t,e,a,r){r[0]=t[0]+a*(e[0]-t[0]),r[1]=t[1]+a*(e[1]-t[1])}static LerpArrayInPlace(t,e,a){t[0]+=a*(e[0]-t[0]),t[1]+=a*(e[1]-t[1])}static Negate(t){return{x:-t.x,y:-t.y}}static NegateToRef(t,e){e.x=-t.x,e.y=-t.y}static NegateInPlace(t){t.x=-t.x,t.y=-t.y}static NegateArray(t){return[-t[0],-t[1]]}static NegateArrayToRef(t,e){e[0]=-t[0],e[1]=-t[1]}static NegateArrayInPlace(t){t[0]=-t[0],t[1]=-t[1]}static Equals(t,e){return t.x===e.x&&t.y===e.y}static EqualsArray(t,e){return t[0]===e[0]&&t[1]===e[1]}static Clone(t){return{x:t.x,y:t.y}}static CloneArray(t){return[t[0],t[1]]}static Copy(t,e){return t.x=e.x,t.y=e.y,t}static CopyArray(t,e){return t[0]=e[0],t[1]=e[1],t}static CopyFromArray(t,e){return t.x=e[0],t.y=e[1],t}static CopyIntoArray(t,e){return t[0]=e.x,t[1]=e.y,t}static ToArray(t){return[t.x,t.y]}static FromArray(t){return new r(t[0],t[1])}constructor(t,e){this.x=t,this.y=e}}},80740:(t,e,a)=>{var r;a.d(e,{m:()=>r}),function(t){t.RunBuildQueue="run-build-queue-for-tasks",t.PlaceVoxel="place-voxel",t.RemoveVoxel="remove-voxel",t.PlaceVoxelArea="place-voxel-area",t.RemoveVoxelArea="remove-voxel-area",t.BuildTemplate="build-template"}(r||(r={}))},86081:(t,e,a)=>{var r;a.d(e,{z:()=>r}),function(t){t[t.BuildSection=0]="BuildSection",t[t.BuildSector=1]="BuildSector",t[t.Generate=2]="Generate",t[t.Decorate=3]="Decorate",t[t.RGBlightUpdate=4]="RGBlightUpdate",t[t.RGBlightRemove=5]="RGBlightRemove",t[t.WorldSun=6]="WorldSun",t[t.SunLightUpdate=7]="SunLightUpdate",t[t.SunLightRemove=8]="SunLightRemove",t[t.Propagation=9]="Propagation",t[t.AnalyzerUpdate=10]="AnalyzerUpdate",t[t.FlowUpdate=11]="FlowUpdate",t[t.FlowRemove=12]="FlowRemove",t[t.ConstructEntity=13]="ConstructEntity",t[t.ConstructItem=14]="ConstructItem",t[t.Explosion=15]="Explosion",t[t.VoxelErease=16]="VoxelErease",t[t.VoxelPaint=17]="VoxelPaint",t[t.VoxelUpdate=18]="VoxelUpdate",t[t.LogicUpdate=19]="LogicUpdate"}(r||(r={}))},83651:(t,e,a)=>{a.d(e,{l:()=>c});var r=a(48860),i=a(19305),s=a(75438),o=a(18556);const n=[0,0,0,0,0,0];class c{data={id:"dve_air",name:"",state:0,secondaryVoxelId:"",secondaryVoxeName:"",level:0,levelState:0,mod:0};dimension=0;x=0;y=0;z=0;voxelCursor=new i.x;dataCursor=new r.p;setXYZ(t,e,a){return this.x=t,this.y=e,this.z=a,this}newSector(){s._.sectors.new(this.dimension,this.x,this.y,this.z)}setData(t){return this.clear(),t.name?this.setName(t.name):t.id&&this.setId(t.id),t.secondaryVoxeName?this.setSecondaryName(t.secondaryVoxeName):t.secondaryVoxelId&&this.setSecondaryId(t.secondaryVoxelId),this.data.state=t.state?t.state:0,this.data.level=t.level?t.level:0,this.data.levelState=t.levelState?t.levelState:0,this.data.mod=t.mod?t.mod:0,this}getData(){return this.data}setRaw(t){return this.voxelCursor.copyRaw(t).process(),this.data.id=this.voxelCursor.getStringId(),this.data.state=this.voxelCursor.getState(),this.data.levelState=this.voxelCursor.getLevelState(),this.data.level=this.voxelCursor.getLevel(),this.voxelCursor.setSecondary(!0),this.voxelCursor.secondaryId>=2&&(this.data.secondaryVoxelId=this.voxelCursor.getStringId()),this.voxelCursor.setSecondary(!1),this.data.mod=this.voxelCursor.getMod(),this}getRaw(){return i.x.VoxelDataToRaw(this.data)}setId(t){return this.data.id=t,this.data.name=o.A.voxelIdToNameMap.get(t),this}setName(t){return this.data.id=o.A.voxelNametoIdMap.get(t),this.data.name=t,this}setSecondaryId(t){return this.data.secondaryVoxelId=t,this.data.secondaryVoxeName=t?o.A.voxelIdToNameMap.get(t):"",this}setSecondaryName(t){return this.data.secondaryVoxelId=t?o.A.voxelNametoIdMap.get(t):"",this.data.secondaryVoxeName=t,this}setShapeState(t){return this.data.state=t,this}setLevel(t){return this.data.level=t,this}setLevelState(t){return this.data.levelState=t,this}setMod(t){return this.data.mod=t,this}clear(){this.data.id="dve_air",this.data.name="",this.data.secondaryVoxelId="",this.data.level=0,this.data.levelState=0,this.data.state=0,this.data.mod=0,this.x=0,this.y=0,this.z=0}_debug=!1;_paint(){if(!this.dataCursor.inBounds(this.x,this.y,this.z))return!1;const t=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!t)return;const e=o.A.voxels.getNumberId(this.data.id);if(e<0)return!1;if(t.setId(e),this._debug&&console.warn(this.x,this.y,this.z,this.data.state),t.setState(this.data.state),t.setLevel(this.data.level),t.setMod(this.data.mod),this.data.secondaryVoxelId){const e=o.A.voxels.getNumberId(this.data.secondaryVoxelId);e>0&&(t.setSecondary(!0),t.setId(e),t.setSecondary(!1))}t.process(),t.isLightSource()&&t.getLightSourceValue()&&t.setLight(t.getLightSourceValue()),t.updateVoxel(0)}_erase(){const t=this.dataCursor.getVoxel(this.x,this.y,this.z);t&&t.copyRaw(n).updateVoxel(1)}paint(){return this._paint(),this}erase(){return this._erase(),this}start(t,e,a,r){return this.dataCursor.setFocalPoint(t,e,a,r),this.dimension=t,this.x=e,this.y=a,this.z=r,this}stop(){return this}}},19305:(t,e,a)=>{a.d(e,{x:()=>o});var r=a(46088),i=a(18556),s=a(63846);class o extends r.S{static VoxelDataToRaw(t,e=0){const a=void 0!==t.id&&i.A.voxels.getNumberId(t.id)||0,r=void 0!==t.secondaryVoxelId&&i.A.voxels.getNumberId(t.secondaryVoxelId)||0;let o=0;return void 0!==t.level&&(o=s.o.setLevel(o,t.level)),void 0!==t.levelState&&(o=s.o.setLevelState(o,t.levelState)),[a,e,o,t.state||0,t.mod||0,r]}ids=new Uint16Array(1);light=new Uint16Array(1);level=new Uint8Array(1);state=new Uint16Array(1);mod=new Uint16Array(1);secondary=new Uint16Array(1);loadIn(){}updateVoxel(t){}}},52196:(t,e,a)=>{a.d(e,{w:()=>l});var r=a(62312),i=a(70522),s=a(85212),o=a(80903),n=a(29105);const c=[0,0];class l{sector;index;static GetBufferSize(){const t=r.k.section.volumne,e=r.k.section.bounds.y;return(0,n.bZ)(2+e/8+e/8+e/8+t/8+t/8+2*t+2*t+t+2*t+2*t+2*t)}static GetArrayStartIndex(t){return t*l.GetBufferSize()+i.h.GetHeaderSize()}static CreateNew(t,e){const a=r.k.section.volumne,i=r.k.section.bounds.y;let s=this.GetArrayStartIndex(t);const o=new Uint8Array(e,s,2);s+=2;const n=new Uint8Array(e,s,i/8);s+=i/8;const c=new Uint8Array(e,s,i/8);s+=i/8;const l=new Uint8Array(e,s,i/8);s+=i/8;const y=new Uint8Array(e,s,a/8);s+=a/8;const d=new Uint8Array(e,s,a/8);s+=a/8;const h=new Uint16Array(e,s,a);s+=2*a;const x=new Uint16Array(e,s,a);s+=2*a;const u=new Uint16Array(e,s,a);s+=2*a;const g=new Uint16Array(e,s,a);s+=2*a;const p=new Uint16Array(e,s,a);s+=2*a;const A=new Uint8Array(e,s,a);return s+=a,{flagArray:o,voxelMap:n,dirtyMap:c,logicDirtyMap:l,logicDirty:d,buried:y,ids:h,light:x,level:A,state:u,mod:g,secondary:p}}static toObject(t,e,a){return new l(t,e,a)}position;constructor(t,e,a){this.sector=t,this.index=e,this.position=r.k.section.getPositionFromIndexVec3Array(this.index),this.position[0]=this.position[0]*r.k.section.bounds.x+this.sector.position[0],this.position[1]=this.position[1]*r.k.section.bounds.y+this.sector.position[1],this.position[2]=this.position[2]*r.k.section.bounds.z+this.sector.position[2],this.flagArray=a.flagArray,this.voxelMap=a.voxelMap,this.dirtyMap=a.dirtyMap,this.logicDirty=a.logicDirty,this.logicDirtyMap=a.logicDirtyMap,this.buried=a.buried,this.ids=a.ids,this.level=a.level,this.light=a.light,this.secondary=a.secondary,this.state=a.state,this.mod=a.mod}getPosition(){return this.position}setBitFlag(t,e){(0,s.JU)(this.flagArray,t,e?1:0)}getBitFlag(t){return 1==(0,s.Tv)(this.flagArray,t)}isDisplayDirty(){return this.getBitFlag(o.n.displayDirty)}setDisplayDirty(t){this.setBitFlag(o.n.displayDirty,t),t&&(this.sector.setStored(!1),this.sector.setDisplayDirty(!0))}isLogicDirty(){return this.getBitFlag(o.n.logicDirty)}setLogicDirty(t){this.setBitFlag(o.n.logicDirty,t),t&&this.sector.setLogicDirty(!0)}isLogicSliceDirty(t){return 1==(0,s.Tv)(this.logicDirtyMap,t)}setLogicSliceDirty(t,e){(0,s.JU)(this.logicDirtyMap,t,e?1:0)}getVoxelLogicDirty(t){return 1==(0,s.Tv)(this.logicDirty,t)}setVoxelLogicDirty(t,e){return(0,s.JU)(this.logicDirty,t,e?1:0)}isInProgress(){return this.getBitFlag(o.n.inProgress)}setInProgress(t){this.setBitFlag(o.n.inProgress,t)}isLogicUpdateInProgress(){return this.getBitFlag(o.n.logicUpdateInProgress)}setLogicUpdateInProgress(t){this.setBitFlag(o.n.logicUpdateInProgress,t)}getBuried(t){return 1==(0,s.Tv)(this.buried,t)}setBuried(t,e){return(0,s.JU)(this.buried,t,e?1:0)}setHasVoxel(t,e){return(0,s.JU)(this.voxelMap,t,e?1:0)}getHasVoxel(t){return 1==(0,s.Tv)(this.voxelMap,t)}setHasVoxelDirty(t,e){return(0,s.JU)(this.dirtyMap,t,e?1:0)}getHasVoxelDirty(t){return 1==(0,s.Tv)(this.dirtyMap,t)}getMinMax(){let t=1/0,e=-1/0,a=r.k.section.bounds.y;for(;a--;)(this.getHasVoxel(a)||this.getHasVoxelDirty(a))&&(a<t&&(t=a),a>e&&(e=a));return c[0]=t,c[1]=e,c}getLogicMinMax(){let t=1/0,e=-1/0,a=r.k.section.bounds.y;for(;a--;)this.isLogicSliceDirty(a)&&(a<t&&(t=a),a>e&&(e=a));return c[0]=t,c[1]=e,c}storeFlags(){const t={};for(const e in o.B.StoredFlags)t[e]=this.getBitFlag(o.B.StoredFlags[e]);return t}loadFlags(t){for(const e in t){const a=o.B.StoredFlags[e];void 0!==a?this.setBitFlag(a,t[e]):console.warn(`${e} does not exist on stored flags for section`)}}toJSON(){return{flagArray:this.flagArray,logicDirtyMap:this.logicDirtyMap,logicDirty:this.logicDirty,voxelMap:this.voxelMap,dirtyMap:this.dirtyMap,buried:this.buried,ids:this.ids,light:this.light,level:this.level,secondary:this.secondary,state:this.state,mod:this.mod}}}}}]);