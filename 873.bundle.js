(()=>{"use strict";var e,t,s,r,i,a,o={78872:(e,t,s)=>{s.a(e,(async(e,t)=>{try{var r=s(20707),i=s(94618),a=s(26983);(new(s(90842).J)).init(),await(0,r.V)(),(0,a.A)(),(0,i.A)(),t()}catch(e){t(e)}}),1)},90842:(e,t,s)=>{s.d(t,{J:()=>ft});var r=s(20650),i=s(66454);class a{chunkDepth=16;chunkWidth=16;minHeight=60;worldHeight=256;noiseHeight=120;waterHeight=60;noise;brush;init(e){this.noise=e.noise,this.brush=e.brush}}const o=(e=[-1,1],t=[-1,1],s=[-1,1],r=[-10,-10],i=[-1,1],a=!1,o=!1,n=!1,l=!0,d=!1,h=!1)=>({temperature:e,moisture:t,elevation:s,river:r,mod:i,hardLimitMoisture:a,hardLimitTemperature:o,hardLimitElevation:n,hardLimitRiver:l,hardLimitMod:d,excludeRiver:h}),n=(e,t)=>t.temperature[0]<=e[0]&&t.temperature[0]>=e[1],l=(e,t)=>t.moisture[0]<=e[1]&&t.moisture[1]>=e[1],d=(e,t)=>t.elevation[0]<=e[2]&&t.elevation[1]>=e[2],h=(e,t)=>{let s=0,r=!1,i=0;if(!t.hardLimitTemperature||t.hardLimitTemperature&&n(e,t)){const r=(t.temperature[1]+t.temperature[0])/2;s+=1-Math.abs((e[0]-r)/(t.temperature[1]-t.temperature[0])),i++}else t.hardLimitTemperature&&!n(e,t)&&(r=!0);if(!t.hardLimitMoisture||t.hardLimitMoisture&&l(e,t)){const r=(t.moisture[1]+t.moisture[0])/2;s+=1-Math.abs((e[1]-r)/(t.moisture[1]-t.moisture[0])),i++}else t.hardLimitMoisture&&!l(e,t)&&(r=!0);if(!t.hardLimitElevation||t.hardLimitElevation&&d(e,t)){const r=(t.elevation[1]+t.elevation[0])/2;s+=1-Math.abs((e[2]-r)/(t.elevation[1]-t.elevation[0])),i++}else t.hardLimitElevation&&d(e,t)&&(r=!0);if(t.river[1]>0)if(!t.hardLimitRiver||t.hardLimitRiver&&((e,t)=>t.river[0]<=e[3]&&t.river[1]>=e[3])(e,t)){const r=(t.river[1]+t.river[0])/2;s+=1-Math.abs((e[3]-r)/(t.river[1]-t.river[0])),i++}else t.hardLimitRiver&&(r=!0);if(t.mod[1]>0&&void 0!==e[4])if(!t.hardLimitMod||t.hardLimitMod&&((e,t)=>t.mod[0]<=e[4]&&t.mod[1]>=e[4])(e,t)){const r=(t.mod[1]+t.mod[0])/2;s+=1-Math.abs((e[4]-r)/(t.mod[1]-t.mod[0])),i++}else t.hardLimitMod&&(r=!0);return r?0:s/(i||1)};class c{static _biomeTypes=new Map;static _biomes=new Map;static _caveCarver=new Map;static registerBiomes(...e){e.forEach((e=>this._biomes.set(e.data.id,e)))}static getBiome(e){const t=this._biomes.get(e);if(!t)throw new Error(`The biome with id ${e} does not exist.`);return t}static registerBiomeTypes(...e){e.forEach((e=>this._biomeTypes.set(e.data.id,e)))}static getBiomeType(e){const t=this._biomeTypes.get(e);if(!t)throw new Error(`The biome type with id ${e} does not exist.`);return t}static registerCaveCarver(...e){e.forEach((e=>this._caveCarver.set(e.data.id,e)))}static getCaveCarver(e){const t=this._caveCarver.get(e);if(!t)throw new Error(`The cave carver with id ${e} does not exist.`);return t}}class u{nodes;constructor(e){this.nodes=e}}const g=2**32;class f extends u{static data={id:"valley"};getCarved(e,t,s){const r=500;t+=1e5;let i=e+200*this.nodes.noise.detailNoise((e-g+1e5)/r,(t-g+1e5)/r,(s-g+1e5)/r),a=t+200*this.nodes.noise.detailNoise((e-g+1e5)/r,(t-g-1e5)/r,(s-g+1e5)/r),o=s+200*this.nodes.noise.detailNoise((e-g-1e5)/r*1.9,(t-g+1e5)/r,(s-g-1e5)/r)*1.9,n=this.nodes.noise.detailNoise((i-g)/100,(a-g)/100,(o-g)/100);const l=this.nodes.noise.worldGenDetailNoise((e+1e3)/r,(t+1e3)/r,(s+1e3)/r);return n=1-Math.abs(n-.5),n=Math.pow(n,16),n>.8&&l>.6}getData(){return f.data}getClass(){return f}}var m;!function(e){e.Snow="dc_snow",e.Stone="dc_stone",e.GrassBlock="dc_grass_block",e.Dirt="dc_dirt",e.Sand="dc_sand",e.Water="dc_water",e.Gravel="dc_gravel",e.Clay="dc_clay",e.Ice="dc_ice",e.Andesite="dc_andesite",e.Granite="dc_granite",e.CobbleStone="dc_cobble_stone",e.MossyCobbleStone="dc_mossy_cobble_stone",e.GlowStone="dc_glow_stone",e.OakLog="dc_oak_log",e.OakPlanks="dc_oak_planks",e.OakLeaves="dc_oak_leaves",e.SpruceLog="dc_spruce_log",e.SpruceLeaves="dc_spruce_leaves",e.SprucePlanks="dc_spruce_planks",e.SmoothAndesite="dc_smooth_andesite",e.SmoothGranite="dc_smooth_granite",e.Glass="dc_glass",e.Podzol="dc_podzol",e.EmeraldOre="dc_emerald_ore",e.GoldOre="dc_gold_ore",e.IronOre="dc_iron_ore",e.LapisOre="dc_lapis_ore",e.RedstoneOre="dc_redstone_ore",e.CoalBlock="dc_coal_block",e.DiamondBlock="dc_diamond_block",e.GoldBlock="dc_gold_block",e.IronBlock="dc_iron_block",e.Mycelium="dc_mycelium",e.TallFern="dc_tall_fern",e.TallGrass="dc_tall_grass",e.TallRose="dc_tall_rose",e.PaeoniaFlower="dc_paeonia_flower",e.SyringaFlower="dc_syringa_flower",e.BlueOrchidFlower="dc_blue_orchid_flower",e.DandelionFlower="dc_dandelion_flower",e.OxeyeDaisyFlower="dc_oxeye_daisy_flower",e.TulipFlower="dc_tulip_flower",e.WaterlilyFlower="dc_waterlily_flower",e.Vine="dc_vine",e.Fern="dc_fern",e.Reeds="dc_reeds",e.Kelp="dc_kelp",e.Cactus="dc_cactus",e.Grass="dc_grass",e.SeaGrass="dc_sea_grass",e.BrainCoral="dc_brain_coral",e.BrainCoralBlock="dc_brain_coral_block",e.BubbleCoral="dc_bubble_coral",e.BubbleCoralBlock="dc_bubble_coral_block",e.DeadBrainCoralBlock="dc_dead_brain_coral_block",e.DeadBubbleCoralBlock="dc_dead_bubble_coral_block",e.DeadFireCoral="dc_dead_fire_coral",e.DeadFireCoralBlock="dc_dead_fire_coral_block",e.DeadHornCoral="dc_dead_horn_coral",e.DeadHornCoralBlock="dc_dead_horn_coral_block",e.DeadTubeCoral="dc_dead_tube_coral",e.DeadTubeCoralBlock="dc_dead_tube_coral_block",e.DeadBrainCoral="dc_dead_brain_coral",e.DeadBubbleCoral="dc_dead_bubble_coral",e.FireCoral="dc_fire_coral",e.FireCoralBlock="dc_fire_coral_block",e.HornCoral="dc_horn_coral",e.HornCoralBlock="dc_horn_coral_block",e.TubeCoral="dc_tube_coral",e.TubeCoralBlock="dc_tube_coral_block",e.DarkOakLeaves="dc_dark_oak_leaves",e.DarkOakLog="dc_dark_oak_log",e.DarkOakPlanks="dc_dark_oak_planks",e.AcaciaLeaves="dc_acacia_leaves",e.AcaciaLog="dc_acacia_log",e.AcaciaPlanks="dc_acacia_planks",e.BirchLeaves="dc_birch_leaves",e.BirchLog="dc_birch_log",e.BirchPlanks="dc_birch_planks",e.DarkPrismarine="dc_dark_prismarine",e.Prismarine="dc_prismarine",e.PrismarineBricks="dc_prismarine_bricks",e.Bedrock="dc_bedrock",e.Obsidian="dc_obsidan",e.SeaLantern="dc_sea_lantern"}(m||(m={}));const p={[m.Stone]:{name:m.Stone},[m.SeaLantern]:{name:m.SeaLantern},[m.Snow]:{name:m.Snow},[m.SeaGrass]:{name:m.SeaGrass},[m.GrassBlock]:{name:m.GrassBlock},[m.Grass]:{name:m.Grass},[m.Dirt]:{name:m.Dirt},[m.Sand]:{name:m.Sand},[m.Water]:{name:m.Water},[m.Gravel]:{name:m.Gravel},[m.Clay]:{name:m.Clay},[m.Ice]:{name:m.Ice},[m.Andesite]:{name:m.Andesite},[m.Granite]:{name:m.Granite},[m.CobbleStone]:{name:m.CobbleStone},[m.MossyCobbleStone]:{name:m.MossyCobbleStone},[m.GlowStone]:{name:m.GlowStone},[m.OakLog]:{name:m.OakLog},[m.OakPlanks]:{name:m.OakPlanks},[m.OakLeaves]:{name:m.OakLeaves},[m.SpruceLog]:{name:m.SpruceLog},[m.SpruceLeaves]:{name:m.SpruceLeaves},[m.SprucePlanks]:{name:m.SprucePlanks},[m.SmoothAndesite]:{name:m.SmoothAndesite},[m.SmoothGranite]:{name:m.SmoothGranite},[m.Glass]:{name:m.Glass},[m.Podzol]:{name:m.Podzol},[m.EmeraldOre]:{name:m.EmeraldOre},[m.GoldOre]:{name:m.GoldOre},[m.IronOre]:{name:m.IronOre},[m.LapisOre]:{name:m.LapisOre},[m.RedstoneOre]:{name:m.RedstoneOre},[m.CoalBlock]:{name:m.CoalBlock},[m.DiamondBlock]:{name:m.DiamondBlock},[m.GoldBlock]:{name:m.GoldBlock},[m.IronBlock]:{name:m.IronBlock},[m.Mycelium]:{name:m.Mycelium},[m.TallFern]:{name:m.TallFern},[m.TallGrass]:{name:m.TallGrass},[m.TallRose]:{name:m.TallRose},[m.PaeoniaFlower]:{name:m.PaeoniaFlower},[m.SyringaFlower]:{name:m.SyringaFlower},[m.BlueOrchidFlower]:{name:m.BlueOrchidFlower},[m.DandelionFlower]:{name:m.DandelionFlower},[m.OxeyeDaisyFlower]:{name:m.OxeyeDaisyFlower},[m.TulipFlower]:{name:m.TulipFlower},[m.WaterlilyFlower]:{name:m.WaterlilyFlower},[m.Vine]:{name:m.Vine},[m.Fern]:{name:m.Fern},[m.Reeds]:{name:m.Reeds},[m.Cactus]:{name:m.Cactus},[m.Kelp]:{name:m.Kelp},[m.BrainCoral]:{name:m.BrainCoral},[m.BrainCoralBlock]:{name:m.BrainCoralBlock},[m.BubbleCoral]:{name:m.BubbleCoral},[m.BubbleCoralBlock]:{name:m.BubbleCoralBlock},[m.DeadBrainCoralBlock]:{name:m.DeadBrainCoralBlock},[m.DeadBubbleCoralBlock]:{name:m.DeadBubbleCoralBlock},[m.DeadFireCoral]:{name:m.DeadFireCoral},[m.DeadFireCoralBlock]:{name:m.DeadFireCoralBlock},[m.DeadHornCoral]:{name:m.DeadHornCoral},[m.DeadHornCoralBlock]:{name:m.DeadHornCoralBlock},[m.DeadTubeCoral]:{name:m.DeadTubeCoral},[m.DeadTubeCoralBlock]:{name:m.DeadTubeCoralBlock},[m.DeadBrainCoral]:{name:m.DeadBrainCoral},[m.DeadBubbleCoral]:{name:m.DeadBubbleCoral},[m.FireCoral]:{name:m.FireCoral},[m.FireCoralBlock]:{name:m.FireCoralBlock},[m.HornCoral]:{name:m.HornCoral},[m.HornCoralBlock]:{name:m.HornCoralBlock},[m.TubeCoral]:{name:m.TubeCoral},[m.TubeCoralBlock]:{name:m.TubeCoralBlock},[m.DarkOakLeaves]:{name:m.DarkOakLeaves},[m.DarkOakLog]:{name:m.DarkOakLog},[m.DarkOakPlanks]:{name:m.DarkOakPlanks},[m.AcaciaLeaves]:{name:m.AcaciaLeaves},[m.AcaciaLog]:{name:m.AcaciaLog},[m.AcaciaPlanks]:{name:m.AcaciaPlanks},[m.BirchLeaves]:{name:m.BirchLeaves},[m.BirchLog]:{name:m.BirchLog},[m.BirchPlanks]:{name:m.BirchPlanks},[m.DarkPrismarine]:{name:m.DarkPrismarine},[m.Prismarine]:{name:m.Prismarine},[m.PrismarineBricks]:{name:m.PrismarineBricks},[m.Bedrock]:{name:m.Bedrock},[m.Obsidian]:{name:m.Obsidian}};var y=s(62312);new Map;const x=new Map,v=new Map,b=new Map,w=new Map;function A(e,t,s){return`${e}-${t}-${s}`}class B{nodes;data;biomeTypes=new Map;constructor(e,t){this.nodes=e,this.data=t}init(){for(const[e,t]of this.data.biomeTypes){const s=new(c.getBiomeType(e))(this.nodes,this,t);this.biomeTypes.set(e,s),s.init()}}isInRange(e,t){return t.temperature[0]<=e[0]&&t.temperature[1]>=e[0]&&t.moisture[0]<=e[1]&&t.moisture[1]>=e[1]&&t.elevation[0]<=e[2]&&t.elevation[1]>=e[2]}getBiomeTypeInRange(e){let t=0,s=null,r=0,i=0;for(const[a,o]of this.data.biomeTypes){let n=h(e,o);if(n>i&&o.river[1]<=0&&o.excludeRiver&&(i=n),n>t){if(o.river[1]>=0&&r>0&&t==i){n=0;continue}t=n,s=this.biomeTypes.get(a),r=o.excludeRiver?100:r}}return s||this.biomeTypes.get("grass-land")}getBiomeTypeFromValue(e){let t=this.getBiomeTypeInRange(e);const s=t.getData();if(!s.edgeBiomeTypes.length||!s.edgeFactor)return t;{const r=[e[0]+s.edgeFactor[0],e[1]+s.edgeFactor[1],e[2]+s.edgeFactor[2],e[3]+s.edgeFactor[3]],i=this.getBiomeTypeInRange(r);if(i!=t){const s=this.getEdgeBiomeTypeFromValue(t,e);if(i.getData().edgeBiomeTypes.find((e=>e[0]==s.getData().id)))return s}}{const r=[e[0]-s.edgeFactor[0],e[1]-s.edgeFactor[1],e[2]-s.edgeFactor[2],e[3]-s.edgeFactor[3]],i=this.getBiomeTypeInRange(r);if(i!=t){const s=this.getEdgeBiomeTypeFromValue(t,e);if(i.getData().edgeBiomeTypes.find((e=>e[0]==s.getData().id)))return s}}return t}getBiomeFromValue(e,t){return this.getBiomeTypeFromValue(e).getBiomeFromValue(e,t)}getEdgeBiomeTypeFromValue(e,t){for(const[s,r]of e.getData().edgeBiomeTypes)if(this.isInRange(t,r))return this.biomeTypes.get(s);throw new Error("No biome type")}_clearTimeOut;getRiverNoise(e,t,s){let r=this.nodes.noise.biomeTypeRiverNoise(e/1600,1.2*s/1600),i=.05*this.nodes.noise.biomeDetailNoise(e/50,10,s/50)+.1;return r>-i&&r<i?(r+i)/(2*i):0}getElavation(e,t,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(e/100,50,s/100);const a=this.nodes.noise.biomeTypeElevationNoise((e-r)/1024,(s+r)/1024);let o=a+i;return(o>1||o<-1)&&(i=-i,o=a+i),Math.max(-1,Math.min(1,o))}getTempature(e,t,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(e/100,5880,s/100);const a=this.nodes.noise.biomeTypeTemperatureNoise((e-r)/4096,(s-r)/4096);let o=a+i;return(o>1||o<-1)&&(i=-i,o=a+i),Math.max(-1,Math.min(1,o))}getMostiure(e,t,s){const r=2**32;let i=.1*this.nodes.noise.biomeDetailNoise(e/100,10980,s/100);const a=this.nodes.noise.biomeTypeMoistureNoise((e-r)/1024,(s-r)/1024);let o=a+i;return(o>1||o<-1)&&(i=-i,o=a+i),Math.max(-1,Math.min(1,o))}getBiomeTypeValue(e,t,s){const r=this.getMostiure(e,t,s);return[this.getElavation(e,t,s),r,this.getTempature(e,t,s),this.getRiverNoise(e,t,s)]}clearCache(){w.clear(),x.clear(),v.clear(),b.clear()}getBiomeType(e,t,s){const r=A(e,t,s);let i=w.get(r);if(i)return i;let a=this.getBiomeTypeValue(e,t,s);return i=this.getBiomeTypeFromValue(a),w.set(r,i),i}getBiome(e,t,s){const r=A(e,t,s);let i=x.get(r);return i||(i=this.getBiomeType(e,t,s).getBiome(e,t,s),x.set(r,i),i)}getHeight(e,t,s){const r=A(e,t,s);let i=b.get(r);return i||(i=Math.max(this.getBiome(e,t,s).getHeight(e,t,s),1),b.set(r,i),i)}getBlendedHeight(e,t,s){const r=A(e,t,s);let i=v.get(r);return i||(i=Math.max(this.getBiome(e,t,s).getBlendedHeight(e,t,s),1),v.set(r,i),i)}generateWorldColumn(e,t){const{brush:s}=this.nodes,r=s.dataCursor;for(let i=e;i<this.nodes.chunkWidth+e;i++)for(let e=t;e<this.nodes.chunkDepth+t;e++){const t=this.getBiome(i,0,e),a=this.getBlendedHeight(i,0,e);if(a>y.k.world.bounds.MaxY-20)continue;for(let r=0;r<=a;r++){if(0==r){s.setName(m.Bedrock).setXYZ(i,r,e).paint();continue}if(t.getCarved(i,r,e))continue;const a=t.getGenVoxel(i,r,e);a&&s.setData(a).setXYZ(i,r,e).paint()}let o=!1,n=!1;for(let s=a+10;s>=0&&(o||(r.getVoxel(i,s,e)?.isRenderable()||1==s)&&(o=!0,t.fill(i,s+1,e)),n||t.addTopLayer(i,s,e)&&(n=!0),!o||!n);s--);}}decorateWorldColumn(e,t){const{brush:s}=this.nodes;for(let s=e;s<this.nodes.chunkWidth+e;s++)for(let e=t;e<this.nodes.chunkDepth+t;e++){const t=this.getBiome(s,0,e),r=this.getBlendedHeight(s,0,e);for(let i=1;i<=r;i++)t.decorate(s,i,e)}}wormCanver;generateBiomeTypeImage([e,t,s],[r,i,a]){this.wormCanver=new f(this.nodes);const o=new Uint8ClampedArray(4194304);console.log("Start");for(let t=s;t<=a;t++)for(let i=e;i<=r;i++){const r=4*(1024*(t-s)+(i-e));try{const[e,s,a]=this.getBiome(i,0,t).getData().color;o[r]=e,o[r+1]=s,o[r+2]=a,o[r+3]=255}catch(e){o[r]=255,o[r+3]=255}}return console.log("done",o),o}}class I{nodes;dimesnion;range;biomes=new Map;isRiver;constructor(e,t,s){this.nodes=e,this.dimesnion=t,this.range=s}getBiomeFromValue(e,t){e[4]=t;let s=0,r=null,i=null;for(const[t,a]of this.getData().biomes){let o=h(e,a);o>s&&(s=o,i=a,r=this.biomes.get(t))}if(!r||!i)return this.biomes.get(this.biomes.keys().next().value);const a=r.getData();if(!a.edgeBiomes.length||!a.edgeFactor)return r;{const s=[e[0]-(Array.isArray(a.edgeFactor[0])?a.edgeFactor[0][0]:a.edgeFactor[0]),e[1]-(Array.isArray(a.edgeFactor[1])?a.edgeFactor[1][0]:a.edgeFactor[1]),e[2]-(Array.isArray(a.edgeFactor[2])?a.edgeFactor[2][0]:a.edgeFactor[2]),e[3]-(Array.isArray(a.edgeFactor[3])?a.edgeFactor[3][0]:a.edgeFactor[3])],o=this.dimesnion.getBiomeTypeFromValue(s);if((i.excludeRiver||this.range.excludeRiver)&&o.isRiver)return r;if(o!=this)return this.getEdgeBiomeFromValue(e,r,t)}{const s=[e[0]+(Array.isArray(a.edgeFactor[0])?a.edgeFactor[0][1]:a.edgeFactor[0]),e[1]+(Array.isArray(a.edgeFactor[1])?a.edgeFactor[1][1]:a.edgeFactor[1]),e[2]+(Array.isArray(a.edgeFactor[2])?a.edgeFactor[2][1]:a.edgeFactor[2]),e[3]+(Array.isArray(a.edgeFactor[3])?a.edgeFactor[3][1]:a.edgeFactor[3])],o=this.dimesnion.getBiomeTypeFromValue(s);if((i.excludeRiver||this.range.excludeRiver)&&o.isRiver)return r;if(o!=this)return this.getEdgeBiomeFromValue(e,r,t)}return r}getEdgeBiomeFromValue(e,t,s){e[4]=s;let r=0,i=null,a=null;for(const[s,o]of t.getData().edgeBiomes){let t=h(e,o);t>r&&(r=t,a=o,i=this.biomes.get(s))}return i&&a?i:this.biomes.get(this.biomes.keys().next().value)}getBiomeValue(e,t,s){return this.nodes.noise.biomeNoise(e/120,0,s/120)}getBiome(e,t,s){const r=this.getBiomeValue(e,t,s),i=this.dimesnion.getBiomeTypeValue(e,t,s);return this.getBiomeFromValue(i,r)}init(){for(const[e]of this.getData().biomes){const t=c.getBiome(e);if(this.biomes.set(e,new t(this.nodes,this)),t.data.edgeBiomes.length)for(const[e]of t.data.edgeBiomes){const t=c.getBiome(e);this.biomes.set(e,new t(this.nodes,this))}}}}class S{nodes;biomeType;isRiver;constructor(e,t){this.nodes=e,this.biomeType=t}findHeightInDirection(e,t,s,r,i,a){let o=e,n=1;for(let e=1;e<=a;e++){const a=t+e*r,l=s+e*i,d=this.biomeType.dimesnion.getBiome(a,0,l);d!==this&&(o+=d.getHeight(a,0,l),n++)}return o/n}getBlendedHeight(e,t,s){const r=this.getData();if(r.heightBlendFactor<=0)return this.getHeight(e,t,s);const i=32*r.heightBlendFactor;let a=Math.round(this.getHeight(e,t,s)),o=a,n=1;o+=this.findHeightInDirection(a,e,s,0,1,i),o+=this.findHeightInDirection(a,e,s,0,-1,i),o+=this.findHeightInDirection(a,e,s,1,0,i),o+=this.findHeightInDirection(a,e,s,-1,0,i),n+=4,o+=this.findHeightInDirection(a,e,s,1,1,i),o+=this.findHeightInDirection(a,e,s,1,-1,i),o+=this.findHeightInDirection(a,e,s,-1,1,i),o+=this.findHeightInDirection(a,e,s,-1,-1,i),n+=4;const l=Math.round(o/9),d=this.getData().minHeight;return void 0!==d&&l<d?d:l}}class C{data;currentState;rules;angle=25;constructor(e){this.data=e}setRules(e,t,s=this.angle){this.currentState=e,this.rules=t,this.angle=s}setAngle(e){this.angle=e}generateRandomRules(){const e=["F[+F]F[-F]FE","F[&F]F[^F]FE","F[&+F]F[^-F]FE","F[-F][+F]FE","F[&-F][^+F]FE"],t=["FF","FFF","F-F"],s=2+Math.floor(2*Math.random());this.rules=[];for(let r=0;r<s;r++){const s=Math.random()<.5?e.map((e=>e.replace(/F/g,t[Math.floor(Math.random()*t.length)]+(Math.random()>.9?"E":"")))):t.map((e=>e+(Math.random()>.9?"E":"")));this.rules.push({symbol:"F",replacements:s})}return this.rules.push({symbol:"X",replacements:["F[-F][+F]F[&F]^FE","F&[X-FX]+FE","F^F[X]+F-FE"].slice(0,1+Math.floor(2*Math.random()))}),this.currentState="X",this.setRules("X",this.rules,this.angle),this}generateState(e){if(!this.rules.length)throw new Error("Rules not set. Please set rules before generating L-system.");for(let t=0;t<e;t++){let e="";for(const t of this.currentState){let s=!1;for(const r of this.rules)if(t===r.symbol){e+=r.replacements[Math.floor(Math.random()*r.replacements.length)],s=!0;break}s||(e+=t)}this.currentState=e}return this.currentState}interpret(e,t={x:0,y:0,z:0},s={x:0,y:1,z:0}){let r=[],i=t,a=s;for(const t of e)switch(t){case"F":i.x+=a.x,i.y+=a.y,i.z+=a.z,this.placeVoxel(i.x,i.y,i.z);break;case"E":this.placeEnd(i.x,i.y,i.z);case"+":a=this.rotate(a,this.angle,"z");break;case"-":a=this.rotate(a,-this.angle,"z");break;case"&":a=this.rotate(a,this.angle,"x");break;case"^":a=this.rotate(a,-this.angle,"x");break;case"[":r.push({position:{...i},direction:{...a}});break;case"]":const e=r.pop();i=e.position,a=e.direction}}rotate(e,t,s){const r=t*Math.PI/180;let i=e.x,a=e.y,o=e.z;switch(s){case"x":a=e.y*Math.cos(r)-e.z*Math.sin(r),o=e.y*Math.sin(r)+e.z*Math.cos(r);break;case"y":i=e.x*Math.cos(r)-e.z*Math.sin(r),o=e.x*Math.sin(r)+e.z*Math.cos(r);break;case"z":i=e.x*Math.cos(r)-e.y*Math.sin(r),a=e.x*Math.sin(r)+e.y*Math.cos(r)}return{x:i,y:a,z:o}}placeEnd(e,t,s){this.data.placeEnd(Math.round(e),Math.round(t),Math.round(s))}placeVoxel(e,t,s){this.data.placeVoxel(Math.round(e),Math.round(t),Math.round(s))}}var T=s(99673);function _(e,t,s,r,i,a,o=!1,n=!0){let l=s-a,d=i-a;e.setName(t);const h=e.dataCursor;for(let t=l;t<=s+a;t++)for(let l=d;l<=i+a;l++)if(!o||t!=s||l!=i){if(n){const e=h.getVoxel(t,r,l);if(e){if(e.isAir()&&1==e.getLevelState())continue;if(e.isRenderable())continue}}(0,T.me)(t,s,l,i)<=a&&e.setXYZ(t,r,l).paint()}}function z(e,t,s,r,i,a,o=-1,n=!0){let l=Math.floor(s-a),d=Math.floor(r-a),h=Math.floor(i-a);e.setName(t);const c=e.dataCursor;for(let t=l;t<=s+a;t++)for(let l=h;l<=i+a;l++)for(let h=d;h<=r+a;h++){if(o>-1&&Math.random()<o)continue;const d=c.getVoxel(t,h,l);if(n&&d){if(d.isAir()&&1==d.getLevelState())continue;if(d.isRenderable())continue}(0,T.D7)(t,h,l,s,r,i)<=a&&e.setXYZ(t,h,l).paint()}}class V{static oakLSystem=new C({placeVoxel(e,t,s){V.nodes.brush.setXYZ(e,t,s).setName(m.OakLog).paint()},placeEnd(e,t,s){z(V.nodes.brush,m.OakLeaves,e,t,s,Math.max(5*Math.random(),4),.01)}});static birchSystem=new C({placeVoxel(e,t,s){V.nodes.brush.setXYZ(e,t,s).setName(m.BirchLog).paint()},placeEnd(e,t,s){z(V.nodes.brush,m.BirchLeaves,e,t,s,Math.max(5*Math.random(),4),.01)}});static acaciSystem=new C({placeVoxel(e,t,s){V.nodes.brush.setXYZ(e,t,s).setName(m.AcaciaLog).paint()},placeEnd(e,t,s){z(V.nodes.brush,m.AcaciaLeaves,e,t,s,Math.max(5*Math.random(),4),.01)}});static darkOakSystem=new C({placeVoxel(e,t,s){V.nodes.brush.setXYZ(e,t,s).setName(m.DarkOakLog).paint()},placeEnd(e,t,s){z(V.nodes.brush,m.DarkOakLeaves,e,t,s,Math.max(5*Math.random(),4),.01)}});static nodes;static init(e){this.nodes=e}static generateOakTree(e,t,s){this.oakLSystem.generateRandomRules();const r=this.oakLSystem.generateState(2);this.oakLSystem.interpret(r,{x:e,y:t-1,z:s})}static generateDarkOakTree(e,t,s){this.darkOakSystem.generateRandomRules();const r=this.darkOakSystem.generateState(2);this.darkOakSystem.interpret(r,{x:e,y:t-1,z:s})}static generateAcaciaTree(e,t,s){this.acaciSystem.generateRandomRules();const r=this.acaciSystem.generateState(2);this.acaciSystem.interpret(r,{x:e,y:t-1,z:s})}static generateBirchTree(e,t,s){this.birchSystem.generateRandomRules();const r=this.birchSystem.generateState(2);this.birchSystem.interpret(r,{x:e,y:t-1,z:s})}static generateSpruceTree(e,t,s){const{brush:r}=this.nodes;r.setName(m.SpruceLog).setXYZ(e,t,s).paint();let i=Math.floor(30*Math.random()+10);r.setName(m.SpruceLeaves).setXYZ(e,i+t+1,s).paint(),r.setXYZ(e+1,i+t+1,s).paint(),r.setXYZ(e,i+t+1,s+1).paint(),r.setXYZ(e+1,i+t+1,s+1).paint();let a=4,o=i,n=o/4;for(;o>n&&a<10;)_(r,m.SpruceLeaves,e,t+o,s,a),o-=3,a++;for(let a=t;a<=t+i;a++)r.setName(m.SpruceLog).setXYZ(e,a,s).paint(),r.setXYZ(e+1,a,s).paint(),r.setXYZ(e,a,s+1).paint(),r.setXYZ(e+1,a,s+1).paint()}}const D={getIndex(e,t=Math.random()){if(e.length<=1)return 0;const s=[];let r=0;for(const[t,i]of e)r+=i,s.push(r);const i=t*r|0;let a=0;for(const e of s){if(i<=e)break;a++}return a},getValue(e,t=Math.random()){return e[this.getIndex(e,t)][0]}},M=[[m.TulipFlower,10],[m.PaeoniaFlower,10],[m.SyringaFlower,10],[m.DandelionFlower,10],[m.BlueOrchidFlower,10],[m.OxeyeDaisyFlower,10],[m.WaterlilyFlower,10]],k=[[m.Fern,10],[m.Grass,10],[m.TallGrass,10],[m.TallFern,10]],N=[[m.DeadFireCoral,10],[m.DeadHornCoral,10],[m.DeadTubeCoral,10],[m.DeadBrainCoral,10],[m.DeadBubbleCoral,10]],L=[[m.FireCoral,10],[m.HornCoral,10],[m.TubeCoral,10],[m.BrainCoral,10],[m.BubbleCoral,10]],R=[[m.SeaGrass,10]];class F{static generateCactus(e,t,s,r){const{brush:i}=e;let a=Math.floor(5*Math.random()+2);for(let e=s;e<=s+a;e++)i.setName(m.Cactus).setXYZ(t,e,r).paint()}static generateReed(e,t,s,r){const{brush:i}=e;let a=Math.floor(5*Math.random()+2);for(let e=s;e<=s+a;e++)i.setName(m.Reeds).setXYZ(t,e,r).paint()}static generateKelp(e,t,s,r){const{brush:i}=e;let a=Math.floor(15*Math.random()+5),o=Math.floor(5*Math.random());for(let n=s;n<=s+a&&n<e.waterHeight-o;n++)i.setName(m.Water).setLevel(7).setSecondaryName(m.Kelp).setXYZ(t,n,r).paint();i.setLevel(0),i.setSecondaryName("")}static generateWaterPlant(e,t,s,r){const{brush:i}=e,a=D.getValue(R);i.setName(m.Water).setLevel(7).setSecondaryName(a).setXYZ(t,s,r).paint(),i.setLevel(0),i.setSecondaryName("")}static generateRandomFlower(e,t,s,r){const{brush:i}=e,a=D.getValue(M);i.setName(a).setXYZ(t,s,r).paint()}static generateRandomPlant(e,t,s,r){const{brush:i}=e,a=D.getValue(k);i.setName(a).setXYZ(t,s,r).paint()}static generateRandomDeadCoral(e,t,s,r){const{brush:i}=e,a=D.getValue(N);i.setName(a).setXYZ(t,s,r).paint()}static generateRandomCoral(e,t,s,r){const{brush:i}=e,a=D.getValue(L);i.setName(m.Water).setLevel(7).setSecondaryName(a).setXYZ(t,s,r).paint(),i.setLevel(0),i.setSecondaryName("")}}const U=2**32;class P extends u{static data={id:"standard"};getCarved(e,t,s){const r=this.nodes.noise.worldGenNoise(e/50,t/50,s/50),i=(1+this.nodes.noise.detailNoise((e-U)/100,t/100,(s-U)/100))/2;return i<.4+(.6-.4)*r-.9*i&&t<(.2+(.8-.2)*r+.9*i)*this.nodes.worldHeight}getData(){return P.data}getClass(){return P}}const E=2**32;class H extends u{static data={id:"worm"};getCarved(e,t,s){for(let r=0;r<4;r++){let i=150/(r%3);e+=2e4*r,s-=2e4*r;let a=this.nodes.noise.detailNoise(e/200,25e4*r,s/200);if(this.nodes.noise.worldDetailNoise(e/600,25e4*r,s/600)<.5)continue;let o=(1+this.nodes.noise.worldDetailNoise((e-E)/i,5e4,(s-E)/i))/2*60+5,n=(1+this.nodes.noise.worldDetailNoise((e-E)/150,25e4,(s-E)/150))/2*10+5,l=(1+this.nodes.noise.worldDetailNoise((e-E)/30,(t+200)/30,(s-E)/30))/2;if(a>-.03-.02*l&&a<.03+.02*l&&t<=o+(n+20*l)/2&&t>=o-(n+20*l)/2)return!0}return!1}getData(){return H.data}getClass(){return H}}class G{static standard;static worm;static valley;static init(e){this.standard=new P(e),this.worm=new H(e),this.valley=new f(e)}static getCarved(e,t,s){const r=this.standard.getCarved(e,t,s),i=this.worm.getCarved(e,t,s);return r||i}}const[O,Q]=[1e3,1e4];class Y extends S{static data={id:"tundra",heightBlendFactor:1,color:[3,171,121],edgeBiomes:[]};getGenVoxel(e,t,s){return!(t>40*this.noiseQuery(e,t,s)+this.nodes.minHeight)&&p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+O)/100,t/100,(s+Q)/100))/2}getHeight(e,t,s){return 40*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint(),r.setData(p[m.Snow]).setXYZ(e,t+1,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();r>.999&&V.generateOakTree(e,t+1,s),r>.88&&r<.89&&F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Y}}const[X,Z]=[1e3,1e4];class W extends S{static data={id:"frozen-waste",heightBlendFactor:1,color:[255,255,255],edgeBiomes:[]};getGenVoxel(e,t,s){return!(t>40*this.noiseQuery(e,t,s)+this.nodes.minHeight)&&p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+X)/100,t/100,(s+Z)/100))/2}getHeight(e,t,s){return 40*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Gravel]).setXYZ(e,t,s).paint(),r.setData(p[m.Snow]).setXYZ(e,t+1,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){}getData(){return this.getClass().data}getClass(){return W}}class q extends I{static data={id:"artic",color:[255,255,255],biomes:[[Y.data.id,o([-.8,-.5])],[W.data.id,o([-1,-.8])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return q}}const[j,$]=[1e3,1e4];class K extends S{static data={id:"desert",heightBlendFactor:1,color:[166,132,40],edgeBiomes:[]};getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+j)/480,t/480,(s+$)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Sand]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Sand]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.Sand){const r=Math.random();if(r>.999)return void V.generateOakTree(e,t+1,s);if(r>.88&&r<.89)return void F.generateCactus(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return K}}class J{static brainCoralSystem=new C({placeVoxel(e,t,s){t>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(e,t,s).setName(m.BrainCoralBlock).paint()},placeEnd(e,t,s){}});static fireCoralSystem=new C({placeVoxel(e,t,s){t>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(e,t,s).setName(m.FireCoralBlock).paint()},placeEnd(e,t,s){}});static bubbleCoralSystem=new C({placeVoxel(e,t,s){t>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(e,t,s).setName(m.BubbleCoralBlock).paint()},placeEnd(e,t,s){}});static hornCoralSystem=new C({placeVoxel(e,t,s){t>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(e,t,s).setName(m.HornCoralBlock).paint()},placeEnd(e,t,s){}});static tubeCoralSystem=new C({placeVoxel(e,t,s){t>J.nodes.waterHeight-1||J.nodes.brush.setXYZ(e,t,s).setName(m.TubeCoralBlock).paint()},placeEnd(e,t,s){}});static nodes;static init(e){this.nodes=e}static generateBrainCoral(e,t,s){this.brainCoralSystem.generateRandomRules();const r=this.brainCoralSystem.generateState(2);this.brainCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateFireCoral(e,t,s){this.fireCoralSystem.generateRandomRules();const r=this.fireCoralSystem.generateState(2);this.fireCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateBubbleCoral(e,t,s){this.bubbleCoralSystem.generateRandomRules();const r=this.bubbleCoralSystem.generateState(2);this.bubbleCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateHornCoral(e,t,s){this.hornCoralSystem.generateRandomRules();const r=this.hornCoralSystem.generateState(2);this.hornCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateTubeCoral(e,t,s){this.tubeCoralSystem.generateRandomRules();const r=this.tubeCoralSystem.generateState(2);this.tubeCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static deadBrainCoralSystem=new C({placeVoxel(e,t,s){J.nodes.brush.setXYZ(e,t,s).setName(m.DeadBrainCoralBlock).paint()},placeEnd(e,t,s){}});static deadBubbleCoralSystem=new C({placeVoxel(e,t,s){J.nodes.brush.setXYZ(e,t,s).setName(m.DeadBubbleCoralBlock).paint()},placeEnd(e,t,s){}});static deadFireCoralSystem=new C({placeVoxel(e,t,s){J.nodes.brush.setXYZ(e,t,s).setName(m.DeadFireCoralBlock).paint()},placeEnd(e,t,s){}});static deadHornCoralSystem=new C({placeVoxel(e,t,s){J.nodes.brush.setXYZ(e,t,s).setName(m.DeadHornCoralBlock).paint()},placeEnd(e,t,s){}});static deadTubeCoralSystem=new C({placeVoxel(e,t,s){J.nodes.brush.setXYZ(e,t,s).setName(m.DeadTubeCoralBlock).paint()},placeEnd(e,t,s){}});static generateDeadBrainCoral(e,t,s){this.deadBrainCoralSystem.generateRandomRules();const r=this.deadBrainCoralSystem.generateState(2);this.deadBrainCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateDeadBubbleCoral(e,t,s){this.deadBubbleCoralSystem.generateRandomRules();const r=this.deadBubbleCoralSystem.generateState(2);this.deadBubbleCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateDeadFireCoral(e,t,s){this.deadFireCoralSystem.generateRandomRules();const r=this.deadFireCoralSystem.generateState(2);this.deadFireCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateDeadHornCoral(e,t,s){this.deadHornCoralSystem.generateRandomRules();const r=this.deadHornCoralSystem.generateState(2);this.deadHornCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static generateDeadTubeCoral(e,t,s){this.deadTubeCoralSystem.generateRandomRules();const r=this.deadTubeCoralSystem.generateState(2);this.deadTubeCoralSystem.interpret(r,{x:e,y:t-1,z:s})}static runRandomGenerator(e){return e[Math.floor(Math.random()*e.length)]}static liveGens=[this.generateBrainCoral,this.generateBubbleCoral,this.generateFireCoral,this.generateHornCoral,this.generateTubeCoral];static generateRandomCoral(e,t,s){this.runRandomGenerator(this.liveGens).call(this,e,t,s)}static deadGens=[this.generateDeadBrainCoral,this.generateDeadBubbleCoral,this.generateDeadFireCoral,this.generateDeadHornCoral,this.generateDeadTubeCoral];static generateRandomDeadCoral(e,t,s){this.runRandomGenerator(this.deadGens).call(this,e,t,s)}}const[ee,te]=[1e3,1e4];class se extends S{static data={id:"dea-sea",heightBlendFactor:1,color:[153,131,70],edgeBiomes:[]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+ee)/480,t/480,(s+te)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Sand]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Sand]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.Sand){const r=Math.random();if(r>.87&&r<.89)return void J.generateRandomDeadCoral(e,t+1,s);if(r>.85&&r<.87)return void F.generateRandomDeadCoral(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return se}}class re extends I{static data={id:"desert",color:[166,132,40],biomes:[[K.data.id,o([-1,1],[-1,1],[.3,.7],[-1,1])],[se.data.id,o([-1,1],[-1,1],[0,.2],[-1,1])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return re}}const[ie,ae]=[1e3,1e4];class oe extends S{static data={id:"oak-forest",heightBlendFactor:1,color:[42,102,49],edgeBiomes:[]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+ie)/480,t/480,(s+ae)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.97)return void V.generateOakTree(e,t+1,s);if(r>.85&&r<.89)return void F.generateRandomFlower(this.nodes,e,t+1,s);if(r>0&&r<.1)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return oe}}const[ne,le]=[1e3,1e4];class de extends S{static data={id:"spruce-forest",heightBlendFactor:1,color:[32,56,35],edgeBiomes:[]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+ne)/480,t/480,(s+le)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}getFillVoxel(e,t,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(e/200,t/200,s/200))/2;return i>.4&&i<1?m.Podzol:i>.3&&i<.4?r?m.GrassBlock:m.Dirt:m.Gravel}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[this.getFillVoxel(e,t,s,!0)]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[this.getFillVoxel(e,t,s)]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&(a==m.Podzol||a==m.GrassBlock)){const r=Math.random();if(r>.99)return void V.generateSpruceTree(e,t+1,s);if(r>.88&&r<.89)return void F.generateRandomFlower(this.nodes,e,t+1,s);if(r>0&&r<.05)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return de}}const[he,ce]=[1e3,1e4];class ue extends S{static data={id:"dark-oak-forest",heightBlendFactor:1,color:[1,66,8],edgeBiomes:[]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+he)/480,t/480,(s+ce)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.97)return void V.generateDarkOakTree(e,t+1,s);if(r>.85&&r<.89)return void F.generateRandomFlower(this.nodes,e,t+1,s);if(r>0&&r<.1)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return ue}}class ge extends S{static data={id:"birch-forest",heightBlendFactor:1,color:[95,204,61],edgeBiomes:[]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){const[r,i]=[1e3,1e4];return(1+this.nodes.noise.worldGenNoise((e+r)/480,t/480,(s+i)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.97)return void V.generateBirchTree(e,t+1,s);if(r>.85&&r<.89)return void F.generateRandomFlower(this.nodes,e,t+1,s);if(r>0&&r<.1)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return ge}}class fe extends I{static data={id:"forest",color:[19,77,17],biomes:[[oe.data.id,o([-.2,.3],[-.2,-.01],[.1,.8])],[de.data.id,o([-.8,-.1],[-.4,-.2],[.2,.8])],[ue.data.id,o([-.2,.3],[-.4,-.3],[.2,.5])],[ge.data.id,o([-.3,.4],[-.3,-.1],[.4,.8])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return fe}}const[me,pe]=[1e3,1e4];class ye extends S{static data={id:"prairie",heightBlendFactor:1,color:[117,255,112],edgeBiomes:[]};caveCarver=new P(this.nodes);getCoreVoxel(e,t,s){const r=(1+this.nodes.noise.worldGenNoise(e/200,t/200,s/200))/2;return r>=.8?m.Granite:r>=.7&&r<.8?m.Andesite:m.Stone}getGenVoxel(e,t,s){return p[this.getCoreVoxel(e,t,s)]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+me)/480,t/480,(s+pe)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone||o==m.Andesite||o==m.Granite){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.99)return void V.generateOakTree(e,t+1,s);if(r>.9&&r<.92)return void F.generateRandomFlower(this.nodes,e,t+1,s);if(r>0&&r<.1)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return ye}}const[xe,ve]=[1e3,1e4];class be extends S{static data={id:"savannah",heightBlendFactor:1,color:[188,255,112],edgeBiomes:[]};caveCarver=new P(this.nodes);getCoreVoxel(e,t,s){const r=(1+this.nodes.noise.worldGenNoise(e/200,t/200,s/200))/2;return r>=.8?m.Granite:r>=.7&&r<.8?m.Andesite:m.Stone}getGenVoxel(e,t,s){return p[this.getCoreVoxel(e,t,s)]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+xe)/480,t/480,(s+ve)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone||o==m.Andesite||o==m.Granite){r.setData(p[m.GrassBlock]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.99)return void V.generateAcaciaTree(e,t+1,s);if(r>0&&r<.01)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return be}}class we extends I{static data={id:"grass-land",color:[117,255,112],biomes:[[ye.data.id,o([.1,.3],[-.5,-.3])],[be.data.id,o([.3,.4],[-.3,-.1])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return we}}const[Ae,Be]=[1e3,1e4];class Ie extends S{static data={id:"rocky-mountain",heightBlendFactor:.2,color:[129,142,143],edgeBiomes:[]};caveCarver=new P(this.nodes);getCoreVoxel(e,t,s){const r=(1+this.nodes.noise.worldGenNoise(e/40,t/40,s/40))/2;return r>.6&&r<.7?m.Gravel:m.Stone}getGenVoxel(e,t,s){return p[this.getCoreVoxel(e,t,s)]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+Ae)/30,t/30,(s+Be)/30))/2}getHeight(e,t,s){return 200*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){if(t<150)return!0;const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Snow]).setXYZ(e,t,s).paint(),r.setData(p[m.Snow]).setXYZ(e,t+1,s).paint();let i=5;for(;i--;)r.setData(p[m.Snow]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){}getData(){return this.getClass().data}getClass(){return Ie}}const[Se,Ce]=[1e3,1e4];class Te extends S{static data={id:"high-gravel-hills",heightBlendFactor:1,color:[90,99,99],edgeBiomes:[]};caveCarver=new P(this.nodes);getCoreVoxel(e,t,s){const r=(1+this.nodes.noise.worldGenNoise(e/40,t/40,s/40))/2;return r>.2&&r<.8?m.Gravel:m.Stone}getGenVoxel(e,t,s){return p[this.getCoreVoxel(e,t,s)]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.getHeight(e,t,s)}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+Se)/100,t/100,(s+Ce)/100))/2}getHeight(e,t,s){return 80*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){if(t<150)return!0;const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Snow]).setXYZ(e,t,s).paint(),r.setData(p[m.Snow]).setXYZ(e,t+1,s).paint();let i=5;for(;i--;)r.setData(p[m.Snow]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){return!1}decorate(e,t,s){}getData(){return this.getClass().data}getClass(){return Te}}class _e extends I{static data={id:"mountain",color:[129,142,143],biomes:[[Ie.data.id,o(void 0,void 0,[.85,1])],[Te.data.id,o(void 0,void 0,[.7,.85])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return _e}}const[ze,Ve]=[1e3,1e4];class De extends S{static data={id:"beache",heightBlendFactor:.5,color:[252,252,3],edgeBiomes:[],minHeight:60};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+ze)/480,t/480,(s+Ve)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Sand]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Sand]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(;i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setName(m.Sand).setXYZ(e,i,s).paint(),i++}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.999)return void V.generateOakTree(e,t+1,s);if(r>.85&&r<.89)return void F.generateRandomPlant(this.nodes,e,t+1,s)}if(i&&a==m.Sand){const r=Math.random();if(r>.88&&r<.89)return void F.generateRandomPlant(this.nodes,e,t+1,s);if(r>2e-4&&r<.005)return void F.generateReed(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return De}}const[Me,ke]=[1e3,1e4];class Ne extends S{static data={id:"rocky-beach",heightBlendFactor:.5,color:[122,122,59],edgeBiomes:[],minHeight:60};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getFillVoxel(e,t,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(e/200,t/200,s/200))/2;return i>.4&&i<1?m.Gravel:i>.3&&i<.4?m.Sand:m.Andesite}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+Me)/480,t/480,(s+ke)/480))/2}getHeight(e,t,s){return 30*this.noiseQuery(e,0,s)+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[this.getFillVoxel(e,t,s)]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[this.getFillVoxel(e,t,s)]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(;i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setName(this.getFillVoxel(e,t,s)).setXYZ(e,i,s).paint(),i++}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.999)return void V.generateOakTree(e,t+1,s);if(r>.85&&r<.89)return void F.generateRandomPlant(this.nodes,e,t+1,s)}if(i&&a==m.Sand){const r=Math.random();if(r>.88&&r<.89)return void F.generateRandomPlant(this.nodes,e,t+1,s);if(r>2e-4&&r<.005)return void F.generateReed(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Ne}}const[Le,Re]=[1e3,1e4];class Fe extends S{static data={id:"icy-beach",heightBlendFactor:.5,color:[230,230,85],edgeBiomes:[],minHeight:60};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+Le)/480,0,(s+Re)/480))/2*5+this.nodes.minHeight}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setData(p[m.Sand]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Sand]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(;i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setName(m.Sand).setXYZ(e,i,s).paint(),i++}decorate(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();a&&o==m.Sand&&Math.random()<.95&&r.setName(m.Snow).setXYZ(e,t+1,s).paint()}getData(){return this.getClass().data}getClass(){return Fe}}const[Ue,Pe]=[1e3,1e4];class Ee extends S{static data={id:"shallow-ocean",heightBlendFactor:1,color:[0,119,128],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[De.data.id,o([0,1],void 0,[-1,.6])],[Ne.data.id,o(void 0,void 0,[.6,1])],[Fe.data.id,o([-1,-.5],void 0,[-1,.6])]]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((e+Ue)/480,0,(s+Pe)/480))/2*40}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(e,t,s)?.getName();if(o&&n==m.Stone){r.setData(p[m.Dirt]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(r.setName(m.Water).setLevel(7);i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setXYZ(e,i,s).paint(),i++;r.setLevel(0)}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s),a=i?.isAir()||i?.isRenderable()&&r.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,o=r.getVoxel(e,t,s)?.getName();if(a&&(o==m.Dirt||o==m.Sand)){const r=Math.random();if(r>.87&&r<.89)return void F.generateKelp(this.nodes,e,t+1,s);if(r>.98)return void F.generateWaterPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Ee}}const[He,Ge]=[1e3,1e4];class Oe extends S{static data={id:"tropical-ocean",heightBlendFactor:1,color:[10,231,247],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[De.data.id,o([0,1],void 0,[-1,.6])],[Ne.data.id,o(void 0,void 0,[.6,1])],[Fe.data.id,o([-1,-.5],void 0,[-1,.6])]]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((e+He)/480,0,(s+Ge)/480))/2*40}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(e,t,s)?.getName();if(o&&n==m.Stone){r.setData(p[m.Dirt]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(r.setName(m.Water).setLevel(7);i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setXYZ(e,i,s).paint(),i++;r.setLevel(0)}decorate(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(e,t,s)?.getName();if(o&&(n==m.Dirt||n==m.Sand)){const i=Math.random();if(i>.87&&i<.89)return void J.generateRandomCoral(e,t+1,s);if(i>.85&&i<.87)return void F.generateRandomCoral(this.nodes,e,t+1,s);if(i>.8&&i<.82)return void r.setName(m.SeaLantern).setXYZ(e,t+1,s).paint();if(i>.98)return void F.generateWaterPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Oe}}const[Qe,Ye]=[1e3,1e4];class Xe extends S{static data={id:"deep-ocean",heightBlendFactor:1,color:[2,83,89],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[De.data.id,o([0,1],void 0,[-1,.6])],[Ne.data.id,o(void 0,void 0,[.6,1])],[Fe.data.id,o([-1,-.5],void 0,[-1,.6])]]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((e+Qe)/480,0,(s+Ye)/480))/2*50}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(e,t,s)?.getName();if(o&&n==m.Stone){r.setData(p[m.Dirt]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(r.setName(m.Water).setLevel(7);i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setXYZ(e,i,s).paint(),i++;r.setLevel(0)}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s),a=i?.isAir()||i?.isRenderable()&&r.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,o=r.getVoxel(e,t,s)?.getName();if(a&&(o==m.Dirt||o==m.Sand)){const r=Math.random();if(r>.87&&r<.89)return void F.generateKelp(this.nodes,e,t+1,s);if(r>.98)return void F.generateWaterPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Xe}}const[Ze,We]=[1e3,1e4];class qe extends S{static data={id:"frozen-ocean",heightBlendFactor:1,color:[57,99,102],edgeFactor:[0,[.1,0],0,0],edgeBiomes:[[De.data.id,o([0,1])],[Ne.data.id,o(void 0,void 0,[.7,1])],[Fe.data.id,o([-1,-.5])]]};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return this.nodes.minHeight-(1+this.nodes.noise.worldGenNoise((e+Ze)/480,0,(s+We)/480))/2*40}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid||!1,n=i.getVoxel(e,t,s)?.getName();if(o&&n==m.Stone){r.setData(p[m.Dirt]).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setData(p[m.Dirt]).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;Math.random()>.8&&r.setName(m.Ice).setXYZ(e,this.nodes.waterHeight+1,s).paint(),r.setName(m.Ice).setXYZ(e,this.nodes.waterHeight,s).paint();let i=t;for(r.setName(m.Water).setLevel(7);i<=this.nodes.waterHeight-1;)t<this.nodes.waterHeight-1&&r.setXYZ(e,i,s).paint(),i++;r.setLevel(0)}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s),a=i?.isAir()||i?.isRenderable()&&r.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid||!1,o=r.getVoxel(e,t,s)?.getName();if(a&&(o==m.Dirt||o==m.Sand)){const r=Math.random();if(r>.87&&r<.89)return void F.generateKelp(this.nodes,e,t+1,s);if(r>.98)return void F.generateWaterPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return qe}}class je extends I{static data={id:"ocean",color:[2,83,89],biomes:[[Ee.data.id,o([-.2,.4],[0,1],[-.4,0])],[Oe.data.id,o([.8,1],[0,1],[-.1,0])],[Xe.data.id,o([-1,.4],[0,1],[-1,-.5])],[qe.data.id,o([-1,-.5],[0,1],[-.5,0])]],edgeBiomeTypes:[]};getData(){return this.getClass().data}getClass(){return je}}const[$e,Ke]=[1e3,1e4];class Je extends S{static data={id:"river-bank",heightBlendFactor:.25,color:[43,26,1],edgeBiomes:[],minHeight:60};caveCarver=new P(this.nodes);getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}noiseQuery(e,t,s){return(1+this.nodes.noise.worldGenNoise((e+$e)/120,t/120,(s+Ke)/120))/2}getHeight(e,t,s){return 5*this.noiseQuery(e,0,s)+(this.nodes.waterHeight+5)}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s)?.isAir()||!0,o=i.getVoxel(e,t,s)?.getName();if(a&&o==m.Stone){r.setName(this.getFillVoxel(e,t,s,!0)).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setName(this.getFillVoxel(e,t-1-i,s)).setXYZ(e,t-1-i,s).paint();return!0}return!1}getFillVoxel(e,t,s,r=!1){const i=(1+this.nodes.noise.worldGenNoise(e/20+10,t/20+100,s/20+10))/2;return i>.5&&i<1?m.Sand:i>.3&&i<.5?r?m.GrassBlock:m.Dirt:m.Gravel}fill(e,t,s){const r=this.nodes.brush,i=r.dataCursor;let a=t;for(;a<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&(i.getVoxel(e,t,s)?.isRenderable()||r.setName(this.getFillVoxel(e,a,s,a==this.nodes.waterHeight)).setXYZ(e,a,s).paint()),a++}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s)?.isAir()||!0,a=r.getVoxel(e,t,s)?.getName();if(i&&a==m.GrassBlock){const r=Math.random();if(r>.99)return void V.generateOakTree(e,t+1,s);if(r>.9&&r<.92)return void F.generateReed(this.nodes,e,t+1,s);if(r>0&&r<.1)return void F.generateRandomPlant(this.nodes,e,t+1,s)}}getData(){return this.getClass().data}getClass(){return Je}}const[et,tt]=[1e3,1e4];class st extends S{static data={id:"river",heightBlendFactor:.25,color:[3,206,252],edgeFactor:[0,0,0,[.1,.3]],edgeBiomes:[[Je.data.id,o()]]};caveCarver=new P(this.nodes);isRiver=!0;getGenVoxel(e,t,s){return p[m.Stone]}getCarved(e,t,s){return G.getCarved(e,t,s)}getBlendtoHeight(e,t,s){return this.nodes.waterHeight}getHeight(e,t,s){return this.nodes.waterHeight-5-(1+this.nodes.noise.worldGenNoise((e+et)/480,0,(s+tt)/480))/2*5}getLayerVoxel(e,t,s){const r=(1+this.nodes.noise.worldGenNoise(e/200,t/200,s/200))/2;return r>=.7?m.Gravel:r<.7&&r>.4?m.Dirt:r<=.4&&r>.2?m.Sand:m.Clay}addTopLayer(e,t,s){const r=this.nodes.brush,i=r.dataCursor,a=i.getVoxel(e,t+1,s),o=a?.isAir()||a?.isRenderable()&&i.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,n=i.getVoxel(e,t,s)?.getName();if(o&&n==m.Stone){r.setName(this.getLayerVoxel(e,t,s)).setXYZ(e,t,s).paint();let i=5;for(;i--;)r.setName(this.getLayerVoxel(e,t-1,s)).setXYZ(e,t-1-i,s).paint();return!0}return!1}fill(e,t,s){const{brush:r}=this.nodes;let i=t;for(r.setName(m.Water).setLevel(7);i<=this.nodes.waterHeight;)t<this.nodes.waterHeight&&r.setXYZ(e,i,s).paint(),i++;r.setLevel(0)}decorate(e,t,s){const r=this.nodes.brush.dataCursor,i=r.getVoxel(e,t+1,s),a=i?.isAir()||i?.isRenderable()&&r.getVoxel(e,t+1,s).getSubstanceData().dve_is_liquid,o=r.getVoxel(e,t,s)?.getName();a&&(o==m.Dirt||o==m.Sand)&&t<this.nodes.waterHeight-1&&Math.random()>.98&&F.generateWaterPlant(this.nodes,e,t+1,s)}getData(){return this.getClass().data}getClass(){return st}}class rt extends I{static data={id:"river",color:[0,228,245],biomes:[[st.data.id,o()]],edgeBiomeTypes:[]};isRiver=!0;getData(){return this.getClass().data}getClass(){return rt}}const it=-.35,at=.8,ot={id:"overworld",biomeTypes:[[re.data.id,o([.6,1],[-1,-.5],[it,at])],[q.data.id,o([-1,-.8],[-.7,0],[it,at])],[je.data.id,o([-1,.5],[.1,1],[-1,it],void 0,void 0,!1,!1,!1,!0,!1,!0)],[we.data.id,o([-.2,.5],[-.5,-.2],[it,at])],[fe.data.id,o([-.2,.3],[-.55,-.1],[it,at])],[_e.data.id,o([-.4,.7],[-1,0],[at,1])],[rt.data.id,o([-1,1],[-1,1],[it,at-.2],[.3,1.2],void 0,!1,!1,!1,!0)]]};var nt=s(29835),lt=s.n(nt),dt=s(84627);class ht{worldGenNoise;detailNoise;orePerlin;worldDetailNoise;worldGenDetailNoise;biomeNoise;biomeDetailNoise;biomeTypeMoistureNoise;biomeTypeTemperatureNoise;biomeTypeElevationNoise;biomeTypeRiverNoise;oreNoise;init(e){this.worldGenNoise=(0,dt.Cf)(lt()(`${e.worldNoise}`)),this.detailNoise=(0,dt.Cf)(lt()(`${e.detailNoise}`)),this.biomeNoise=(0,dt.fu)(lt()(`${e.biomeNoise}`)),this.biomeTypeMoistureNoise=(0,dt.fu)(lt()(`${e.biomeTypeMoistureNoise}`)),this.biomeTypeTemperatureNoise=(0,dt.fu)(lt()(`${e.biomeTypeTemperatureNoise}`)),this.biomeTypeElevationNoise=(0,dt.fu)(lt()(`${e.biomeTypeElevationNoise}`)),this.biomeDetailNoise=(0,dt.Cf)(lt()(`${e.biomeDetailNoise}`)),this.biomeTypeRiverNoise=(0,dt.fu)(lt()(e.biomeTypeRiverNoise)),this.oreNoise=(0,dt.Cf)(lt()(e.oreNoise)),this.worldDetailNoise=(0,dt.Cf)(lt()(e.worldDetailNoise)),this.worldGenDetailNoise=(0,dt.Cf)(lt()(e.worldGenDetailNoise)),console.log("noise",this.biomeTypeElevationNoise(123,31290),this.biomeTypeElevationNoise(239048230,42304),this.biomeTypeTemperatureNoise(209348,238490))}}var ct=s(81168);const ut=new i.T;let gt;class ft{static instance;nodes;overWorldGen;constructor(){if(ft.instance)return ft.instance;ft.instance=this}init(){c.registerBiomeTypes(je,q,fe,_e,re,we,rt),c.registerBiomes(Y,K,se,ue,ge,W,Te,be,oe,Fe,Ne,Ie,de,ye,Ie,Ee,De,Xe,qe,Oe,st,Je),c.registerCaveCarver(P,H,f),r.J.setWorldGen(this);const e=new ht;this.nodes=new a,e.init({biomeNoise:8394723847382,biomeDetailNoise:7089879878979,biomeTypeMoistureNoise:2748927489274,biomeTypeTemperatureNoise:1748927483928,biomeTypeElevationNoise:7384723847938,biomeTypeRiverNoise:3472983472983,worldNoise:1892738192738,detailNoise:3928743928743,oreNoise:1928371928371,worldDetailNoise:4938274938274,worldGenDetailNoise:0xefabe3fe05}),this.nodes.init({noise:e,brush:ut}),this.overWorldGen=new B(this.nodes,ot),this.overWorldGen.init(),V.init(this.nodes),G.init(this.nodes),J.init(this.nodes)}async generate([[e,t,s,r],i]){ut.start(e,t,s,r),this.overWorldGen.generateWorldColumn(t,r),ut.stop()}async decorate([[e,t,s,r],i]){ut.start(e,t,s,r),this.overWorldGen.decorateWorldColumn(t,r),clearTimeout(gt),gt=setTimeout((()=>this.overWorldGen.clearCache()),6e4),ut.stop()}}ct.QK.registerTask("get-biome-image",(([e,t])=>{const s=ft.instance.overWorldGen.generateBiomeTypeImage(e,t);return[s,[s.buffer]]}))},23891:(e,t,s)=>{s.d(t,{P:()=>i});var r=s(8126);class i{buffer;data;constructor(e){return this.buffer=e,this.data=new DataView(ArrayBuffer.isView(e)?e.buffer:e),new Proxy(this,{get:(e,t)=>{if("string"==typeof t&&!isNaN(Number(t))){const s=Number(t);return e.get(s)}return e[t]},set:(e,t,s)=>{if("string"==typeof t&&!isNaN(Number(t))){const r=Number(t);return e.set(r,s),!0}return e[t]=s,!0}})}get length(){return 8*this.buffer.byteLength}get(e){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);return r.u.getBitArrayIndexView(this.data,0,e)}set(e,t){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);if(t<0||t>1)throw new RangeError(`Value ${t} is out of bounds for a bit`);r.u.setBitArrayIndexView(this.data,0,e,t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.length?{value:this.get(e++),done:!1}:{value:void 0,done:!0}}}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t,this)}}},85860:(e,t,s)=>{var r,i;s.d(t,{QI:()=>r,Yd:()=>a,bI:()=>i}),function(e){e[e.Int8=0]="Int8",e[e.Uint8=1]="Uint8",e[e.Uint8Clamped=2]="Uint8Clamped",e[e.Int16=3]="Int16",e[e.Uint16=4]="Uint16",e[e.Float32=5]="Float32",e[e.Int32=6]="Int32",e[e.Uint32=7]="Uint32",e[e.Float64=8]="Float64",e[e.BigInt=9]="BigInt",e[e.BigUint=10]="BigUint"}(r||(r={})),function(e){e[e.Int8=1]="Int8",e[e.Uint8=1]="Uint8",e[e.Uint8Clamped=1]="Uint8Clamped",e[e.Int16=2]="Int16",e[e.Uint16=2]="Uint16",e[e.Float32=4]="Float32",e[e.Int32=4]="Int32",e[e.Uint32=4]="Uint32",e[e.Float64=8]="Float64",e[e.BigInt=8]="BigInt",e[e.BigUint=8]="BigUint"}(i||(i={}));const a={[r.Int8]:i.Int8,[r.Uint8]:i.Uint8,[r.Uint8Clamped]:i.Uint8Clamped,[r.Int16]:i.Int16,[r.Uint16]:i.Uint16,[r.Float32]:i.Float32,[r.Int32]:i.Int32,[r.Uint32]:i.Uint32,[r.Float64]:i.Float64,[r.BigInt]:i.BigInt,[r.BigUint]:i.BigUint}},8126:(e,t,s)=>{s.d(t,{u:()=>i});var r=s(35112);class i{static getBitArrayIndexView(e,t,s){const i=s/8|0,a=s-8*i,o=e.getUint8(i+t);return r.y.getBitValue(o,a,1)}static setBitArrayIndexView(e,t,s,i){const a=s/8|0,o=s-8*a,n=e.getUint8(a+t);e.setUint8(a+t,r.y.setBitValue(n,o,i,1))}static getBitArrayIndex(e,t,s){const i=s/8|0,a=s-8*i,o=e[i+t];return r.y.getBitValue(o,a,1)}static setBitArrayIndex(e,t,s,i){const a=s/8|0,o=s-8*a,n=e[a+t];e[a+t]=r.y.setBitValue(n,o,i,1)}static getNibbleArrayIndex(e,t,s){const i=s/2|0,a=s%2==0,o=e.getUint8(i+t);return r.y.getBitValue(o,a?4:0,4)}static setNibbleArrayIndex(e,t,s,i){const a=s/2|0,o=s%2==0,n=e.getUint8(a+t);e.setUint8(a+t,r.y.setBitValue(n,o?4:0,i,4))}static getHalfNibbleArrayIndex(e,t,s){const i=s/4|0,a=s%4,o=e.getUint8(i+t);return r.y.getBitValue(o,2*a,2)}static setHalfNibbleArrayIndex(e,t,s,i){const a=s/4|0,o=s%4,n=e.getUint8(a+t);e.setUint8(a+t,r.y.setBitValue(n,2*o,i,2))}}},35112:(e,t,s)=>{s.d(t,{y:()=>o});var r=s(34135),i=s(85860),a=s(25075);class o{static setTypedNumber(e,t,s,r){return a.v[s](e,t,r)}static getTypedNumber(e,t,s){return r.n[s](e,t)}static calculateBitsNeeded(e,t){let s=t-e;return Math.ceil(Math.log2(s))}static getTypedSize(e){return i.Yd[e]}static getBitValue(e,t,s){return(2**s-1<<t&e)>>>t}static setBitValue(e,t,s,r){const i=2**r-1;return e&~(i<<t)|(s&i)<<t}}},34135:(e,t,s)=>{s.d(t,{n:()=>i});var r=s(85860);const i={[r.QI.Int8]:(e,t)=>e.getInt8(t),[r.QI.Uint8]:(e,t)=>e.getUint8(t),[r.QI.Uint8Clamped]:(e,t)=>e.getUint8(t),[r.QI.Int16]:(e,t)=>e.getInt16(t,!0),[r.QI.Uint16]:(e,t)=>e.getUint16(t,!0),[r.QI.Float32]:(e,t)=>e.getFloat32(t,!0),[r.QI.Int32]:(e,t)=>e.getInt32(t,!0),[r.QI.Uint32]:(e,t)=>e.getUint32(t,!0),[r.QI.Float64]:(e,t)=>e.getFloat64(t,!0),[r.QI.BigInt]:(e,t)=>e.getBigInt64(t,!0),[r.QI.BigUint]:(e,t)=>e.getBigUint64(t,!0)}},25075:(e,t,s)=>{s.d(t,{v:()=>i});var r=s(85860);const i={[r.QI.Int8]:(e,t,s)=>e.setInt8(t,s),[r.QI.Uint8]:(e,t,s)=>e.setUint8(t,s),[r.QI.Uint8Clamped]:(e,t,s)=>e.setUint8(t,s),[r.QI.Int16]:(e,t,s)=>e.setInt16(t,s,!0),[r.QI.Uint16]:(e,t,s)=>e.setUint16(t,s,!0),[r.QI.Float32]:(e,t,s)=>e.setFloat32(t,s,!0),[r.QI.Int32]:(e,t,s)=>e.setInt32(t,s,!0),[r.QI.Uint32]:(e,t,s)=>e.setUint32(t,s,!0),[r.QI.Float64]:(e,t,s)=>e.setFloat64(t,s,!0),[r.QI.BigInt]:(e,t,s)=>e.setBigInt64(t,s,!0),[r.QI.BigUint]:(e,t,s)=>e.setBigUint64(t,s,!0)}},93587:(e,t,s)=>{var r,i;s.d(t,{$f:()=>r,xH:()=>i}),function(e){e.North="north",e.South="south",e.West="west",e.East="east",e.NorthEast="north-east",e.NorthWest="north-west",e.SouthEast="south-east",e.SouthWest="south-west"}(r||(r={})),function(e){e[e.North=0]="North",e[e.NorthEast=Math.PI/4]="NorthEast",e[e.East=Math.PI/2]="East",e[e.SouthEast=3*Math.PI/4]="SouthEast",e[e.South=Math.PI]="South",e[e.SouthWest=5*Math.PI/4]="SouthWest",e[e.West=3*Math.PI/2]="West",e[e.NorthWest=7*Math.PI/4]="NorthWest"}(i||(i={})),r.North,i.North,r.South,i.South,r.West,i.West,r.East,i.East,r.NorthEast,i.NorthEast,r.NorthWest,i.NorthWest,r.SouthEast,i.SouthEast,r.SouthWest,i.SouthWest},27798:(e,t,s)=>{s.d(t,{Jd:()=>r.J});var r=s(54262)},82843:(e,t,s)=>{function r(e,t,s,r){var i=t-e,a=r-s;return Math.sqrt(i*i+a*a)}s.d(t,{m:()=>r})},63086:(e,t,s)=>{function r(e,t,s,r,i,a){return Math.sqrt((r-e)**2+(i-t)**2+(a-s)**2)}s.d(t,{D:()=>r})},29600:(e,t,s)=>{s.d(t,{D7:()=>i.D,me:()=>r.m});var r=s(82843),i=s(63086)},85443:(e,t,s)=>{s.d(t,{Z:()=>r});class r{x;y;z;w;static Create(e=0,t=0,s=0,i=0){return new r(e,t,s,i)}static ApplyMatrix(e,t){return{x:e[0]*t.x+e[1]*t.y+e[2]*t.z+e[3]*t.w,y:e[4]*t.x+e[5]*t.y+e[6]*t.z+e[7]*t.w,z:e[8]*t.x+e[9]*t.y+e[10]*t.z+e[11]*t.w,w:e[12]*t.x+e[13]*t.y+e[14]*t.z+e[15]*t.w}}static ApplyMatrixArray(e,t){return[e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3],e[4]*t[0]+e[5]*t[1]+e[6]*t[2]+e[7]*t[3],e[8]*t[0]+e[9]*t[1]+e[10]*t[2]+e[11]*t[3],e[12]*t[0]+e[13]*t[1]+e[14]*t[2]+e[15]*t[3]]}static RotateAroundPivot(e,t,s){const i={x:t.x-s.x,y:t.y-s.y,z:t.z-s.z,w:t.w-s.w},a=r.ApplyMatrix(e,i);return{x:a.x+s.x,y:a.y+s.y,z:a.z+s.z,w:a.w+s.w}}static RotateAroundPivotArray(e,t,s){const i=[t[0]-s[0],t[1]-s[1],t[2]-s[2],t[3]-s[3]],a=r.ApplyMatrixArray(e,i);return[a[0]+s[0],a[1]+s[1],a[2]+s[2],a[3]+s[3]]}static Add(e,t){return{x:e.x+t.x,y:e.y+t.y,z:e.z+t.z,w:e.w+t.w}}static AddToRef(e,t,s){s.x=e.x+t.x,s.y=e.y+t.y,s.z=e.z+t.z,s.w=e.w+t.w}static AddInPlace(e,t){e.x+=t.x,e.y+=t.y,e.z+=t.z,e.w+=t.w}static AddArray(e,t){return[e[0]+t[0],e[1]+t[1],e[2]+t[2],e[3]+t[3]]}static AddArrayToRef(e,t,s){s[0]=e[0]+t[0],s[1]=e[1]+t[1],s[2]=e[2]+t[2],s[3]=e[3]+t[3]}static AddArrayInPlace(e,t){e[0]+=t[0],e[1]+=t[1],e[2]+=t[2],e[3]+=t[3]}static AddScalar(e,t){return{x:e.x+t,y:e.y+t,z:e.z+t,w:e.w+t}}static AddScalarToRef(e,t,s){s.x=e.x+t,s.y=e.y+t,s.z=e.z+t,s.w=e.w+t}static AddScalarInPlace(e,t){e.x+=t,e.y+=t,e.z+=t,e.w+=t}static AddScalarArray(e,t){return[e[0]+t,e[1]+t,e[2]+t,e[3]+t]}static AddScalarArrayToRef(e,t,s){s[0]=e[0]+t,s[1]=e[1]+t,s[2]=e[2]+t,s[3]=e[3]+t}static AddScalarArrayInPlace(e,t){e[0]+=t,e[1]+=t,e[2]+=t,e[3]+=t}static Subtract(e,t){return{x:e.x-t.x,y:e.y-t.y,z:e.z-t.z,w:e.w-t.w}}static SubtractToRef(e,t,s){s.x=e.x-t.x,s.y=e.y-t.y,s.z=e.z-t.z,s.w=e.w-t.w}static SubtractInPlace(e,t){e.x-=t.x,e.y-=t.y,e.z-=t.z,e.w-=t.w}static SubtractArray(e,t){return[e[0]-t[0],e[1]-t[1],e[2]-t[2],e[3]-t[3]]}static SubtractArrayToRef(e,t,s){s[0]=e[0]-t[0],s[1]=e[1]-t[1],s[2]=e[2]-t[2],s[3]=e[3]-t[3]}static SubtractArrayInPlace(e,t){e[0]-=t[0],e[1]-=t[1],e[2]-=t[2],e[3]-=t[3]}static SubtractScalar(e,t){return{x:e.x-t,y:e.y-t,z:e.z-t,w:e.w-t}}static SubtractScalarToRef(e,t,s){s.x=e.x-t,s.y=e.y-t,s.z=e.z-t,s.w=e.w-t}static SubtractScalarInPlace(e,t){e.x-=t,e.y-=t,e.z-=t,e.w-=t}static SubtractScalarArray(e,t){return[e[0]-t,e[1]-t,e[2]-t,e[3]-t]}static SubtractScalarArrayToRef(e,t,s){s[0]=e[0]-t,s[1]=e[1]-t,s[2]=e[2]-t,s[3]=e[3]-t}static SubtractScalarArrayInPlace(e,t){e[0]-=t,e[1]-=t,e[2]-=t,e[3]-=t}static Multiply(e,t){return{x:e.x*t.x,y:e.y*t.y,z:e.z*t.z,w:e.w*t.w}}static MultiplyToRef(e,t,s){s.x=e.x*t.x,s.y=e.y*t.y,s.z=e.z*t.z,s.w=e.w*t.w}static MultiplyInPlace(e,t){e.x*=t.x,e.y*=t.y,e.z*=t.z,e.w*=t.w}static MultiplyArray(e,t){return[e[0]*t[0],e[1]*t[1],e[2]*t[2],e[3]*t[3]]}static MultiplyArrayToRef(e,t,s){s[0]=e[0]*t[0],s[1]=e[1]*t[1],s[2]=e[2]*t[2],s[3]=e[3]*t[3]}static MultiplyArrayInPlace(e,t){e[0]*=t[0],e[1]*=t[1],e[2]*=t[2],e[3]*=t[3]}static MultiplyScalar(e,t){return{x:e.x*t,y:e.y*t,z:e.z*t,w:e.w*t}}static MultiplyScalarToRef(e,t,s){s.x=e.x*t,s.y=e.y*t,s.z=e.z*t,s.w=e.w*t}static MultiplyScalarInPlace(e,t){e.x*=t,e.y*=t,e.z*=t,e.w*=t}static MultiplyScalarArray(e,t){return[e[0]*t,e[1]*t,e[2]*t,e[3]*t]}static MultiplyScalarArrayToRef(e,t,s){s[0]=e[0]*t,s[1]=e[1]*t,s[2]=e[2]*t,s[3]=e[3]*t}static MultiplyScalarArrayInPlace(e,t){e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t}static Divide(e,t){return{x:e.x/t.x,y:e.y/t.y,z:e.z/t.z,w:e.w/t.w}}static DivideToRef(e,t,s){s.x=e.x/t.x,s.y=e.y/t.y,s.z=e.z/t.z,s.w=e.w/t.w}static DivideInPlace(e,t){e.x/=t.x,e.y/=t.y,e.z/=t.z,e.w/=t.w}static DivideArray(e,t){return[e[0]/t[0],e[1]/t[1],e[2]/t[2],e[3]/t[3]]}static DivideArrayToRef(e,t,s){s[0]=e[0]/t[0],s[1]=e[1]/t[1],s[2]=e[2]/t[2],s[3]=e[3]/t[3]}static DivideArrayInPlace(e,t){e[0]/=t[0],e[1]/=t[1],e[2]/=t[2],e[3]/=t[3]}static DivideScalar(e,t){return{x:e.x/t,y:e.y/t,z:e.z/t,w:e.w/t}}static DivideScalarToRef(e,t,s){s.x=e.x/t,s.y=e.y/t,s.z=e.z/t,s.w=e.w/t}static DivideScalarInPlace(e,t){e.x/=t,e.y/=t,e.z/=t,e.w/=t}static DivideScalarArray(e,t){return[e[0]/t,e[1]/t,e[2]/t,e[3]/t]}static DivideScalarArrayToRef(e,t,s){s[0]=e[0]/t,s[1]=e[1]/t,s[2]=e[2]/t,s[3]=e[3]/t}static DivideScalarArrayInPlace(e,t){e[0]/=t,e[1]/=t,e[2]/=t,e[3]/=t}static Dot(e,t){return e.x*t.x+e.y*t.y+e.z*t.z+e.w*t.w}static DotArray(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3]}static Length(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z+e.w*e.w)}static LengthArray(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]+e[3]*e[3])}static Normalize(e){const t=r.Length(e);return 0===t?{x:0,y:0,z:0,w:0}:{x:e.x/t,y:e.y/t,z:e.z/t,w:e.w/t}}static NormalizeToRef(e,t){const s=r.Length(e);0===s?(t.x=0,t.y=0,t.z=0,t.w=0):(t.x=e.x/s,t.y=e.y/s,t.z=e.z/s,t.w=e.w/s)}static NormalizeInPlace(e){const t=r.Length(e);0===t?(e.x=0,e.y=0,e.z=0,e.w=0):(e.x/=t,e.y/=t,e.z/=t,e.w/=t)}static NormalizeArray(e){const t=r.LengthArray(e);return 0===t?[0,0,0,0]:[e[0]/t,e[1]/t,e[2]/t,e[3]/t]}static NormalizeArrayToRef(e,t){const s=r.LengthArray(e);0===s?(t[0]=0,t[1]=0,t[2]=0,t[3]=0):(t[0]=e[0]/s,t[1]=e[1]/s,t[2]=e[2]/s,t[3]=e[3]/s)}static NormalizeArrayInPlace(e){const t=r.LengthArray(e);0===t?(e[0]=0,e[1]=0,e[2]=0,e[3]=0):(e[0]/=t,e[1]/=t,e[2]/=t,e[3]/=t)}static Distance(e,t){return r.Length(r.Subtract(e,t))}static DistanceArray(e,t){return r.LengthArray(r.SubtractArray(e,t))}static Lerp(e,t,s){return{x:e.x+s*(t.x-e.x),y:e.y+s*(t.y-e.y),z:e.z+s*(t.z-e.z),w:e.w+s*(t.w-e.w)}}static LerpToRef(e,t,s,r){r.x=e.x+s*(t.x-e.x),r.y=e.y+s*(t.y-e.y),r.z=e.z+s*(t.z-e.z),r.w=e.w+s*(t.w-e.w)}static LerpInPlace(e,t,s){e.x+=s*(t.x-e.x),e.y+=s*(t.y-e.y),e.z+=s*(t.z-e.z),e.w+=s*(t.w-e.w)}static LerpArray(e,t,s){return[e[0]+s*(t[0]-e[0]),e[1]+s*(t[1]-e[1]),e[2]+s*(t[2]-e[2]),e[3]+s*(t[3]-e[3])]}static LerpArrayToRef(e,t,s,r){r[0]=e[0]+s*(t[0]-e[0]),r[1]=e[1]+s*(t[1]-e[1]),r[2]=e[2]+s*(t[2]-e[2]),r[3]=e[3]+s*(t[3]-e[3])}static LerpArrayInPlace(e,t,s){e[0]+=s*(t[0]-e[0]),e[1]+=s*(t[1]-e[1]),e[2]+=s*(t[2]-e[2]),e[3]+=s*(t[3]-e[3])}static Negate(e){return{x:-e.x,y:-e.y,z:-e.z,w:-e.w}}static NegateToRef(e,t){t.x=-e.x,t.y=-e.y,t.z=-e.z,t.w=-e.w}static NegateInPlace(e){e.x=-e.x,e.y=-e.y,e.z=-e.z,e.w=-e.w}static NegateArray(e){return[-e[0],-e[1],-e[2],-e[3]]}static NegateArrayToRef(e,t){t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=-e[3]}static NegateArrayInPlace(e){e[0]=-e[0],e[1]=-e[1],e[2]=-e[2],e[3]=-e[3]}static Equals(e,t){return e.x===t.x&&e.y===t.y&&e.z===t.z&&e.w===t.w}static EqualsArray(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]}static Clone(e){return{x:e.x,y:e.y,z:e.z,w:e.w}}static CloneArray(e){return[e[0],e[1],e[2],e[3]]}static Copy(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}static CopyArray(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}static CopyFromArray(e,t){return e.x=t[0],e.y=t[1],e.z=t[2],e}static CopyIntoArray(e,t){return e[0]=t.x,e[1]=t.y,e[2]=t.z,e}static ToArray(e){return[e.x,e.y,e.z,e.w]}static FromArray(e){return new r(e[0],e[1],e[2],e[3])}constructor(e,t,s,r){this.x=e,this.y=t,this.z=s,this.w=r}}},33410:(e,t,s)=>{s.d(t,{Az:()=>i.A,D7:()=>o.D7,ZS:()=>a.Z,me:()=>o.me,xt:()=>r.x});var r=s(78441),i=s(7930),a=s(85443),o=s(29600)},6122:(e,t,s)=>{s.d(t,{F:()=>r});class r{_getIndex;_getXYZ;position;bounds;constructor(e,t){this._getIndex=e,this._getXYZ=t,this.position=[0,0,0],this.bounds=[1,1,1]}static GetXZYOrder(){return new r(((e,t)=>e[0]+e[2]*t[0]+e[1]*t[0]*t[2]),((e,t,s)=>{s[1]=Math.floor(e/(t[0]*t[2])),s[2]=Math.floor(e%(t[0]*t[2])/t[0]),s[0]=Math.floor(e%t[0])}))}static GetXYZOrder(){return new r(((e,t)=>e[0]+e[1]*t[0]+e[2]*t[0]*t[1]),((e,t,s)=>{s[2]=Math.floor(e/(t[0]*t[1])),s[1]=Math.floor(e%(t[0]*t[1])/t[0]),s[0]=Math.floor(e%t[0])}))}static GetYXZOrder(){return new r(((e,t)=>e[1]+t[1]*(e[0]+t[0]*e[2])),((e,t,s)=>{s[2]=Math.floor(e/(t[0]*t[1])),s[0]=Math.floor(e%(t[0]*t[1])/t[1]),s[1]=e%t[1]}))}get size(){return this.bounds[0]*this.bounds[1]*this.bounds[2]}getIndex(e){return this._getIndex(e,this.bounds)}getIndexVec3Array(e){return this.position[0]=e[0],this.position[1]=e[1],this.position[2]=e[2],this._getIndex(this.position,this.bounds)}getIndexXYZ(e,t,s){return this.position[0]=e,this.position[1]=t,this.position[2]=s,this._getIndex(this.position,this.bounds)}getIndexVec3(e){return this.position[0]=e.x,this.position[1]=e.y,this.position[2]=e.z,this._getIndex(this.position,this.bounds)}output=[0,0,0];getXYZ(e){return this._getXYZ(e,this.bounds,this.output),this.output}setBounds(e,t,s){this.bounds[0]=e,this.bounds[1]=t,this.bounds[2]=s}}},10538:(e,t,s)=>{s.d(t,{F:()=>r.F});var r=s(6122)},8611:(e,t,s)=>{s.d(t,{l:()=>r});class r{static ForEachFromToVec2(e,t,s,r){const i=e[0]<t[0]?s:-s,a=e[1]<t[1]?s:-s;for(let s=e[0];i>0?s<=t[0]:s>=t[0];s+=i)for(let i=e[1];a>0?i<=t[1]:i>=t[1];i+=a)r(s,i)}static*FromToVec2(e,t,s){const r=e[0]<t[0]?s:-s,i=e[1]<t[1]?s:-s;for(let s=e[0];r>0?s<=t[0]:s>=t[0];s+=r)for(let r=e[1];i>0?r<=t[1]:r>=t[1];r+=i)yield{x:s,y:r}}static ForEachFromToVec3(e,t,s,r){const i=e[0]<t[0]?s:-s,a=e[1]<t[1]?s:-s,o=e[2]<t[2]?s:-s;for(let s=e[0];i>0?s<=t[0]:s>=t[0];s+=i)for(let i=e[1];a>0?i<=t[1]:i>=t[1];i+=a)for(let a=e[2];o>0?a<=t[2]:a>=t[2];a+=o)r(s,i,a)}static*FromToVec3(e,t,s){const r=e[0]<t[0]?s:-s,i=e[1]<t[1]?s:-s,a=e[2]<t[2]?s:-s;for(let s=e[0];r>0?s<=t[0]:s>=t[0];s+=r)for(let r=e[1];i>0?r<=t[1]:r>=t[1];r+=i)for(let i=e[2];a>0?i<=t[2]:i>=t[2];i+=a)yield{x:s,y:r,z:i}}}},58917:(e,t,s)=>{s.d(t,{F$:()=>r.F,l5:()=>i.l});var r=s(10538),i=s(8611)},99673:(e,t,s)=>{s.d(t,{$f:()=>o.$f,Az:()=>r.Az,D7:()=>r.D7,F$:()=>i.F$,Jd:()=>a.Jd,ZS:()=>r.ZS,l5:()=>i.l5,me:()=>r.me,xH:()=>o.xH,xt:()=>r.xt});var r=s(33410),i=s(58917),a=s(27798),o=s(93587)},28432:(e,t,s)=>{s.d(t,{j:()=>o});var r=s(87137),i=s(84918),a=s(55725);class o{name;index;threadPoolName;static readySet=new Set;get isRemoteReady(){return o.readySet.has(this)}get isPortSet(){return Boolean(this.port)}port=null;_pool=null;constructor(e,t,s="worker",r=null){this.name=e,this.index=t,this.threadPoolName=s,this._pool=r}setPort(e){if(this.port=e,"browser"==r.Q.environment){const t=e;t.onmessage=e=>{if(a.E.isInternal(e.data))return a.E.runInternal(e.data,this,e)},t.onmessageerror=e=>{console.error(`Error occured in from thread ${this.name}`),console.log(e.data),console.log(e)}}if("node"==r.Q.environment){const t=e;t.on("message",(e=>{if(a.E.isInternal(e))return a.E.runInternal(e,this,e)})),t.on("error",(e=>{console.error(`Error occured in from thread ${this.name}`),console.log(e)}))}this.sendMessage([a.E.INTERNAL_CODE,i.g.setReady,[this.name,this.index]])}sendMessage(e,t){if(!this.port)throw new Error(`Cannot send message to thread [${this.name}] port is not set`);this.port.postMessage(e,"browser"==r.Q.environment&&t?t:void 0)}connectToThread(e){const t=new MessageChannel;e.sendMessage([a.E.INTERNAL_CODE,i.g.connectPort,[this.name,this.threadPoolName,t.port1]],[t.port1]),this.sendMessage([a.E.INTERNAL_CODE,i.g.connectPort,[e.name,e.threadPoolName,t.port2]],[t.port2])}waitTillTaskExist(e,t=50){let s=!1;return new Promise((r=>{const i=e=>{if(s)return clearTimeout(o);e?(s=!0,r(!0),clearTimeout(o)):setTimeout(a,t)},a=()=>{this.taskExist(e,i)};let o=setTimeout(a,t)}))}taskExist(e,t){const s=a.E.getPromiseId();a.z.checkTasks[2][0]=e,a.z.checkTasks[2][1]=s,this.sendMessage(a.z.checkTasks),a.E.addPromiseTakss("tasks-check",s,(e=>{t(e)}))}runTask(e,t,s,r){const i=r?a.E.getPromiseId():-1;r&&a.E.addPromiseTakss(e,i,r),a.z.runTask[2][0]=e,a.z.runTask[2][1]=i,a.z.runTask[2][2]=t,this.sendMessage(a.z.runTask,s),a.z.runTask[2][2]=null}runTaskAsync(e,t,s){return new Promise((r=>{this.runTask(e,t,s,(e=>{r(e)}))}))}waitTillReady(){return new Promise(((e,t)=>{const s=setInterval((()=>{this.isPortSet&&(clearInterval(s),e(!0))}),1)}))}destroy(){o.readySet.delete(this),this.port&&"terminate"in this.port&&this.port.terminate()}}},82938:(e,t,s)=>{s.d(t,{p:()=>a});var r=s(28432),i=s(87137);class a{name;_totalThreads=0;_currentThread=0;__threads=[];constructor(e){this.name=e}getThreads(){return this.__threads}connectToThread(e){for(const t of this.__threads)t.connectToThread(e)}destroyAll(){for(const e of this.__threads)e.destroy()}isReady(){let e=!0;for(const t of this.__threads)t.isPortSet||(e=!1);return e}waitTillAllAreReady(){return new Promise(((e,t)=>{const s=setInterval((()=>{this.isReady()&&(clearInterval(s),e(!0))}),1)}))}addPort(e){const t=`${this.name}-${this._totalThreads}`,s=new r.j(t,this._totalThreads,this.name,this);i.Q.addThread(s),s.setPort(e),this.__threads.push(s),this._totalThreads++}runTaskForAll(e,t,s){for(let r=0;r<this.__threads.length;r++)this.__threads[r].runTask(e,t,s)}runTask(e,t,s,r,i,a){return"number"!=typeof i?(this._currentThread==a&&this.__handleCount(),this.__threads[this._currentThread].runTask(e,t,s,r),this.__handleCount()):(this.__threads[i].runTask(e,t,s,r),i)}runTaskAsync(e,t,s,r,i){return new Promise((a=>{this.runTask(e,t,s,a,r,i)}))}__handleCount(){let e=this._currentThread;return this._currentThread++,this._currentThread>=this._totalThreads&&(this._currentThread=0),e}}},26983:(e,t,s)=>{function r(){}s.d(t,{A:()=>r})},94618:(e,t,s)=>{s.d(t,{A:()=>y});var r=s(80740),i=s(20650),a=s(99673),o=s(11601),n=s(15741),l=s(23891),d=s(8126);class h{buffer;data;constructor(e){return this.buffer=e,this.data=new DataView(ArrayBuffer.isView(e)?e.buffer:e),new Proxy(this,{get:(e,t)=>{if("string"==typeof t&&!isNaN(Number(t))){const s=Number(t);return e.get(s)}return e[t]},set:(e,t,s)=>{if("string"==typeof t&&!isNaN(Number(t))){const r=Number(t);return e.set(r,s),!0}return e[t]=s,!0}})}get length(){return 4*this.buffer.byteLength}get(e){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);return d.u.getHalfNibbleArrayIndex(this.data,0,e)}set(e,t){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);if(t<0||t>3)throw new RangeError(`Value ${t} is out of bounds for a half nibble`);d.u.setHalfNibbleArrayIndex(this.data,0,e,t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.length?{value:this.get(e++),done:!1}:{value:void 0,done:!0}}}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t,this)}}class c{buffer;data;constructor(e){return this.buffer=e,this.data=new DataView(ArrayBuffer.isView(e)?e.buffer:e),new Proxy(this,{get:(e,t)=>{if("string"==typeof t&&!isNaN(Number(t))){const s=Number(t);return e.get(s)}return e[t]},set:(e,t,s)=>{if("string"==typeof t&&!isNaN(Number(t))){const r=Number(t);return e.set(r,s),!0}return e[t]=s,!0}})}get length(){return 2*this.buffer.byteLength}get(e){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);return d.u.getNibbleArrayIndex(this.data,0,e)}set(e,t){if(e<0||e>=this.length)throw new RangeError(`Index ${e} is out of bounds`);if(t<0||t>15)throw new RangeError(`Value ${t} is out of bounds for a nibble`);d.u.setNibbleArrayIndex(this.data,0,e,t)}[Symbol.iterator](){let e=0;return{next:()=>e<this.length?{value:this.get(e++),done:!1}:{value:void 0,done:!0}}}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t,this)}}const u=(e,t)=>2==e?new l.P(t):e>2&&e<=4?new h(t):e>4&&e<=15?new c(t):t;var g=s(18556),f=s(15661);class m{index=a.F$.GetXZYOrder();size;ids;level;state;mod;secondary;idPalette;levelPalette;statePalette;modPalette;secondaryIdPalette;secondaryStatePalette;constructor(e){this.size=[...e.size],this.index.setBounds(...e.size),this.idPalette=new o.N(e.palettes.id),this.levelPalette=new n.h(e.palettes.level),this.statePalette=new n.h(e.palettes.state),this.modPalette=new n.h(e.palettes.mod),this.secondaryIdPalette=new o.N(e.palettes.secondaryId),this.secondaryStatePalette=new n.h(e.palettes.secondaryState),"object"==typeof e.buffers.ids?this.ids=u(e.palettes.id.length,e.buffers.ids):this.ids=e.buffers.ids,"object"==typeof e.buffers.level?this.level=u(e.palettes.level.length,e.buffers.level):this.level=e.buffers.level,"object"==typeof e.buffers.state?this.state=u(e.palettes.state.length,e.buffers.state):this.state=e.buffers.state,"object"==typeof e.buffers.mod?this.mod=u(e.palettes.mod.length,e.buffers.mod):this.mod=e.buffers.mod,"object"==typeof e.buffers.secondary?this.secondary=u(Math.max(e.palettes.secondaryState.length,e.palettes.secondaryId.length),e.buffers.secondary):this.secondary=e.buffers.secondary}getIndex(e,t,s){return this.index.getIndexXYZ(e,t,s)}getId(e){const t=this.ids;return g.A.voxels.getNumberId(this.idPalette.getStringId("number"==typeof t?t:t[e]))}getState(e){const t=this.state;return this.statePalette.getValue("number"==typeof t?t:t[e])}getLevel(e){const t=this.mod;return this.modPalette.getValue("number"==typeof t?t:t[e])}getMod(e){const t=this.mod;return this.modPalette.getValue("number"==typeof t?t:t[e])}getSecondary(e,t){const s=this.secondary;return f.L.VoxelTags[e].dve_can_have_secondary?g.A.voxels.getNumberId(this.secondaryIdPalette.getStringId("number"==typeof s?s:s[t])):this.secondaryStatePalette.getValue("number"==typeof s?s:s[t])}*traverse(){const e=this.size,t=[0,0,0,0,0,0],s={position:[0,0,0],raw:t};for(const{x:r,y:i,z:o}of a.l5.FromToVec3([0,0,0],[e[0]-1,e[1]-1,e[2]-1],1)){const e=this.index.getIndexXYZ(r,i,o);s.position[0]=r,s.position[1]=i,s.position[2]=o,t[0]=this.getId(e),t[1]=0,t[2]=this.getLevel(e),t[3]=this.getState(e),t[4]=this.getMod(e),t[5]=this.getSecondary(t[0],e),t[0]<1&&t[3]<1||(yield s)}}toJSON(){return{templatorVersion:0,version:0,size:this.size,palettes:{id:this.idPalette._palette,level:Uint8Array.from(this.statePalette._palette),state:Uint16Array.from(this.statePalette._palette),mod:Uint16Array.from(this.modPalette._palette),secondaryId:this.secondaryIdPalette._palette,secondaryState:Uint16Array.from(this.secondaryStatePalette._palette)},buffers:{ids:this.ids instanceof Uint16Array||this.ids instanceof Uint8Array||"number"==typeof this.ids?this.ids:new Uint8Array(this.ids.buffer),level:this.level instanceof Uint8Array||"number"==typeof this.level?this.level:new Uint8Array(this.level.buffer),mod:this.mod instanceof Uint16Array||this.mod instanceof Uint8Array||"number"==typeof this.mod?this.mod:new Uint8Array(this.mod.buffer),state:this.state instanceof Uint16Array||this.state instanceof Uint8Array||"number"==typeof this.state?this.state:new Uint8Array(this.state.buffer),secondary:this.secondary instanceof Uint16Array||this.secondary instanceof Uint8Array||"number"==typeof this.secondary?this.secondary:new Uint8Array(this.secondary.buffer)}}}}var p=s(81168);function y(){const e=i.J.getBrush();p.QK.registerTask(r.m.PlaceVoxelArea,(async([t,[s,r,i],[a,o,n],l])=>{e.start(t,s,r,i),e.setData(l);for(let t=s;t<a;t++)for(let s=r;s<o;s++)for(let r=i;r<n;r++)e.dataCursor.inBounds(t,s,r)&&e.setXYZ(t,s,r).paint();e.runUpdates();for(let t=s;t<a;t++)for(let s=r;s<o;s++)for(let r=i;r<n;r++)e.dataCursor.inBounds(t,s,r)&&e.setXYZ(t,s,r).update();e.runUpdates();const d=e.getUpdatedSections();return e.stop(),[d]})),p.QK.registerTask(r.m.RemoveVoxelArea,(([t,[s,r,i],[a,o,n]])=>{e.start(t,s,r,i);for(let t=s;t<a;t++)for(let s=r;s<o;s++)for(let r=i;r<n;r++)e.dataCursor.inBounds(t,s,r)&&e.dataCursor.getVoxel(t,s,r)?.isRenderable()&&e.setXYZ(t,s,r).erase();e.runUpdates(),r-=1,i-=1,a+=1,o+=1,n+=1;for(let t=s-=1;t<a;t++)for(let s=r;s<o;s++)for(let r=i;r<n;r++)e.dataCursor.inBounds(t,s,r)&&e.setXYZ(t,s,r).update();e.runUpdates();const l=e.getUpdatedSections();return e.stop(),[l]})),p.QK.registerTask(r.m.BuildTemplate,(async([t,[s,r,i],a],o)=>{e.start(t,s,r,i);const n=new m(a),l=s+n.size[0],d=r+n.size[1],h=i+n.size[2];await e.worldAlloc([s,r,i],[l,d,h]);for(const{raw:t,position:a}of n.traverse())t[1]=0,e.setRaw(t).setXYZ(a[0]+s,a[1]+r,a[2]+i).paint();e.runUpdates();for(let t=s;t<l;t++)for(let s=r;s<d;s++)for(let r=i;r<h;r++)e.dataCursor.inBounds(t,s,r)&&e.setXYZ(t,s,r).update();e.runUpdates();const c=e.getUpdatedSections();return e.stop(),await e.worldDealloc([s,r,i],[l,d,h]),[c]}))}},6694:(e,t,s)=>{s.d(t,{c:()=>n});var r=s(81168),i=s(39212);const a=r.QK.createThread("world");class o extends i.Q{static instnace;parent=r.QK.parent;world=a;constructor(){super(),o.instnace=this,this.addThread(this.world),this.addThread(this.parent)}}class n{static environment="browser";static instance;TC=r.QK;threads=new o;constructor(){if(n.instance)return n.instance;n.instance=this}}},20707:(e,t,s)=>{s.d(t,{V:()=>_s});var r=s(27293),i=s(6694),a=s(81168),o=s(22120),n=s(75438),l=s(86081),d=s(39757),h=s(38e3),c=s(36603),u=s(10008),g=s(91437),f=s(83651),m=(s(52196),s(70522)),p=s(48860);class y{static _brush=new f.l;static _sDataTool=new p.p;static _nDataTool=new p.p;static setVoxel(e,t,s,r,i,a,o){}static setDimension(e){}static removeVoxel(e,t,s,r){}static getFlowRate(e){return 0}static getVoxel(e,t,s){return this._sDataTool}static setLevel(e,t,s,r){}static getLevel(e,t,s,r){}static getLevelState(e,t,s,r){}static canFlowOutwardTest(e,t,s,r){}static flowDownTest(e,t,s,r){}static wait(e){return new Promise(((t,s)=>setTimeout(t,e)))}static _lightValues=[0,0,0,0];static getAbsorbLight(e,t,s){}static sunCheck(e,t,s,r){}}async function x(e,t=!0){}const v=new c.P,b=e=>{let t=d.i.doRGBPropagation,s=d.i.doSunPropagation;const[r,i,a,o]=e.origin;e.nDataCursor.setFocalPoint(r,i,a,o);for(const r of h.LE){const n=r[0]+i,l=r[1]+a,d=r[2]+o,h=e.nDataCursor.getVoxel(n,l,d);h&&(t&&h.hasRGBLight()&&e.rgb.update.push(n,l,d),s&&h.hasSunLight()&&e.sun.update.push(n,l,d))}};async function w(e){const[t,s,r,i]=e;v.setOrigin(e);let a=v.sDataCursor.getVoxel(s,r,i);if(!a)return!1;const o=a.getSubstanceData();if(!a.isAir()&&d.i.doFlow&&a.isRenderable()&&o.dve_is_liquid)return async function(){}(),v;a=v.sDataCursor.getVoxel(s,r,i);const n=a.getLight(),l=a.isLightSource();a.setSecondary(!0).setId(0).setSecondary(!1),a.setLight(n>0?n:0).setId(0).setLevel(0).setLevelState(0).setState(0).setMod(0).updateVoxel(1),d.i.doLight&&(d.i.doRGBPropagation&&l&&(v.rgb.remove.push(s,r,i),(0,u.Q)(v)),b(v),d.i.doRGBPropagation&&(0,u.D)(v),d.i.doSunPropagation&&(0,g.a)(v)),v.bounds.update(s,r,i),v.bounds.update(s+1,r+1,i+1);for(let e=0;e<h.LE.length;e++)v.sDataCursor.getVoxel(h.LE[e][0]+s,h.LE[e][1]+r,h.LE[e][2]+i)?.updateVoxel(2);return v}async function A(e){const[t,s,r,i]=e[0];v.setOrigin(e[0]);let a=v.sDataCursor.getVoxel(s,r,i);if(!a)return!1;const o=e[1],n=a.isOpaque();let l=d.i.doRGBPropagation,c=d.i.doSunPropagation;e:if(d.i.doLight){if(a.getLight()<=0)break e;c&&a.hasSunLight()&&(v.sun.remove.push(s,r,i),(0,g.z)(v)),l&&a.hasRGBLight()&&n&&(v.rgb.remove.push(s,r,i),(0,u.Q)(v))}a=v.sDataCursor.getVoxel(s,r,i);const f=o[0];if(f<0)return!1;a.setId(f),a.setLevel(o[2]),a.setState(o[3]),a.setMod(o[4]),a.process(),o[3]>0&&a.canHaveSecondaryVoxel()&&(a.setSecondary(!0),a.setId(o[5]),a.setSecondary(!1)),a.isLightSource()&&a.getLightSourceValue()&&a.setLight(a.getLightSourceValue()),a.updateVoxel(0),d.i.doLight&&(b(v),l&&(v.rgb.update.push(s,r,i),(0,u.D)(v)),c&&(0,g.a)(v)),a=v.sDataCursor.getVoxel(s,r,i),d.i.doFlow&&!a.isAir()&&a.getSubstanceData().dve_is_liquid&&x(),v.bounds.update(s,r,i),v.bounds.update(s+1,r+1,i+1);for(let e=0;e<h.LE.length;e++)v.sDataCursor.getVoxel(h.LE[e][0]+s,h.LE[e][1]+r,h.LE[e][2]+i)?.updateVoxel(2);return v}async function B(e){const[t,s,r,i]=e[0];v.setOrigin(e[0]);const a=v.sDataCursor.getVoxel(s,r,i);if(!a)return!1;let o=d.i.doRGBPropagation,n=d.i.doSunPropagation;return d.i.doLight&&(b(v),o&&(v.rgb.update.push(s,r,i),(0,u.D)(v)),n&&(v.sun.update.push(s,r,i),(0,g.a)(v))),d.i.doFlow&&a.getSubstanceData().dve_is_solid&&x(),v.bounds.update(s,r,i),v.bounds.update(s+1,r+1,i+1),v}var I=s(62312);class S{static getRelative(e){e=[...e];const t=I.k.section.bounds.x,s=I.k.section.bounds.z;let r=-1/0;const[i,a,o,n]=e;for(const i of h.vY){e[1]=i[0]*t+a,e[3]=i[1]*s+n;const o=this.getAbsolute(e);o>r&&(r=o)}return r}static getAbsolute(e){const t=n._.sectors.get(e[0],e[1],e[2],e[3]);if(!t)return I.k.world.bounds.MinY;if(0==t.sections.length)return I.k.world.bounds.MinY;let s=I.k.world.bounds.MinY;e[1],e[2],e[3];for(let e=0;e<t.sections.length;e++){const r=t.sections[e];if(!r)continue;const i=r.getPosition();let[a,o]=r.getMinMax();Math.abs(o)!=1/0&&(o=i[1]+o,s<o&&(s=o))}return s+1}}var C=s(50327),T=s(99196);const _=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]],z=[],V=new C.$;var D=s(63086);class M{_map=new Map;get size(){return this._map.size}_getKey(e,t,s){return`${e}_${t}_${s}`}inMap(e,t,s){return this._map.has(this._getKey(e,t,s))}add(e,t,s){this._map.set(this._getKey(e,t,s),!0)}remove(e,t,s){this._map.delete(this._getKey(e,t,s))}removeDiffernce(e){for(const[t]of e._map)this._map.has(t)&&this._map.delete(t);return e}clear(){this._map.clear()}}const k=new C.$,N={runExplosion(e,t){const[s,r,i,a]=e.origin;y.setDimension(s);const o=[],n=new M;for(o.push([r,i,a]);o.length;){const s=o.shift();if(!s)break;const l=s[0],d=s[1],c=s[2];!n.inMap(l+1,d,c)&&e.sDataCursor.getVoxel(l+1,d,c)&&((0,D.D)(r,i,a,l+1,d,c)<=t&&o.push([l+1,d,c]),n.add(l+1,d,c)),n.inMap(l-1,d,c)||(e.sDataCursor.getVoxel(l-1,d,c)&&(0,D.D)(r,i,a,l-1,d,c)<=t&&o.push([l-1,d,c]),n.add(l-1,d,c)),n.inMap(l,d,c+1)||(e.sDataCursor.getVoxel(l,d,c+1)&&(0,D.D)(r,i,a,l,d,c+1)<=t&&o.push([l,d,c+1]),n.add(l,d,c+1)),n.inMap(l,d,c-1)||(e.sDataCursor.getVoxel(l,d,c-1)&&(0,D.D)(r,i,a,l,d,c-1)<=t&&o.push([l,d,c-1]),n.add(l,d,c-1)),n.inMap(l,d+1,c)||(e.sDataCursor.getVoxel(l,d+1,c)&&(0,D.D)(r,i,a,l,d+1,c)<=t&&o.push([l,d+1,c]),n.add(l,d+1,c)),n.inMap(l,d-1,c)||(e.sDataCursor.getVoxel(l,d-1,c)&&(0,D.D)(r,i,a,l,d-1,c)<=t&&o.push([l,d-1,c]),n.add(l,d-1,c));const u=e.sDataCursor.getVoxel(l,d,c);if(u&&u.isRenderable()){for(const t of h.LE){const s=l+t[0],r=d+t[1],i=c+t[2],a=e.nDataCursor.getVoxel(l,d,c);if(a){const t=a.getLight();t>0&&(k.getS(t)>0&&e.sun.remove.push(s,r,i),k.hasRGBLight(t)&&e.rgb.remove.push(s,r,i))}}e.bounds.update(l,d,c),u.setAir().updateVoxel(1)}}(0,u.Q)(e),(0,g.z)(e),(0,u.D)(e),(0,g.a)(e)}};var L=s(57870),R=s(99673);class F{_section;voxel=new L.$(this);_voxelIndex=0;_voxelPosition=R.Az.Create();_sectionPosition=R.Az.Create();inBounds(e,t,s){const r=this._sectionPosition.x+I.k.section.bounds.x,i=this._sectionPosition.y+I.k.section.bounds.y,a=this._sectionPosition.z+I.k.section.bounds.z;return!(e<this._sectionPosition.x||t<this._sectionPosition.y||s<this._sectionPosition.z||e>r||t>i||s>a)}setSection(e,t,s,r){if("object"==typeof e){this._section=e;const t=this._section.getPosition();return this._sectionPosition.x=t[0],this._sectionPosition.y=t[1],void(this._sectionPosition.z=t[2])}const i=n._.sectors.get(e,t||0,s||0,r||0);if(!i)return!1;this._section=i.getSection(t||0,s||0,r||0);const a=this._section.getPosition();return this._sectionPosition.x=a[0],this._sectionPosition.y=a[1],this._sectionPosition.z=a[2],!0}getVoxelAtIndex(e){return this._voxelIndex=e,I.k.voxel.getPositionFromIndex(e,this._voxelPosition),this.voxel.loadIn(),this.voxel}getVoxel(e,t,s){return this._section?(I.k.voxel.getPosition(e,t,s,this._voxelPosition),this._voxelIndex=I.k.voxel.getIndexFromPosition(this._voxelPosition.x,this._voxelPosition.y,this._voxelPosition.z),this.voxel.loadIn(),this.voxel):null}}const U=new F;var P=s(11601);class E{static flatIndex=R.F$.GetXYZOrder();static getIndex(e,t,s){return this.flatIndex.getIndexXYZ(e+1,t+1,s+1)}}E.flatIndex.setBounds(3,3,3);const H=[];for(let e=0;e<E.flatIndex.size;e++)H[e]=E.flatIndex.getXYZ(e).map((e=>e-1));const G=E.flatIndex.size;function O(e,t,s){return e*s*G+t*s}class Q{view;faceByteCount;constructor(e){this.view=new Uint16Array(e.buffer),this.faceByteCount=e.faceByteCount}getValue(e,t,s){const r=this.view[O(e,t,this.faceByteCount)+s];return 65535==r?-1:r}setValue(e,t,s,r=-1){return this.view[O(e,t,this.faceByteCount)+s]=r}getData(){return{buffer:this.view.buffer,faceByteCount:this.faceByteCount}}}var Y=s(8126);const X=E.flatIndex.size;function Z(e,t,s){return e*s*X+t*s}class W{view;vertexByteCount;constructor(e){this.vertexByteCount=e.vertexByteCount,this.view=new Uint8Array(e.buffer)}getValue(e,t,s){return Y.u.getBitArrayIndex(this.view,Z(e,t,this.vertexByteCount),s)}setValue(e,t,s,r=1){Y.u.setBitArrayIndex(this.view,Z(e,t,this.vertexByteCount),s,r)}getData(){return{buffer:this.view.buffer,vertexByteCount:this.vertexByteCount}}}var q;!function(e){e[e.Enabled=0]="Enabled",e[e.Fliped=1]="Fliped",e[e.Texture=2]="Texture",e[e.Rotation=3]="Rotation",e[e.Transparent=4]="Transparent",e[e.UVs=5]="UVs",e[e.Index=6]="Index"}(q||(q={}));const j=e=>{const t=[];return t[q.Enabled]=!0,t[q.Fliped]=!1,t[q.Texture]=0,t[q.Rotation]=0,t[q.Transparent]=!1,t[q.UVs]=[[1,1],[0,1],[0,0],[1,0]],t[q.Index]=e,t};class ${static ArgIndexes=q;static CreateArgs(){const e=[];for(let t=0;t<6;t++)e[t]=j(t);return e}}class K{geometryPaletteId;geomtry;data;transform;faceIndex=-1;vertexIndex=-1;faceCount=-1;vertexCount=-1;builder;constructor(e,t,s,r){this.geometryPaletteId=e,this.geomtry=t,this.data=s,this.transform=r}}var J;!function(e){e[e.TopRight=0]="TopRight",e[e.TopLeft=1]="TopLeft",e[e.BottomLeft=2]="BottomLeft",e[e.BottomRight=3]="BottomRight"}(J||(J={}));const ee=[J.TopRight,J.TopLeft,J.BottomLeft,J.BottomRight];var te;!function(e){e[e.Up=0]="Up",e[e.Down=1]="Down",e[e.North=2]="North",e[e.South=3]="South",e[e.East=4]="East",e[e.West=5]="West"}(te||(te={}));const se=Object.freeze([te.Up,te.Down,te.North,te.South,te.East,te.West]),re=Object.freeze({[te.Up]:[0,1,0],[te.Down]:[0,-1,0],[te.North]:[0,0,1],[te.South]:[0,0,-1],[te.East]:[1,0,0],[te.West]:[-1,0,0]}),ie=(te.Up,te.Down,te.Down,te.Up,te.North,te.South,te.South,te.North,te.East,te.West,te.West,te.East,te.Up,R.$f.North,te.Down,R.$f.South,te.North,R.$f.North,te.South,R.$f.South,te.East,R.$f.East,te.West,R.$f.West,R.$f.North,te.North,R.$f.South,te.South,R.$f.West,te.West,R.$f.East,te.East,R.$f.NorthEast,te.Up,R.$f.NorthWest,te.Up,R.$f.SouthEast,te.Up,R.$f.SouthWest,te.Up,te.Up,te.Down,te.North,te.South,te.East,te.West,te.Up,te.Down,te.North,te.South,te.East,te.West,[]);ie[te.Up]=[],ie[te.Up][J.TopRight]=[1,1,0,0,1,1,1,1,1],ie[te.Up][J.TopLeft]=[-1,1,0,0,1,1,-1,1,1],ie[te.Up][J.BottomLeft]=[-1,1,0,0,1,-1,-1,1,-1],ie[te.Up][J.BottomRight]=[1,1,0,0,1,-1,1,1,-1],ie[te.Down]=[],ie[te.Down][J.TopRight]=[-1,-1,0,0,-1,1,-1,-1,1],ie[te.Down][J.TopLeft]=[1,-1,0,0,-1,1,1,-1,1],ie[te.Down][J.BottomLeft]=[1,-1,0,0,-1,-1,1,-1,-1],ie[te.Down][J.BottomRight]=[-1,-1,0,0,-1,-1,-1,-1,-1],ie[te.East]=[],ie[te.East][J.TopRight]=[1,0,1,1,1,0,1,1,1],ie[te.East][J.TopLeft]=[1,0,-1,1,1,0,1,1,-1],ie[te.East][J.BottomLeft]=[1,0,-1,1,-1,0,1,-1,-1],ie[te.East][J.BottomRight]=[1,0,1,1,-1,0,1,-1,1],ie[te.West]=[],ie[te.West][J.TopRight]=[-1,0,-1,-1,1,0,-1,1,-1],ie[te.West][J.TopLeft]=[-1,0,1,-1,1,0,-1,1,1],ie[te.West][J.BottomLeft]=[-1,0,1,-1,-1,0,-1,-1,1],ie[te.West][J.BottomRight]=[-1,0,-1,-1,-1,0,-1,-1,-1],ie[te.South]=[],ie[te.South][J.TopRight]=[1,0,-1,0,1,-1,1,1,-1],ie[te.South][J.TopLeft]=[-1,0,-1,0,1,-1,-1,1,-1],ie[te.South][J.BottomLeft]=[-1,0,-1,0,-1,-1,-1,-1,-1],ie[te.South][J.BottomRight]=[1,0,-1,0,-1,-1,1,-1,-1],ie[te.North]=[],ie[te.North][J.TopRight]=[-1,0,1,0,1,1,-1,1,1],ie[te.North][J.TopLeft]=[1,0,1,0,1,1,1,1,1],ie[te.North][J.BottomLeft]=[1,0,1,0,-1,1,1,-1,1],ie[te.North][J.BottomRight]=[-1,0,1,0,-1,1,-1,-1,1];const ae=new Int8Array(216),oe=[J.TopRight,J.TopLeft,J.BottomLeft,J.BottomRight];for(const e of se)for(let t=0;t<oe.length;t++)for(let s=0;s<9;s++)ae[36*e+9*oe[t]+s]=ie[e][oe[t]][s];const ne=[];for(const e of se){ne[e]??=[];for(let t=0;t<oe.length;t++){ne[e][oe[t]]??=[];let s=0;for(let r=0;r<9;r+=3){const i=ie[e][oe[t]][r],a=ie[e][oe[t]][r+1],o=ie[e][oe[t]][r+2];ne[e][oe[t]][s]=E.getIndex(i,a,o),s++}}}E.getIndex(0,0,0);const le=[];function de(e,t,s,r){return e>t&&e>s&&e>r}function he(e,t,s,r){return a=r,!(e==(i=t)&&i==a&&a==s||de(r,t,s,e)||de(t,s,r,e)||!de(e,t,s,r)&&!de(s,t,r,e)&&!((e+s)/2>(t+r)/2));var i,a}function ce(e,t,s,r){let i,a,o=!1;switch(e){case te.Up:i=t,a=r;break;case te.Down:i=t,a=r,o=!0;break;case te.North:i=t,a=s,o=!0;break;case te.South:i=t,a=s;break;case te.East:i=r,a=s;break;case te.West:i=r,a=s,o=!0}return function(e,t,s=!1){let r=(1-(e=Math.max(0,Math.min(1,e))))*(1-(t=Math.max(0,Math.min(1,t)))),i=e*(1-t),a=e*t,o=(1-e)*t;return s?[o,a,i,r]:[a,o,r,i]}(i,a,o)}le[te.Up]=E.getIndex(0,1,0),le[te.Down]=E.getIndex(0,-1,0),le[te.North]=E.getIndex(0,0,1),le[te.South]=E.getIndex(0,0,-1),le[te.East]=E.getIndex(1,0,0),le[te.West]=E.getIndex(-1,0,0);const ue=new C.$;function ge(e,t){return ue.createLightValue(ue.getS(e[0])*t[0]+ue.getS(e[1])*t[1]+ue.getS(e[2])*t[2]+ue.getS(e[3])*t[3],ue.getR(e[0])*t[0]+ue.getR(e[1])*t[1]+ue.getR(e[2])*t[2]+ue.getR(e[3])*t[3],ue.getG(e[0])*t[0]+ue.getG(e[1])*t[1]+ue.getG(e[2])*t[2]+ue.getG(e[3])*t[3],ue.getB(e[0])*t[0]+ue.getB(e[1])*t[1]+ue.getB(e[2])*t[2]+ue.getB(e[3])*t[3])}const fe=(e,t)=>{const s=[];for(const r of ee){const{x:i,y:a,z:o}=e.positions.vertices[r];s[r]=ce(t,i,a,o)}return s};class me{vertices;constructor(e){this.vertices=e}getAsArray(){return[this.vertices[J.TopRight],this.vertices[J.TopLeft],this.vertices[J.BottomLeft],this.vertices[J.BottomRight]]}setVertex(e,t){this.vertices[e]=t}getVertex(e){return this.vertices[e]}setAll(e){this.vertices[J.TopRight]=e,this.vertices[J.TopLeft]=e,this.vertices[J.BottomLeft]=e,this.vertices[J.BottomRight]=e}set(e,t,s,r){this.vertices[J.TopRight]=e,this.vertices[J.TopLeft]=t,this.vertices[J.BottomLeft]=s,this.vertices[J.BottomRight]=r}isEqualTo(e,t,s,r){return this.vertices[J.TopRight]==e&&this.vertices[J.TopLeft]==t&&this.vertices[J.BottomLeft]==s&&this.vertices[J.BottomRight]==r}isAllEqualTo(e){return this.vertices[J.TopRight]==e&&this.vertices[J.TopLeft]==e&&this.vertices[J.BottomLeft]==e&&this.vertices[J.BottomRight]==e}[Symbol.iterator](){let e=J.TopRight;const t=this.vertices;return{next:()=>e<J.BottomRight?{value:t[e++],done:!1}:{value:void 0,done:!0}}}clone(){return new me([structuredClone(this.vertices[J.TopRight]),structuredClone(this.vertices[J.TopLeft]),structuredClone(this.vertices[J.BottomLeft]),structuredClone(this.vertices[J.BottomRight])])}}class pe extends me{vertices;constructor(e=[R.Az.Create(),R.Az.Create(),R.Az.Create(),R.Az.Create()]){super(e),this.vertices=e}setFromQuadData(e){R.Az.Copy(this.vertices[J.TopRight],e.vertices[J.TopRight]),R.Az.Copy(this.vertices[J.TopLeft],e.vertices[J.TopLeft]),R.Az.Copy(this.vertices[J.BottomLeft],e.vertices[J.BottomLeft]),R.Az.Copy(this.vertices[J.BottomRight],e.vertices[J.BottomRight])}addToVertex(e,t){R.Az.AddInPlace(this.vertices[e],t)}subtractFromVertex(e,t){R.Az.SubtractInPlace(this.vertices[e],t)}addAll(e){this.addToVertex(J.TopRight,e),this.addToVertex(J.TopLeft,e),this.addToVertex(J.BottomLeft,e),this.addToVertex(J.BottomRight,e)}subtractAll(e){this.subtractFromVertex(J.TopRight,e),this.subtractFromVertex(J.TopLeft,e),this.subtractFromVertex(J.BottomLeft,e),this.subtractFromVertex(J.BottomRight,e)}isEqualTo(e,t,s,r){return R.Az.Equals(this.vertices[J.TopRight],e)&&R.Az.Equals(this.vertices[J.TopLeft],t)&&R.Az.Equals(this.vertices[J.BottomLeft],s)&&R.Az.Equals(this.vertices[J.BottomRight],r)}isAllEqualTo(e){return R.Az.Equals(this.vertices[J.TopRight],e)&&R.Az.Equals(this.vertices[J.TopLeft],e)&&R.Az.Equals(this.vertices[J.BottomLeft],e)&&R.Az.Equals(this.vertices[J.BottomRight],e)}clone(){return new pe([R.Az.Clone(this.vertices[J.TopRight]),R.Az.Clone(this.vertices[J.TopLeft]),R.Az.Clone(this.vertices[J.BottomLeft]),R.Az.Clone(this.vertices[J.BottomRight])])}}class ye extends me{vertices;constructor(e=[R.xt.Create(),R.xt.Create(),R.xt.Create(),R.xt.Create()]){super(e),this.vertices=e}setFromQuadData(e){R.xt.Copy(this.vertices[J.TopRight],e.vertices[J.TopRight]),R.xt.Copy(this.vertices[J.TopLeft],e.vertices[J.TopLeft]),R.xt.Copy(this.vertices[J.BottomLeft],e.vertices[J.BottomLeft]),R.xt.Copy(this.vertices[J.BottomRight],e.vertices[J.BottomRight])}addToVertex(e,t){R.xt.AddInPlace(this.vertices[e],t)}subtractFromVertex(e,t){R.xt.SubtractInPlace(this.vertices[e],t)}addAll(e){this.addToVertex(J.TopRight,e),this.addToVertex(J.TopLeft,e),this.addToVertex(J.BottomLeft,e),this.addToVertex(J.BottomRight,e)}subtractAll(e){this.subtractFromVertex(J.TopRight,e),this.subtractFromVertex(J.TopLeft,e),this.subtractFromVertex(J.BottomLeft,e),this.subtractFromVertex(J.BottomRight,e)}isEqualTo(e,t,s,r){return R.xt.Equals(this.vertices[J.TopRight],e)&&R.xt.Equals(this.vertices[J.TopLeft],t)&&R.xt.Equals(this.vertices[J.BottomLeft],s)&&R.xt.Equals(this.vertices[J.BottomRight],r)}isAllEqualTo(e){return R.xt.Equals(this.vertices[J.TopRight],e)&&R.xt.Equals(this.vertices[J.TopLeft],e)&&R.xt.Equals(this.vertices[J.BottomLeft],e)&&R.xt.Equals(this.vertices[J.BottomRight],e)}clone(){return new ye([R.xt.Clone(this.vertices[J.TopRight]),R.xt.Clone(this.vertices[J.TopLeft]),R.xt.Clone(this.vertices[J.BottomLeft]),R.xt.Clone(this.vertices[J.BottomRight])])}}class xe extends me{vertices;constructor(e=[0,0,0,0]){super(e),this.vertices=e}setFromQuadData(e){this.vertices[J.TopRight]=e.vertices[J.TopRight],this.vertices[J.TopLeft]=e.vertices[J.TopLeft],this.vertices[J.BottomLeft]=e.vertices[J.BottomLeft],this.vertices[J.BottomRight]=e.vertices[J.BottomRight]}subtractFromVertex(e,t){this.vertices[e]-=t}addAll(e){this.vertices[J.TopRight]+=e,this.vertices[J.TopLeft]+=e,this.vertices[J.BottomLeft]+=e,this.vertices[J.BottomRight]+=e}add(e,t,s,r){this.vertices[J.TopRight]+=e,this.vertices[J.TopLeft]+=t,this.vertices[J.BottomLeft]+=s,this.vertices[J.BottomRight]+=r}subtractAll(e){this.vertices[J.TopRight]-=e,this.vertices[J.TopLeft]-=e,this.vertices[J.BottomLeft]-=e,this.vertices[J.BottomRight]-=e}subtract(e,t,s,r){this.vertices[J.TopRight]+=e,this.vertices[J.TopLeft]+=t,this.vertices[J.BottomLeft]+=s,this.vertices[J.BottomRight]+=r}isGreaterThan(e,t,s,r){return!(this.vertices[J.TopRight]<e||this.vertices[J.TopLeft]<t||this.vertices[J.BottomLeft]<s||this.vertices[J.BottomRight]<r)}isAllGreaterThan(e){return!(this.vertices[J.TopRight]<e||this.vertices[J.TopLeft]<e||this.vertices[J.BottomLeft]<e||this.vertices[J.BottomRight]<e)}isLessThan(e,t,s,r){return!(this.vertices[J.TopRight]>e||this.vertices[J.TopLeft]>t||this.vertices[J.BottomLeft]>s||this.vertices[J.BottomRight]>r)}isAllLessThan(e){return!(this.vertices[J.TopRight]>e||this.vertices[J.TopLeft]>e||this.vertices[J.BottomLeft]>e||this.vertices[J.BottomRight]>e)}clone(){return new xe([this.vertices[J.TopRight],this.vertices[J.TopLeft],this.vertices[J.BottomLeft],this.vertices[J.BottomRight]])}}class ve{static FullUVs=Object.freeze([[1,1],[0,1],[0,0],[1,0]]);static RotateUvs(e,t){const s=R.Jd.RotationZ(t),r=[.5,.5];return[R.xt.RotateAroundPivotArray(s,e[0],r),R.xt.RotateAroundPivotArray(s,e[1],r),R.xt.RotateAroundPivotArray(s,e[2],r),R.xt.RotateAroundPivotArray(s,e[3],r)]}static Create(e,t,s,r){return new ve({positions:e,uvs:t,doubleSided:s,orientation:r})}static RotateVertices90Degrees(e,t=1){for(;t--;)e=[e[1],e[2],e[3],e[0]];return e}static GetQuadNormalRightHanded(e,t,s,r){const i=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],a=[s[0]-e[0],s[1]-e[1],s[2]-e[2]],o=R.Az.NormalizeArray(R.Az.CrossArray(i,a)),n=[s[0]-e[0],s[1]-e[1],s[2]-e[2]],l=[r[0]-e[0],r[1]-e[1],r[2]-e[2]],d=R.Az.NormalizeArray(R.Az.CrossArray(n,l)),h=[R.Az.NormalizeArray([(o[0]+d[0])/2,(o[1]+d[1])/2,(o[2]+d[2])/2]),o,R.Az.NormalizeArray([(o[0]+d[0])/2,(o[1]+d[1])/2,(o[2]+d[2])/2]),d];for(let e=0;e<h.length;e++){const t=h[e];for(let e=0;e<3;e++)0===Math.abs(t[e])&&(t[e]=0)}return h}static GetQuadNormalLeftHanded(e,t,s,r){const i=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],a=[s[0]-e[0],s[1]-e[1],s[2]-e[2]],o=R.Az.MultiplyScalarArray(R.Az.NormalizeArray(R.Az.CrossArray(i,a)),-1),n=[s[0]-e[0],s[1]-e[1],s[2]-e[2]],l=[r[0]-e[0],r[1]-e[1],r[2]-e[2]],d=R.Az.MultiplyScalarArray(R.Az.NormalizeArray(R.Az.CrossArray(n,l)),-1),h=[R.Az.NormalizeArray([(o[0]+d[0])/2,(o[1]+d[1])/2,(o[2]+d[2])/2]),o,R.Az.NormalizeArray([(o[0]+d[0])/2,(o[1]+d[1])/2,(o[2]+d[2])/2]),d];for(let e=0;e<h.length;e++){const t=h[e];for(let e=0;e<3;e++)0===Math.abs(t[e])&&(t[e]=0)}return h}static CalculateQuadPoints(e,t){const s=e.map(((e,s)=>t[s]!==e?s:-1)).filter((e=>-1!==e));let r,i;const a=t,o=e;s.includes(0)&&s.includes(2)?(r=[e[0],e[1],t[2]],i=[t[0],e[1],e[2]]):s.includes(0)&&s.includes(1)?(r=[e[0],t[1],e[2]],i=[t[0],e[1],e[2]]):s.includes(1)&&s.includes(2)&&(r=[e[0],t[1],e[2]],i=[e[0],e[1],t[2]]);const n=[t[0]-e[0],t[1]-e[1],t[2]-e[2]];let l=[0,0,0];return 0===n[0]?l[0]=1:0===n[1]?l[1]=1:0===n[2]&&(l[2]=1),{points:[a,r,o,i],normal:l}}static OrderQuadVertices(e,t){const s={north:e=>[e[0],e[1]],south:e=>[e[0],e[1]],east:e=>[e[2],e[1]],west:e=>[e[2],e[1]],up:e=>[e[0],e[2]],down:e=>[e[0],e[2]]},r=e.map((e=>s[t](e))),i=[(r[0][0]+r[1][0]+r[2][0]+r[3][0])/4,(r[0][1]+r[1][1]+r[2][1]+r[3][1])/4],a=e=>Math.atan2(e[1]-i[1],e[0]-i[0]),o=e.map(((e,t)=>({vertex:e,angle:a(r[t])})));return o.sort(((e,t)=>e.angle-t.angle)),[o[2].vertex,o[3].vertex,o[0].vertex,o[1].vertex]}positions=new pe;normals=new pe;uvs=new ye;flip=!1;doubleSided=!1;orientation=0;constructor(e){e.positions&&this.setPositions(e.positions),e.uvs&&this.setUVs(e.uvs),e.doubleSided&&(this.doubleSided=e.doubleSided),void 0!==e.orientation&&(this.orientation=e.orientation)}setUVs([e,t,s,r]){return this.uvs.set(R.xt.FromArray(e),R.xt.FromArray(t),R.xt.FromArray(s),R.xt.FromArray(r)),this}scale(e,t,s){const r=R.Az.Create(e,t,s);for(const e of this.positions)R.Az.MultiplyInPlace(e,r);return this}transform(e,t,s){const r=R.Az.Create(e,t,s);for(const e of this.positions)R.Az.AddInPlace(e,r);return this}setPositions(e){if(2==e.length){const{points:t,normal:s}=ve.CalculateQuadPoints(e[0],e[1]);this.positions.set(R.Az.FromArray(t[0]),R.Az.FromArray(t[1]),R.Az.FromArray(t[2]),R.Az.FromArray(t[3])),this.normals.set(R.Az.FromArray(s),R.Az.FromArray(s),R.Az.FromArray(s),R.Az.FromArray(s))}if(4==e.length){const[t,s,r,i]=ve.GetQuadNormalLeftHanded(...e);this.positions.set(R.Az.FromArray(e[0]),R.Az.FromArray(e[1]),R.Az.FromArray(e[2]),R.Az.FromArray(e[3])),this.normals.set(R.Az.FromArray(t),R.Az.FromArray(s),R.Az.FromArray(r),R.Az.FromArray(i))}return this}clone(){return ve.Create(this.positions.getAsArray().map((e=>R.Az.ToArray(e))),this.uvs.getAsArray().map((e=>R.xt.ToArray(e))))}}function be(e){return e*Math.PI/180}function we(e){let t=1/0,s=1/0,r=1/0,i=-1/0,a=-1/0,o=-1/0;for(let n=0;n<e.length;n++){const[l,d,h]=e[n];l<t&&(t=l),d<s&&(s=d),h<r&&(r=h),l>i&&(i=l),d>a&&(a=d),h>o&&(o=h)}return[[t,s,r],[i,a,o]]}function Ae(e,t){const s=[],r=R.Az.Create(...e[0]),i=R.Az.Create(...e[1]),a=[];a[te.Up]=ve.Create([[i.x,i.y,i.z],[r.x,i.y,i.z],[r.x,i.y,r.z],[i.x,i.y,r.z]]),a[te.Down]=ve.Create([[r.x,r.y,i.z],[i.x,r.y,i.z],[i.x,r.y,r.z],[r.x,r.y,r.z]]),a[te.North]=ve.Create([[r.x,i.y,i.z],[i.x,i.y,i.z],[i.x,r.y,i.z],[r.x,r.y,i.z]]),a[te.South]=ve.Create([[i.x,i.y,r.z],[r.x,i.y,r.z],[r.x,r.y,r.z],[i.x,r.y,r.z]]),a[te.East]=ve.Create([[i.x,i.y,i.z],[i.x,i.y,r.z],[i.x,r.y,r.z],[i.x,r.y,i.z]]),a[te.West]=ve.Create([[r.x,i.y,r.z],[r.x,i.y,i.z],[r.x,r.y,i.z],[r.x,r.y,r.z]]),function(e,t){const s=new Map;for(const t of e){const e=[t.positions.vertices[J.TopRight],t.positions.vertices[J.TopLeft],t.positions.vertices[J.BottomLeft],t.positions.vertices[J.BottomRight]];for(const t of e){const e=`${t.x},${t.y},${t.z}`;s.has(e)||s.set(e,{...t})}}const r=Array.from(s.values()),i={x:0,y:0,z:0};for(const e of r)i.x+=e.x,i.y+=e.y,i.z+=e.z;i.x/=r.length,i.y/=r.length,i.z/=r.length;let a=!1,o=1,n=1,l=1;if(t.scale){const[e,s,r]=t.scale;o=e,n=s,l=r,a=!0}if(t.flip){const[e,s,r]=t.flip;e&&(o*=-1),s&&(n*=-1),r&&(l*=-1),a=!0}const d=o*n*l;if(a)for(const e of r)e.x=i.x+(e.x-i.x)*o,e.y=i.y+(e.y-i.y)*n,e.z=i.z+(e.z-i.z)*l;if(t.rotation){const[e,s,a]=t.rotation,o=be(e),n=be(s),l=be(a),d=t.rotationPivot?{x:t.rotationPivot[0],y:t.rotationPivot[1],z:t.rotationPivot[2]}:i;for(const e of r){let t=e.x-d.x,s=e.y-d.y,r=e.z-d.z;if(o){const e=Math.cos(o),t=Math.sin(o),i=s*t+r*e;s=s*e-r*t,r=i}if(n){const e=Math.cos(n),s=Math.sin(n),i=-t*s+r*e;t=t*e+r*s,r=i}if(l){const e=Math.cos(l),r=Math.sin(l),i=t*r+s*e;t=t*e-s*r,s=i}e.x=t+d.x,e.y=s+d.y,e.z=r+d.z}}if(t.position){const[e,s,i]=t.position;for(const t of r)t.x+=e,t.y+=s,t.z+=i}for(const t of e){const e=[t.positions.vertices[J.TopRight],t.positions.vertices[J.TopLeft],t.positions.vertices[J.BottomLeft],t.positions.vertices[J.BottomRight]].map((e=>{const t=`${e.x},${e.y},${e.z}`;return s.get(t)}));d<0&&e.reverse(),t.setPositions(e.map((e=>R.Az.ToArray(e))))}}(a,t);const o=new Array(a.length);for(let e=0;e<a.length;e++){const t=[],s=a[e].positions.getAsArray();for(let e=0;e<4;e++)t.push([s[e].x,s[e].y,s[e].z]);o[e]=we(t)}return s[te.Up]=fe(a[te.Up],te.Up),s[te.Down]=fe(a[te.Down],te.Down),s[te.North]=fe(a[te.North],te.North),s[te.South]=fe(a[te.South],te.South),s[te.East]=fe(a[te.East],te.East),s[te.West]=fe(a[te.West],te.West),{quads:a,vertexWeights:s,quadBounds:o}}var Be;!function(e){e[e.Panel=1]="Panel",e[e.CrossPanel=2]="CrossPanel",e[e.Box=3]="Box"}(Be||(Be={}));class Ie{static AnimationStates={WindAffected:Be};static LightMask=65535;static AOMask=15;static AnimationMask=4095;static TextureIndexMax=65535;static createTextureIndex(e,t){let s=0;return s=s&~this.TextureIndexMax|e&this.TextureIndexMax,s=s&~(this.TextureIndexMax<<16)|(t&this.TextureIndexMax)<<16,s}static createAttribute(e,t,s){let r=0;return r=r&~this.LightMask|e&this.LightMask,r=r&~(this.AOMask<<16)|(t&this.AOMask)<<16,r=r&~(this.AnimationMask<<20)|(s&this.AnimationMask)<<20,r}}class Se{static VertexFloatSize=24;static VertexByteSize=4*this.VertexFloatSize;static PositionOffset=0;static NormalOffset=4;static TextureIndexOffset=8;static UVOffset=12;static ColorOffset=14;static VoxelDataOFfset=18;get positionX(){return this.data[this.trueIndex+Se.PositionOffset]}set positionX(e){this.data[this.trueIndex+Se.PositionOffset]=e}get positionY(){return this.data[this.trueIndex+Se.PositionOffset+1]}set positionY(e){this.data[this.trueIndex+Se.PositionOffset+1]=e}get positionZ(){return this.data[this.trueIndex+Se.PositionOffset+2]}set positionZ(e){this.data[this.trueIndex+Se.PositionOffset+2]=e}get normalX(){return this.data[this.trueIndex+Se.NormalOffset]}set normalX(e){this.data[this.trueIndex+Se.NormalOffset]=e}get normalY(){return this.data[this.trueIndex+Se.NormalOffset+1]}set normalY(e){this.data[this.trueIndex+Se.NormalOffset+1]=e}get normalZ(){return this.data[this.trueIndex+Se.NormalOffset+2]}set normalZ(e){this.data[this.trueIndex+Se.NormalOffset+2]=e}get voxelData(){return this.data[this.trueIndex+Se.VoxelDataOFfset]}set voxelData(e){this.data[this.trueIndex+Se.VoxelDataOFfset]=e}get textureIndexX(){return this.data[this.trueIndex+Se.TextureIndexOffset]}set textureIndexX(e){this.data[this.trueIndex+Se.TextureIndexOffset]=e}get textureIndexY(){return this.data[this.trueIndex+Se.TextureIndexOffset+1]}set textureIndexY(e){this.data[this.trueIndex+Se.TextureIndexOffset+1]=e}get textureIndexZ(){return this.data[this.trueIndex+Se.TextureIndexOffset+2]}set textureIndexZ(e){this.data[this.trueIndex+Se.TextureIndexOffset+2]=e}get uvX(){return this.data[this.trueIndex+Se.UVOffset]}set uvX(e){this.data[this.trueIndex+Se.UVOffset]=e}get uvY(){return this.data[this.trueIndex+Se.UVOffset+1]}set uvY(e){this.data[this.trueIndex+Se.UVOffset+1]=e}get colorR(){return this.data[this.trueIndex+Se.ColorOffset]}set colorR(e){this.data[this.trueIndex+Se.ColorOffset]=e}get colorG(){return this.data[this.trueIndex+Se.ColorOffset+1]}set colorG(e){this.data[this.trueIndex+Se.ColorOffset+1]=e}get colorB(){return this.data[this.trueIndex+Se.ColorOffset+2]}set colorB(e){this.data[this.trueIndex+Se.ColorOffset+2]=e}trueIndex=0;_index=0;data;get index(){return this._index}set index(e){this._index=e,this.trueIndex=e*Se.VertexFloatSize}constructor(e){e&&(this.data=e)}toJSON(){return{position:[this.positionX,this.positionY,this.positionZ],normal:[this.normalX,this.normalY,this.normalZ],voxelData:this.voxelData,textureIndex:[this.textureIndexX,this.textureIndexY,this.textureIndexZ],uv:[this.uvX,this.uvY],color:[this.colorR,this.colorG,this.colorB]}}}const Ce=new Se;class Te{static addQuad(e,t,s){if(!e.mesh)return;const r=e.vars.light,i=e.vars.ao,a=e.vars.animation,o=e.vars.textureIndex,n=e.vars.overlayTextures,l=s.positions.vertices[0],d=s.positions.vertices[1],h=s.positions.vertices[2],c=s.positions.vertices[3],u=s.normals.vertices[0],g=s.normals.vertices[1],f=s.normals.vertices[2],m=s.normals.vertices[3],p=Ie.createAttribute(r.vertices[J.TopRight],i.vertices[J.TopRight],a.vertices[J.TopRight]),y=Ie.createAttribute(r.vertices[J.TopLeft],i.vertices[J.TopLeft],a.vertices[J.TopLeft]),x=Ie.createAttribute(r.vertices[J.BottomLeft],i.vertices[J.BottomLeft],a.vertices[J.BottomLeft]),v=Ie.createAttribute(r.vertices[J.BottomRight],i.vertices[J.BottomRight],a.vertices[J.BottomRight]),b=e.mesh.indices;let w=e.mesh.indicieCount,A=s.doubleSided?2:1;const B=s.flip;let I=s.orientation;for(;A--;){const r=e.mesh.vertexCount;B||(e.mesh.buffer.setIndex(r),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,l,u,s.uvs.vertices[J.TopRight],p,o,n),e.mesh.buffer.setIndex(r+1),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,d,g,s.uvs.vertices[J.TopLeft],y,o,n),e.mesh.buffer.setIndex(r+2),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,h,f,s.uvs.vertices[J.BottomLeft],x,o,n),e.mesh.buffer.setIndex(r+3),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,c,m,s.uvs.vertices[J.BottomRight],v,o,n)),B&&(e.mesh.buffer.setIndex(r),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,d,g,s.uvs.vertices[J.TopLeft],y,o,n),e.mesh.buffer.setIndex(r+1),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,l,u,s.uvs.vertices[J.TopRight],p,o,n),e.mesh.buffer.setIndex(r+2),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,c,m,s.uvs.vertices[J.BottomRight],v,o,n),e.mesh.buffer.setIndex(r+3),Ce.data=e.mesh.buffer.currentArray,Ce.index=e.mesh.buffer.curentIndex,_e(e.mesh.buffer.curentIndex,e.mesh.buffer.currentArray,t,h,f,s.uvs.vertices[J.BottomLeft],x,o,n)),I||B?!I&&B&&(b.setIndex(w).currentArray[b.curentIndex]=r,b.setIndex(w+1).currentArray[b.curentIndex]=r+3,b.setIndex(w+2).currentArray[b.curentIndex]=r+2,b.setIndex(w+3).currentArray[b.curentIndex]=r+2,b.setIndex(w+4).currentArray[b.curentIndex]=r+1,b.setIndex(w+5).currentArray[b.curentIndex]=r):(b.setIndex(w).currentArray[b.curentIndex]=r,b.setIndex(w+1).currentArray[b.curentIndex]=r+1,b.setIndex(w+2).currentArray[b.curentIndex]=r+2,b.setIndex(w+3).currentArray[b.curentIndex]=r+2,b.setIndex(w+4).currentArray[b.curentIndex]=r+3,b.setIndex(w+5).currentArray[b.curentIndex]=r),I&&!B?(b.setIndex(w).currentArray[b.curentIndex]=r,b.setIndex(w+1).currentArray[b.curentIndex]=r+3,b.setIndex(w+2).currentArray[b.curentIndex]=r+2,b.setIndex(w+3).currentArray[b.curentIndex]=r+2,b.setIndex(w+4).currentArray[b.curentIndex]=r+1,b.setIndex(w+5).currentArray[b.curentIndex]=r):I&&B&&(b.setIndex(w).currentArray[b.curentIndex]=r,b.setIndex(w+1).currentArray[b.curentIndex]=r+1,b.setIndex(w+2).currentArray[b.curentIndex]=r+2,b.setIndex(w+3).currentArray[b.curentIndex]=r+2,b.setIndex(w+4).currentArray[b.curentIndex]=r+3,b.setIndex(w+5).currentArray[b.curentIndex]=r),e.mesh.addVerticies(4,6)}}}const _e=(e,t,s,r,i,a,o,n,l)=>{t[0+(e*=24)]=r.x+s.x,t[0+e+1]=r.y+s.y,t[0+e+2]=r.z+s.z,t[12+e]=a.x,t[12+e+1]=a.y,t[4+e]=i.x,t[4+e+1]=i.y,t[4+e+2]=i.z,t[8+e]=Ie.createTextureIndex(n,l.x),t[8+e+1]=Ie.createTextureIndex(l.y,l.z),t[8+e+2]=Ie.createTextureIndex(l.w,0),t[18+e]=o},ze=$.ArgIndexes;class Ve extends K{quads;quadBounds=[];vertexWeights;_wasAOShaded=!1;lightData=new C.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:e,vertexWeights:t,quadBounds:s}=Ae(this.data.points,this.transform);this.quads=e,this.vertexWeights=t,this.quadBounds=s}isExposed(e){const t=e+this.faceIndex,s=this.geomtry.faceCullMap[t];if(!s)return!0;const r=this.builder;for(let e=0;e<s.length;e++){const i=s[e],a=H[i],o=this.builder.space.getHash(r.nVoxel,r.position.x+a[0],r.position.y+a[1],r.position.z+a[2]);if(this.builder.space.foundHash[o]<2)continue;const n=this.builder.space.getGeomtry(o),l=this.builder.space.getConditionalGeomtry(o);if(n)for(let e=0;e<n.length;e++){const s=n[e];if(Ge.rulesless[s])continue;const r=this.geomtry.cullIndex.getValue(s,i,t);if(r>-1&&!this.builder.space.getConstructor(o)?.isShapeStateFaceTransparent(this.builder.space.modCache[o],this.builder.space.stateCache[o],s,r))return!1}if(l)for(let e=0;e<l.length;e++){const s=l[e];for(let e=0;e<s.length;e++){const r=s[e];if(Ge.rulesless[r])continue;const a=this.geomtry.cullIndex.getValue(r,i,t);if(a>-1&&!this.builder.space.getConstructor(o)?.isCondtionalStateFaceTransparent(this.builder.space.modCache[o],this.builder.space.stateCache[o],r,a))return!1}}}return!0}determineShading(e){const t=this.builder,s=t.lightData[e],r=this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),i=this.builder.vars.light,a=this.builder.vars.ao;for(let o=0;o<4;o++){if(a.vertices[o]=0,i.vertices[o]=ge(s,this.vertexWeights[e][o]),r)continue;const n=this.vertexIndex+4*e+o,l=this.geomtry.vertexHitMap[n];if(l)for(let e=0;e<l.length;e++){const s=l[e],r=H[s],i=this.builder.space.getHash(t.nVoxel,t.position.x+r[0],t.position.y+r[1],t.position.z+r[2]);if(this.builder.space.foundHash[i]<2||1===this.builder.space.noCastAO[i])continue;const d=this.builder.space.getGeomtry(i),h=this.builder.space.getConditionalGeomtry(i);if(!d&&!h)continue;let c=0,u=!1;if(d){c=d.length;for(let e=0;e<c;e++)if(this.geomtry.aoIndex.getValue(d[e],s,n)&&(this._wasAOShaded=!0,a.vertices[o]++,a.vertices[o]>4)){u=!0;break}}if(h&&!u){c=h.length;for(let e=0;e<c;e++){const t=h[e].length;for(let r=0;r<t;r++)if(this.geomtry.aoIndex.getValue(h[e][r],s,n)&&(this._wasAOShaded=!0,a.vertices[o]++,a.vertices[o]>4)){u=!0;break}}}}}}shouldFlip(){const e=this.builder.vars.ao;if(he(e.vertices[0],e.vertices[1],e.vertices[2],e.vertices[3])&&this._wasAOShaded)return!0;if(this._wasAOShaded)return!1;const t=this.builder.vars.light;return he(this.lightData.getS(t.vertices[0]),this.lightData.getS(t.vertices[1]),this.lightData.getS(t.vertices[2]),this.lightData.getS(t.vertices[3]))||he(this.lightData.sumRGB(t.vertices[0]),this.lightData.sumRGB(t.vertices[1]),this.lightData.sumRGB(t.vertices[2]),this.lightData.sumRGB(t.vertices[3]))}add(e){let t=!1;const s=this.builder;for(let r=0;r<6;r++)if(e[r][ze.Enabled]&&this.isExposed(r)){t=!0,s.calculateFaceData(r),this.determineShading(r);const i=e[r],a=this.quads[r];a.flip=this.shouldFlip()||i[ze.Fliped],s.vars.textureIndex=i[ze.Texture];const o=i[ze.UVs];a.uvs.vertices[0].x=o[0][0],a.uvs.vertices[0].y=o[0][1],a.uvs.vertices[1].x=o[1][0],a.uvs.vertices[1].y=o[1][1],a.uvs.vertices[2].x=o[2][0],a.uvs.vertices[2].y=o[2][1],a.uvs.vertices[3].x=o[3][0],a.uvs.vertices[3].y=o[3][1],Te.addQuad(s,this.builder.origin,a),s.updateBounds(this.quadBounds[r])}return this.builder.vars.ao.setAll(0),this.builder.vars.light.setAll(0),this._wasAOShaded=!1,t}}var De;!function(e){e[e.Enabled=0]="Enabled",e[e.Fliped=1]="Fliped",e[e.Texture=2]="Texture",e[e.Rotation=3]="Rotation",e[e.Transparent=4]="Transparent",e[e.DoubleSided=5]="DoubleSided",e[e.UVs=6]="UVs"}(De||(De={}));class Me{static ArgIndexes=De;static CreateArgs(){const e=[];return e[De.Enabled]=!0,e[De.Fliped]=!1,e[De.Texture]=0,e[De.Rotation]=0,e[De.Transparent]=!1,e[De.DoubleSided]=!1,e[De.UVs]=[[1,1],[0,1],[0,0],[1,0]],e}}function ke(e,t){const s=function(e,t){const s={...e.positions.vertices[J.TopRight]},r={...e.positions.vertices[J.TopLeft]},i={...e.positions.vertices[J.BottomLeft]},a={...e.positions.vertices[J.BottomRight]},o=[s,r,i,a],n={x:(s.x+r.x+i.x+a.x)/4,y:(s.y+r.y+i.y+a.y)/4,z:(s.z+r.z+i.z+a.z)/4};let l=1,d=1,h=1;if(t.scale){const[e,s,r]=t.scale;l=e,d=s,h=r}if(t.flip){const[e,s,r]=t.flip;e&&(l*=-1),s&&(d*=-1),r&&(h*=-1)}const c=l*d*h;for(const e of o)e.x=n.x+(e.x-n.x)*l,e.y=n.y+(e.y-n.y)*d,e.z=n.z+(e.z-n.z)*h;if(t.rotation){const[e,s,r]=t.rotation,i=be(e),a=be(s),l=be(r),d=t.rotationPivot?{x:t.rotationPivot[0],y:t.rotationPivot[1],z:t.rotationPivot[2]}:n;for(const e of o){let t=e.x-d.x,s=e.y-d.y,r=e.z-d.z;if(i){const e=Math.cos(i),t=Math.sin(i),a=s*t+r*e;s=s*e-r*t,r=a}if(a){const e=Math.cos(a),s=Math.sin(a),i=-t*s+r*e;t=t*e+r*s,r=i}if(l){const e=Math.cos(l),r=Math.sin(l),i=t*r+s*e;t=t*e-s*r,s=i}e.x=t+d.x,e.y=s+d.y,e.z=r+d.z}}if(t.position){const[e,s,r]=t.position;for(const t of o)t.x+=e,t.y+=s,t.z+=r}return c<0&&o.reverse(),ve.Create(o.map((e=>R.Az.ToArray(e))))}(ve.Create(e.points),t);s.orientation=0;const r=s.normals.getAsArray(),i=[0,0,0];for(let e=0;e<r.length;e++)i[0]+=r[e].x,i[1]+=r[e].y,i[2]+=r[e].z;i[0]/=r.length,i[1]/=r.length,i[2]/=r.length;const a=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);0!==a&&(i[0]/=a,i[1]/=a,i[2]/=a);const o=function(e){const[t,s,r]=e;let i=-1/0,a=[0,0,0];for(const e of[-1,0,1])for(const o of[-1,0,1])for(const n of[-1,0,1]){if(0===e&&0===o&&0===n)continue;const l=(t*e+s*o+r*n)/Math.sqrt(e*e+o*o+n*n);l>i&&(i=l,a=[e,o,n])}const o=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/o,a[1]/o,a[2]/o]}(i);let n=te.Up;return 1==o[0]&&(n=te.East),-1==o[0]&&(n=te.West),1==o[1]&&(n=te.Up),-1==o[1]&&(n=te.Down),1==o[2]&&(n=te.North),-1==o[2]&&(n=te.South),{quad:s,vertexWeights:fe(s,n),closestFace:n,quadBounds:we(s.positions.getAsArray().map((e=>R.Az.ToArray(e))))}}const Ne=Me.ArgIndexes;class Le extends K{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;closestFace;lightData=new C.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:e,quadBounds:t,closestFace:s,vertexWeights:r}=ke(this.data,this.transform);this.quad=e,this.quadBounds=t,this.vertexWeights=r,this.closestFace=s}isExposed(){const e=this.faceIndex,t=this.geomtry.faceCullMap[e];if(!t)return!0;const s=this.builder;for(let r=0;r<t.length;r++){const i=t[r],a=H[i],o=this.builder.space.getHash(s.nVoxel,s.position.x+a[0],s.position.y+a[1],s.position.z+a[2]),n=this.builder.space.getGeomtry(o),l=this.builder.space.getConditionalGeomtry(o);if(n)for(let t=0;t<n.length;t++){const s=this.geomtry.cullIndex.getValue(n[t],i,e);if(s>-1&&!this.builder.space.getConstructor(o)?.isShapeStateFaceTransparent(this.builder.space.modCache[o],this.builder.space.stateCache[o],n[t],s))return!1}if(l)for(let t=0;t<l.length;t++){const s=l[t];for(let r=0;r<s.length;r++){const a=this.geomtry.cullIndex.getValue(s[r],i,e);if(a>-1&&!this.builder.space.getConstructor(o)?.isCondtionalStateFaceTransparent(this.builder.space.modCache[o],this.builder.space.stateCache[o],s[t],a))return!1}}}return!0}determineShading(){const e=this.builder,t=e.lightData[te.Up],s=this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),r=e.vars.light,i=e.vars.ao;for(let a=0;a<4;a++){if(i.vertices[a]=0,r.vertices[a]=ge(t,this.vertexWeights[a]),s)continue;const o=this.vertexIndex+4+a,n=this.geomtry.vertexHitMap[o];if(n)for(let t=0;t<n.length;t++){const s=n[t],r=H[s],l=this.builder.space.getHash(e.nVoxel,e.position.x+r[0],e.position.y+r[1],e.position.z+r[2]);if(1===this.builder.space.noCastAO[l])continue;const d=this.builder.space.getGeomtry(l),h=this.builder.space.getConditionalGeomtry(l);if(!d&&!h)continue;let c=0,u=!1;if(d){c=d.length;for(let e=0;e<c;e++)if(this.geomtry.aoIndex.getValue(d[e],s,o)){i.vertices[a]=1,u=!0;break}}if(h){c=h.length;for(let e=0;e<c;e++){const t=h[e].length;for(let r=0;r<t;r++)if(this.geomtry.aoIndex.getValue(h[e][r],s,o)){i.vertices[a]=1;break}}}}}}shouldFlip(){const e=this.builder.vars.ao,t=this.builder.vars.light;return!!he(e.vertices[0],e.vertices[1],e.vertices[2],e.vertices[3])||he(this.lightData.getS(t.vertices[0]),this.lightData.getS(t.vertices[1]),this.lightData.getS(t.vertices[2]),this.lightData.getS(t.vertices[3]))||he(this.lightData.sumRGB(t.vertices[0]),this.lightData.sumRGB(t.vertices[1]),this.lightData.sumRGB(t.vertices[2]),this.lightData.sumRGB(t.vertices[3]))}add(e){if(!e[Ne.Enabled])return!1;if(!this.isExposed())return!1;this.builder.calculateFaceData(this.closestFace),this.determineShading();const t=this.quad;t.flip=this.shouldFlip()||e[Ne.Fliped],this.builder.vars.textureIndex=e[Ne.Texture],t.doubleSided=e[Ne.DoubleSided];const s=e[Ne.UVs];return t.uvs.vertices[0].x=s[0][0],t.uvs.vertices[0].y=s[0][1],t.uvs.vertices[1].x=s[1][0],t.uvs.vertices[1].y=s[1][1],t.uvs.vertices[2].x=s[2][0],t.uvs.vertices[2].y=s[2][1],t.uvs.vertices[3].x=s[3][0],t.uvs.vertices[3].y=s[3][1],Te.addQuad(this.builder,this.builder.origin,t),this.builder.updateBounds(this.quadBounds),this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),!0}}const Re=Me.ArgIndexes;class Fe extends K{quad;quadBounds=[[0,0,0],[0,0,0]];vertexWeights;closestFace;lightData=new C.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quad:e,closestFace:t,vertexWeights:s,quadBounds:r}=ke(this.data,this.transform);this.quad=e,this.quadBounds=r,this.vertexWeights=s,this.closestFace=t}determineShading(){const e=this.builder.lightData[te.Up],t=(this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),this.builder.vars.light),s=this.builder.vars.ao;for(let r=0;r<4;r++)s.vertices[r]=0,t.vertices[r]=ge(e,this.vertexWeights[r])}shouldFlip(){const e=this.builder.vars.light,t=this.builder.vars.ao;return!!he(t.vertices[0],t.vertices[1],t.vertices[2],t.vertices[3])||he(this.lightData.getS(e.vertices[0]),this.lightData.getS(e.vertices[1]),this.lightData.getS(e.vertices[2]),this.lightData.getS(e.vertices[3]))||he(this.lightData.sumRGB(e.vertices[0]),this.lightData.sumRGB(e.vertices[1]),this.lightData.sumRGB(e.vertices[2]),this.lightData.sumRGB(e.vertices[3]))}add(e){if(!e[Re.Enabled])return!1;const t=this.builder;t.calculateFaceData(this.closestFace),this.determineShading();const s=this.quad;s.flip=this.shouldFlip()||e[Re.Fliped],t.vars.textureIndex=e[Re.Texture],s.doubleSided=e[Re.DoubleSided];const r=e[Re.UVs];return s.uvs.vertices[0].x=r[0][0],s.uvs.vertices[0].y=r[0][1],s.uvs.vertices[1].x=r[1][0],s.uvs.vertices[1].y=r[1][1],s.uvs.vertices[2].x=r[2][0],s.uvs.vertices[2].y=r[2][1],s.uvs.vertices[3].x=r[3][0],s.uvs.vertices[3].y=r[3][1],Te.addQuad(t,t.position,s),this.builder.updateBounds(this.quadBounds),this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),!0}}const Ue=$.ArgIndexes;class Pe extends K{quads;quadBounds=[];vertexWeights;lightData=new C.$;init(){this.faceCount=6,this.vertexCount=4*this.faceCount;const{quads:e,vertexWeights:t,quadBounds:s}=Ae(this.data.points,this.transform);this.quads=e,this.quadBounds=s,this.vertexWeights=t}determineShading(e){const t=this.builder.lightData[e],s=(this.builder.voxel.isLightSource()||this.builder.voxel.noAO(),this.builder.vars.light),r=this.builder.vars.ao;for(let i=0;i<4;i++)r.vertices[i]=0,s.vertices[i]=ge(t,this.vertexWeights[e][i])}shouldFlip(){const e=this.builder.vars.light,t=this.builder.vars.ao;return!!he(t.vertices[0],t.vertices[1],t.vertices[2],t.vertices[3])||he(this.lightData.getS(e.vertices[0]),this.lightData.getS(e.vertices[1]),this.lightData.getS(e.vertices[2]),this.lightData.getS(e.vertices[3]))||he(this.lightData.sumRGB(e.vertices[0]),this.lightData.sumRGB(e.vertices[1]),this.lightData.sumRGB(e.vertices[2]),this.lightData.sumRGB(e.vertices[3]))}add(e){const t=this.builder;let s=!1;for(let r=0;r<6;r++)if(e[r][Ue.Enabled]){s=!0,t.calculateFaceData(r),this.determineShading(r);const i=e[r],a=this.quads[r];a.flip=this.shouldFlip()||i[Ue.Fliped],t.vars.textureIndex=i[Ue.Texture];const o=i[Ue.UVs];a.uvs.vertices[0].x=o[0][0],a.uvs.vertices[0].y=o[0][1],a.uvs.vertices[1].x=o[1][0],a.uvs.vertices[1].y=o[1][1],a.uvs.vertices[2].x=o[2][0],a.uvs.vertices[2].y=o[2][1],a.uvs.vertices[3].x=o[3][0],a.uvs.vertices[3].y=o[3][1],Te.addQuad(t,t.position,a),this.builder.updateBounds(this.quadBounds[r])}return this.builder.vars.light.setAll(0),this.builder.vars.ao.setAll(0),s}}class Ee{geometryPaletteId;nodes=[];faceCullMap;vertexHitMap;cullIndex;aoIndex;constructor(e,t){this.geometryPaletteId=e;for(const s of t.nodes)if("custom"==s.node.type){const t=new(Ge.getCustomNode(s.node.id))(e,this,s.node,s.tranform);t.init(),this.nodes.push(t)}if(t?.ruleless)for(const s of t.nodes){if("box"==s.node.type){const t=new Pe(e,this,s.node,s.tranform);t.init(),this.nodes.push(t)}if("quad"==s.node.type){const t=new Fe(e,this,s.node,s.tranform);t.init(),this.nodes.push(t)}}else{this.faceCullMap=t.faceCullMap,this.vertexHitMap=t.vertexHitMap,this.cullIndex=new Q(t.cullIndex),this.aoIndex=new W(t.aoIndex);for(const s of t.nodes){if("box"==s.node.type){const t=new Ve(e,this,s.node,s.tranform);t.init(),this.nodes.push(t)}if("quad"==s.node.type){const t=new Le(e,this,s.node,s.tranform);t.init(),this.nodes.push(t)}}}let s=0,r=0;for(const e of this.nodes)e.faceIndex=s,e.vertexIndex=r,s+=e.faceCount,r+=e.vertexCount}}var He=s(18556);class Ge{static geometryPalette;static geometry=[];static rulesless=[];static setGeometryPalette(e){this.geometryPalette=new P.N(e)}static modelData=new Map;static customNodes=new Map;static registerModels(e){e.forEach((e=>this.modelData.set(e.id,e)))}static registerCustomNode(e,t){this.customNodes.set(e,t)}static getCustomNode(e){const t=this.customNodes.get(e);if(!t)throw new Error(`Custom geometry node [${e}] does not exist.`);return t}static constructorsPaltte=[];static constructors=new Map;static getConstructor(e){return this.constructors.get(e)}static registerVoxel(e){if(Array.isArray(e))for(const t of e)this.constructors.set(t.id,t),this.constructorsPaltte[He.A.voxels.getNumberId(t.id)]=t;else this.constructorsPaltte[He.A.voxels.getNumberId(e.id)]=e,this.constructors.set(e.id,e)}static registerGeometry(e){for(const t of e){const e=this.geometryPalette.getNumberId(t.id);this.geometry[e]=new Ee(e,t),1==t.ruleless?this.rulesless[e]=!0:this.rulesless[e]=!1}}}var Oe=s(19305),Qe=s(92287);class Ye{bounds;foundHash;voxelCache;modCache;stateCache;conditonalStateCache;noCastAO;offset=[0,0,0];voxelCursor=new Oe.x;constructor(e){this.bounds=e;const t=e.x*e.y*e.z;this.foundHash=new Uint8Array(t),this.voxelCache=new Uint16Array(t),this.modCache=new Int32Array(t),this.stateCache=new Int32Array(t),this.conditonalStateCache=new Int32Array(t),this.noCastAO=new Uint8Array(t)}start(e,t,s){this.offset[0]=e,this.offset[1]=t,this.offset[2]=s,this.foundHash.fill(0),this.voxelCache.fill(0),this.modCache.fill(-1),this.stateCache.fill(-1),this.conditonalStateCache.fill(-1),this.noCastAO.fill(0)}getIndex(e,t,s){return(0,Qe.BN)(e-this.offset[0],t-this.offset[1],s-this.offset[2],this.bounds.x,this.bounds.y,this.bounds.z)}getConstructor(e){return this.foundHash[e]<2?null:Ge.constructorsPaltte[this.voxelCache[e]]}getGeomtry(e){return!(this.foundHash[e]<2)&&Ge.constructorsPaltte[this.voxelCache[e]].data.shapeStateGeometryMap[this.stateCache[e]]}getConditionalGeomtry(e){return!(this.foundHash[e]<2)&&Ge.constructorsPaltte[this.voxelCache[e]].data.condiotnalShapeStateGeometryMap[this.conditonalStateCache[e]]}getHash(e,t,s,r){const i=this.getIndex(t,s,r);return 0==this.foundHash[i]&&this.hashState(e,i,t,s,r),i}hashState(e,t,s,r,i){if(1==this.foundHash[t])return-1;if(2==this.foundHash[t])return this.stateCache[t];const a=e.getVoxel(s,r,i);if(!a||!a.isRenderable())return this.foundHash[t]=1,-1;const o=a.getId(),n=Ge.constructorsPaltte[o];if(!n)return this.foundHash[t]=1,-1;this.voxelCache[t]=o,this.foundHash[t]=2,this.noCastAO[t]=a.isLightSource()||a.noAO()?1:0;const l=n.shapeStateTree.getState(a.getState());this.stateCache[t]=l;const d=n.modTree.getState(a.getMod());this.modCache[t]=d,this.voxelCursor.copy(a).process(),n.schema.position.x=s,n.schema.position.y=r,n.schema.position.z=i,n.schema.voxel=this.voxelCursor,n.schema.dataCursor=e;const h=n.condtioanlShapeStateTree.getState();return this.conditonalStateCache[t]=h,1}}new Se;const Xe=new Float32Array([1/0])[0];class Ze{levels;constructor(e){this.levels=e}getLevelSize(e){if(e<0||e>=this.levels)throw new Error("Invalid level");return 1<<e}getIndexAtLevel(e,t){if(e<0||e>=this.levels)throw new Error("Invalid level");const s=this.getLevelSize(e);if(t<0||t>=s)throw new Error("Invalid node index at the given level");return(1<<e)-1+t}getLevelAndIndex(e){const t=(1<<this.levels)-1;if(e<0||e>=t)throw new Error("Invalid node index");const s=Math.floor(Math.log2(e+1));return[s,e-((1<<s)-1)]}getLeftChildAtLevel(e,t){if(e+1>=this.levels)return-1;const s=this.getIndexAtLevel(e,t);return this.getLeftChild(s)}getRightChildAtLevel(e,t){if(e+1>=this.levels)return-1;const s=this.getIndexAtLevel(e,t);return this.getRightChild(s)}getParentAtLevel(e,t){if(0===e)return-1;const s=this.getIndexAtLevel(e,t);return this.getParent(s)}getLeftChild(e){const t=2*e+1;return t<(1<<this.levels)-1?t:-1}getRightChild(e){const t=2*e+2;return t<(1<<this.levels)-1?t:-1}getParent(e){return 0===e?-1:Math.floor((e-1)/2)}getTotalSize(){return(1<<this.levels)-1}}class We{data;get minX(){return this.data[this.trueIndex]}get minY(){return this.data[this.trueIndex+1]}get minZ(){return this.data[this.trueIndex+2]}get maxX(){return this.data[this.trueIndex+4]}get maxY(){return this.data[this.trueIndex+5]}get maxZ(){return this.data[this.trueIndex+6]}get voxelIndex(){return this.data[this.trueIndex+3]}get active(){return this.data[this.trueIndex+3]}get nodeType(){return this.data[this.trueIndex+7]}trueIndex=0;index=0;setIndex(e){this.trueIndex=8*e}constructor(e){this.data=e}setActive(){this.data[this.trueIndex+3]=1}setVoxelIndex(e){this.data[this.trueIndex+3]=e}setInnerNode(){this.data[this.trueIndex+7]=1}setGeomtryNode(){this.data[this.trueIndex+7]=2}updateMin(e,t,s){const r=this.trueIndex,i=this.trueIndex+1,a=this.trueIndex+2;(e<this.data[r]||this.data[r]==-Xe)&&(this.data[r]=e),(t<this.data[i]||this.data[i]==-Xe)&&(this.data[i]=t),(s<this.data[a]||this.data[a]==-Xe)&&(this.data[a]=s)}updateMax(e,t,s){const r=this.trueIndex+4,i=this.trueIndex+5,a=this.trueIndex+6;(e>this.data[r]||this.data[r]==-Xe)&&(this.data[r]=e),(t>this.data[i]||this.data[i]==-Xe)&&(this.data[i]=t),(s>this.data[a]||this.data[a]==-Xe)&&(this.data[a]=s)}}class qe{static AABBStructByteSize=32;treeIndex=new Ze(13);tree=new Float32Array(new ArrayBuffer(this.treeIndex.getTotalSize()*qe.AABBStructByteSize));structCursor=new We(this.tree);indices=new Uint32Array(2*this.treeIndex.getLevelSize(12));reset(){this.tree.fill(-Xe),this.indices.fill(0)}updateVoxel(e,t,s,r,i,a,o,n,l,d,h,c){const u=I.k.voxel.getIndex(e,t,s),g=this.treeIndex.getIndexAtLevel(12,u);this.indices[2*u]=i,this.indices[2*u+1]=a,this.structCursor.setIndex(g),this.structCursor.updateMin(o,n,l),this.structCursor.updateMax(d,h,c),this.structCursor.setVoxelIndex(u),this.structCursor.setGeomtryNode();let f=g;for(let e=1;e<13;e++){let e=this.treeIndex.getParent(f);this.structCursor.setIndex(e),this.structCursor.updateMin(o,n,l),this.structCursor.updateMax(d,h,c),this.structCursor.setActive(),this.structCursor.setInnerNode(),f=e}}}const je=new C.$;class $e{vertexFloatSize;sectorVertexSize;_buffers=[];sectorSize=0;constructor(e,t,s=4){this.vertexFloatSize=e,this.sectorVertexSize=t,this.sectorSize=e*t;for(let e=0;e<s;e++)this._buffers.push(new Float32Array(this.sectorSize))}currentArray;curentIndex=0;_index=0;setIndex(e){this._index=e;const t=Math.floor(e*this.vertexFloatSize/this.sectorSize);this._buffers[t]||(this._buffers[t]=new Float32Array(this.sectorSize)),this.curentIndex=(e*this.vertexFloatSize-t*this.sectorSize)/this.vertexFloatSize,this.currentArray=this._buffers[t]}}class Ke{sectorSize;_buffers=[];constructor(e,t=4){this.sectorSize=e;for(let s=0;s<t;s++)this._buffers.push(new Uint32Array(e))}currentArray;curentIndex=0;_index=0;setIndex(e){this._index=e;const t=Math.floor(e/this.sectorSize);return this._buffers[t]||(this._buffers[t]=new Uint32Array(this.sectorSize)),this.curentIndex=e-t*this.sectorSize,this.currentArray=this._buffers[t],this}}class Je{indicieCount=0;vertexCount=0;minBounds=R.Az.Create(1/0,1/0,1/0);maxBounds=R.Az.Create(-1/0,-1/0,-1/0);buffer=new $e(Se.VertexFloatSize,1e3);indices=new Ke(1e3);addVerticies(e,t){this.vertexCount+=e,this.indicieCount+=t}clear(){this.indicieCount=0,this.vertexCount=0,this.minBounds.x=1/0,this.minBounds.y=1/0,this.minBounds.z=1/0,this.maxBounds.x=-1/0,this.maxBounds.y=-1/0,this.maxBounds.z=-1/0}}class et{faceFlipped=!1;textureIndex=0;overlayTextures=R.ZS.Create();light=new xe;ao=new xe;animation=new xe;level=new xe;reset(){this.faceFlipped=!1,this.textureIndex=0,this.overlayTextures.x=0,this.overlayTextures.y=0,this.overlayTextures.z=0}}class tt{id;materialIndex;space;voxel;nVoxel;position=R.Az.Create();origin=R.Az.Create();mesh=new Je;bvhTool=null;vars=new et;dataCalculated;condiotnalGeometryData;lightData;effects;constructor(e,t){this.id=e,this.materialIndex=t,this.dataCalculated=[];for(const e of se)this.dataCalculated[e]=!1;this.condiotnalGeometryData=[];for(const e of se)this.condiotnalGeometryData[e]=[],this.condiotnalGeometryData[e][J.TopRight]=[[],[],[]],this.condiotnalGeometryData[e][J.TopLeft]=[[],[],[]],this.condiotnalGeometryData[e][J.BottomLeft]=[[],[],[]],this.condiotnalGeometryData[e][J.BottomRight]=[[],[],[]];this.lightData=[];for(const e of se)this.lightData[e]=[],this.lightData[e][J.TopRight]=0,this.lightData[e][J.TopLeft]=0,this.lightData[e][J.BottomLeft]=0,this.lightData[e][J.BottomRight]=0}bounds={min:[0,0,0],max:[0,0,0]};_indexStart=0;startConstruction(){this._indexStart=this.mesh.indicieCount,this.bounds.min[0]=1/0,this.bounds.min[1]=1/0,this.bounds.min[2]=1/0,this.bounds.max[0]=-1/0,this.bounds.max[1]=-1/0,this.bounds.max[2]=-1/0,this._boundsUpdate=!0}endConstruction(){if(this.vars.reset(),this.bvhTool){if(!this._boundsUpdate)return!1;this.bvhTool.updateVoxel(this.position.x,this.position.y,this.position.z,this._indexStart,this.materialIndex,this.mesh.indicieCount,this.bounds.min[0],this.bounds.min[1],this.bounds.min[2],this.bounds.max[0],this.bounds.max[1],this.bounds.max[2]),this.bvhTool.structCursor.setIndex(0),this.mesh.minBounds.x=this.bvhTool.structCursor.minX,this.mesh.minBounds.y=this.bvhTool.structCursor.minY,this.mesh.minBounds.z=this.bvhTool.structCursor.minZ,this.mesh.maxBounds.x=this.bvhTool.structCursor.maxX,this.mesh.maxBounds.y=this.bvhTool.structCursor.maxY,this.mesh.maxBounds.z=this.bvhTool.structCursor.maxZ}return!0}_boundsUpdate=!1;updateBounds(e){const t=this.origin;t.x+e[0][0]<this.bounds.min[0]&&(this.bounds.min[0]=t.x+e[0][0]),t.y+e[0][1]<this.bounds.min[1]&&(this.bounds.min[1]=t.y+e[0][1]),t.z+e[0][2]<this.bounds.min[2]&&(this.bounds.min[2]=t.z+e[0][2]),t.x+e[1][0]>this.bounds.max[0]&&(this.bounds.max[0]=t.x+e[1][0]),t.y+e[1][1]>this.bounds.max[1]&&(this.bounds.max[1]=t.y+e[1][1]),t.z+e[1][2]>this.bounds.max[2]&&(this.bounds.max[2]=t.z+e[1][2]),this._boundsUpdate=!0}calculateFaceData(e){if(this.dataCalculated[e])return!0;!function(e,t){const s=t.position.x,r=t.position.y,i=t.position.z,a=t.lightData[e],o=t.nVoxel,n=ie[e];let l=0;l=t.voxel.isLightSource()?t.voxel.getLightSourceValue():o.getVoxel(s+re[e][0],r+re[e][1],i+re[e][2])?.getLight()||0,l<0&&(l=0);const d=je.getS(l),h=je.getR(l),c=je.getG(l),u=je.getB(l);for(let e=0;e<4;e++){a[e]=l;let t=d,g=h,f=c,m=u;for(let a=0;a<9;a+=3){const l=o.getVoxel(n[e][a]+s,n[e][a+1]+r,n[e][a+2]+i)?.getLight()||-1;if(l<=0)continue;let d=je.getS(l),h=je.getR(l),c=je.getG(l),u=je.getB(l);t<d&&(t=d),g<h&&(g=h),f<c&&(f=c),m<u&&(m=u)}a[e]=je.createLightValue(t,g,f,m)}}(e,this),this.dataCalculated[e]=!0}clearCalculatedData(){this.dataCalculated[te.Up]=!1,this.dataCalculated[te.Down]=!1,this.dataCalculated[te.North]=!1,this.dataCalculated[te.South]=!1,this.dataCalculated[te.East]=!1,this.dataCalculated[te.West]=!1}clear(){return this.vars.reset(),this.mesh.clear(),this}}class st{static meshersMap=new Map;static meshers=[];static register(e){for(let t=0;t<e.length;t++){const s=new tt(e[t],t);this.meshersMap.set(e[t],s),this.meshers[t]=s}}}const rt=new F,it=new p.p;let at;const ot=new qe;function nt(e,t,s,r){let i=!1;const a=Ge.constructorsPaltte[r.getId()],o=a.builder;return o.origin.x=rt._voxelPosition.x,o.origin.y=rt._voxelPosition.y,o.origin.z=rt._voxelPosition.z,o.position.x=e,o.position.y=t,o.position.z=s,o.voxel=r,o.nVoxel=it,o.startConstruction(),i=a.process(),o.endConstruction(),i}const lt=R.Az.Create(5,5,5);function dt(e,t=[]){at||(at=new Ye({x:I.k.section.bounds.x+lt.x,y:I.k.section.bounds.y+lt.y,z:I.k.section.bounds.z+lt.z}));const s=n._.sectors.getAt(e);if(!s)return null;const r=s.getSection(e[1],e[2],e[3]),[i,a,o]=r.getPosition();it.setFocalPoint(...e),rt.setSection(...e);let[l,d]=r.getMinMax();if(l==1/0&&d==-1/0)return r.setDirty(!1),r.setInProgress(!1),null;at.start(i-(lt.x-1),a-(lt.y-1),o-(lt.z-1)),ot.reset();const h={};for(let e=0;e<st.meshers.length;e++){const t=st.meshers[e];t.space=at,t.bvhTool=ot,t.effects=h}const c=I.k.section.volumne,u=I.k.section.bounds.x*I.k.section.bounds.z;for(let e=0;e<c;e++){if(!(e%u)){const t=e/u;if(!r.getHasVoxel(t)&&!r.getHasVoxelDirty(t)){e+=u-1;continue}}if(!r.ids[e])continue;if(!r.ids[e]||r.getBuried(e))continue;const t=rt.getVoxelAtIndex(e),s=i+rt._voxelPosition.x,n=a+rt._voxelPosition.y,l=o+rt._voxelPosition.z;let d=!1;nt(s,n,l,t)&&(d=!0),t.hasSecondaryVoxel()&&(t.setSecondary(!0),nt(s,n,l,t)&&(d=!0),t.setSecondary(!1)),r.setBuried(e,!d)}const g=[],f=[[e[0],...r.getPosition()],[],g,0],m=[];for(let e=0;e<st.meshers.length;e++){const s=st.meshers[e];for(const e in s.effects){const r=Float32Array.from(s.effects[e]);t.push(r.buffer),g.push([e,r])}s.mesh.vertexCount?m.push(s):(s.clear(),s.bvhTool=null)}const p=function(e,t=[]){const s=[0,[]];for(let r=0;r<e.length;r++){const i=e[r];if(!i.mesh.vertexCount)continue;const a=i.mesh.vertexCount*Se.VertexFloatSize,o=new Float32Array(a),n=i.mesh.buffer._buffers;let l=0,d=!1;for(let e=0;e<n.length;e++){const t=n[e];for(let e=0;e<t.length;e++)if(o[l]=t[e],l++,l>a){d=!0;break}if(d)break}const h=i.mesh.indicieCount>65535?new Uint32Array(i.mesh.indicieCount):new Uint16Array(i.mesh.indicieCount),c=i.mesh.indices._buffers;l=0,d=!1;for(let e=0;e<c.length;e++){const t=c[e];for(let e=0;e<t.length;e++)if(h[l]=t[e],l++,l>i.mesh.indicieCount){d=!0;break}if(d)break}const u=i.mesh.minBounds,g=i.mesh.maxBounds;s[1].push([i.id,o,h,[u.x,u.y,u.z],[g.x,g.y,g.z]]),t.push(o.buffer,h.buffer)}return s}(m,t);f[1]=p;for(let e=0;e<m.length;e++)m[e].clear(),m[e].bvhTool=null;return r.setDirty(!1),r.setInProgress(!1),f}var ht,ct,ut=s(20650),gt=s(55138);!function(e){e[e.None=0]="None",e[e.Down=1]="Down",e[e.Up=2]="Up"}(ht||(ht={})),function(e){e[e.NorthEast=0]="NorthEast",e[e.NorthWest=1]="NorthWest",e[e.SouthWest=2]="SouthWest",e[e.SouthEsat=3]="SouthEsat"}(ct||(ct={}));const ft={[ct.NorthEast]:[1,0,0,1,1,1],[ct.NorthWest]:[-1,0,0,1,-1,1],[ct.SouthWest]:[-1,0,0,-1,-1,-1],[ct.SouthEsat]:[1,0,0,-1,1,-1]};function mt(e,t,s,r){const i=e.nVoxel.getVoxel(t,s,r);if(!i||!i.isRenderable())return-1;if(!e.voxel.isSameVoxel(i))return-1;const a=i.getLevel();return i.getLevelState()>0?7:a}const pt=[R.xH.East,0],yt=new xe,xt=new xe,vt=new C.$,bt=6/7,wt={[R.xH.North]:ve.RotateUvs(ve.FullUVs,R.xH.North),[R.xH.South]:ve.RotateUvs(ve.FullUVs,R.xH.South),[R.xH.East]:ve.RotateUvs(ve.FullUVs,R.xH.East),[R.xH.West]:ve.RotateUvs(ve.FullUVs,R.xH.West),[R.xH.NorthWest]:ve.RotateUvs(ve.FullUVs,R.xH.NorthWest),[R.xH.NorthEast]:ve.RotateUvs(ve.FullUVs,R.xH.NorthEast),[R.xH.SouthWest]:ve.RotateUvs(ve.FullUVs,R.xH.SouthWest),[R.xH.SouthEast]:ve.RotateUvs(ve.FullUVs,R.xH.SouthEast)},At=[[1,1],[0,1],[0,0],[1,0]],{quads:Bt,vertexWeights:It,quadBounds:St}=Ae([[0,0,0],[1,bt,1]],{});Bt[te.Up].setUVs(At),Bt[te.Down].setUVs(At);class Ct extends K{init(){this.faceCount=1,this.vertexCount=0}isExposed(e){const t=this.builder.nVoxel.getVoxel(re[e][0]+this.builder.position.x,re[e][1]+this.builder.position.y,re[e][2]+this.builder.position.z);return!(t&&!t.isAir()&&(this.builder.voxel.isSameVoxel(t)||e!=te.Up))}determineShading(e){this.builder.calculateFaceData(e);const t=this.builder.lightData[e],s=this.builder.vars.light;s.vertices[0]=t[0],s.vertices[1]=t[1],s.vertices[2]=t[2],s.vertices[3]=t[3]}shouldFlip(){const e=this.builder.vars.light;return he(vt.getS(e.vertices[0]),vt.getS(e.vertices[1]),vt.getS(e.vertices[2]),vt.getS(e.vertices[3]))||he(vt.sumRGB(e.vertices[0]),vt.sumRGB(e.vertices[1]),vt.sumRGB(e.vertices[2]),vt.sumRGB(e.vertices[3]))}add(e){xt.setAll(15),yt.setAll(0);const t=this.builder;let s=!1,r=!1;if(this.isExposed(te.Up)){r=!0,s=!0,function(e,t){const s=e.voxel.getLevel(),r=e.voxel.getLevelState();for(let i=0;i<=3;i++){const a=ft[i];let o=s,n=0;for(let s=0;s<6;s+=2){const r=a[s]+e.position.x,l=a[s+1]+e.position.z;if(mt(e,r,e.position.y+1,l)>0){t.vertices[i]=9,o=9;break}const d=mt(e,r,e.position.y,l);-1==d&&n++,o<d&&(o=d)}(o<7&&o>3||1==r)&&n>=2&&(o=3),t.vertices[i]=o}}(t,xt);const i=Bt[te.Up];this.determineShading(te.Up),i.flip=this.shouldFlip(),t.vars.textureIndex=e.stillTexture,yt.set(xt.vertices[0]/7,xt.vertices[1]/7,xt.vertices[2]/7,xt.vertices[3]/7);const a=function(e){if(e.isAllEqualTo(7))return pt[0]=0,pt[1]=ht.Up,pt;const t=e.vertices[J.TopRight],s=e.vertices[J.TopLeft],r=e.vertices[J.BottomLeft],i=e.vertices[J.BottomRight],a=t==i,o=s==r;if(t==s&&i==r){if(t<i)return pt[0]=R.xH.North,pt[1]=ht.Up,pt;if(t>i)return pt[0]=R.xH.South,pt[1]=ht.Up,pt}if(a&&o){if(t<s)return pt[0]=R.xH.East,pt[1]=ht.Up,pt;if(t>s)return pt[0]=R.xH.West,pt[1]=ht.Up,pt}return i<t&&i<s&&i<r||s>t&&s>i&&s>r?(pt[0]=R.xH.SouthEast,pt[1]=ht.Up,pt):s<t&&s<i&&s<r||i>t&&i>s&&i>r?(pt[0]=R.xH.NorthWest,pt[1]=ht.Up,pt):t<i&&t<s&&t<r||r>i&&r>s&&r>t?(pt[0]=R.xH.NorthEast,pt[1]=ht.Up,pt):r<i&&r<s&&r<t||t>i&&t>s&&t>r?(pt[0]=R.xH.SouthWest,pt[1]=ht.Up,pt):(pt[0]=R.xH.North,pt[1]=ht.Up,pt)}(xt),o=wt[a[0]];t.vars.animation.setAll(a[1]),i.uvs.vertices[J.TopRight].x=o[0][0],i.uvs.vertices[J.TopRight].y=o[0][1],i.uvs.vertices[J.TopLeft].x=o[1][0],i.uvs.vertices[J.TopLeft].y=o[1][1],i.uvs.vertices[J.BottomLeft].x=o[2][0],i.uvs.vertices[J.BottomLeft].y=o[2][1],i.uvs.vertices[J.BottomRight].x=o[3][0],i.uvs.vertices[J.BottomRight].y=o[3][1],i.positions.vertices[0].y=yt.vertices[0]*bt,i.positions.vertices[1].y=yt.vertices[1]*bt,i.positions.vertices[2].y=yt.vertices[2]*bt,i.positions.vertices[3].y=yt.vertices[3]*bt,Te.addQuad(t,t.origin,i),t.updateBounds(St[te.Up])}if(this.isExposed(te.Down)){s=!0,t.vars.textureIndex=e.stillTexture;const r=Bt[te.Down];this.determineShading(te.Down),r.flip=this.shouldFlip(),Te.addQuad(t,t.origin,r),t.updateBounds(St[te.Down])}if(this.isExposed(te.North)){s=!0,t.vars.textureIndex=e.flowTexture;const i=Bt[te.North];t.vars.animation.setAll(1),this.determineShading(te.North),i.flip=this.shouldFlip(),r?(i.positions.vertices[J.TopRight].y=yt.vertices[ct.NorthWest]*bt,i.positions.vertices[J.TopLeft].y=yt.vertices[ct.NorthEast]*bt,i.uvs.vertices[J.TopRight].y=yt.vertices[ct.NorthWest],i.uvs.vertices[J.TopLeft].y=yt.vertices[ct.NorthEast]):(i.positions.vertices[J.TopRight].y=1,i.positions.vertices[J.TopLeft].y=1,i.setUVs(At)),Te.addQuad(t,t.origin,i),t.updateBounds(St[te.North])}if(this.isExposed(te.South)){s=!0,t.vars.textureIndex=e.flowTexture;const i=Bt[te.South];t.vars.animation.setAll(1),this.determineShading(te.South),i.flip=this.shouldFlip(),r?(i.positions.vertices[J.TopRight].y=yt.vertices[ct.SouthEsat]*bt,i.positions.vertices[J.TopLeft].y=yt.vertices[ct.SouthWest]*bt,i.uvs.vertices[J.TopRight].y=yt.vertices[ct.SouthEsat],i.uvs.vertices[J.TopLeft].y=yt.vertices[ct.SouthWest]):(i.positions.vertices[J.TopLeft].y=1,i.positions.vertices[J.TopRight].y=1,i.setUVs(At)),Te.addQuad(t,t.origin,i),t.updateBounds(St[te.South])}if(this.isExposed(te.East)){s=!0,t.vars.textureIndex=e.flowTexture;const i=Bt[te.East];t.vars.animation.setAll(1),this.determineShading(te.East),i.flip=this.shouldFlip(),r?(i.positions.vertices[J.TopRight].y=yt.vertices[ct.NorthEast]*bt,i.positions.vertices[J.TopLeft].y=yt.vertices[ct.SouthEsat]*bt,i.uvs.vertices[J.TopRight].y=yt.vertices[ct.SouthEsat],i.uvs.vertices[J.TopLeft].y=yt.vertices[ct.NorthEast]):(i.positions.vertices[J.TopLeft].y=1,i.positions.vertices[J.TopRight].y=1,i.setUVs(At)),Te.addQuad(t,t.origin,i),t.updateBounds(St[te.East])}if(this.isExposed(te.West)){s=!0,t.vars.textureIndex=e.flowTexture;const i=Bt[te.West];t.vars.animation.setAll(1),this.determineShading(te.West),i.flip=this.shouldFlip(),r?(i.positions.vertices[J.TopRight].y=yt.vertices[ct.SouthWest]*bt,i.positions.vertices[J.TopLeft].y=yt.vertices[ct.NorthWest]*bt,i.uvs.vertices[J.TopRight].y=yt.vertices[ct.SouthWest],i.uvs.vertices[J.TopLeft].y=yt.vertices[ct.NorthWest]):(i.positions.vertices[J.TopLeft].y=1,i.positions.vertices[J.TopRight].y=1,i.setUVs(At)),Te.addQuad(t,t.origin,i),t.updateBounds(St[te.West])}return this.builder.vars.light.setAll(0),s}}var Tt,_t,zt=s(61886),Vt=s(50556);class Dt{data;view;constructor(e){this.data=e,this.view=new Uint8Array(e.buffer)}getValue(e,t,s){return Y.u.getBitArrayIndex(this.view,this.data.resultsSize*e+t,s)}setValue(e,t,s,r=1){Y.u.setBitArrayIndex(this.view,this.data.resultsSize*e+t,s,r)}}class Mt{model;effects=[];constructor(e){this.model=e;for(const t of e.data.effects)"fx-points"==t.type&&this.effects.push({id:t.effectId,reader:new Vt.z(e.schema,0,t.tree),palette:t.treePalette})}addEffects(e,t,s){if(this.effects.length)for(let r=0;r<this.effects.length;r++){const i=this.effects[r];let a=s[i.id];a||(a=[],s[i.id]=a);const o=i.reader.getState(e);if(-1==o)continue;const n=i.palette[o];if(!n)continue;let l=a.length;for(let e=0;e<n.length;e++){const s=n[e];a[l]=t.x+s[0],a[l+1]=t.y+s[1],a[l+2]=t.z+s[2],l+=3}}}}!function(e){e[e.Equals=0]="Equals",e[e.NotEquals=1]="NotEquals",e[e.GreaterThan=2]="GreaterThan",e[e.LessThan=3]="LessThan"}(Tt||(Tt={})),function(e){e[e.And=0]="And",e[e.Or=1]="Or"}(_t||(_t={})),Tt.Equals,Tt.NotEquals,Tt.GreaterThan,Tt.LessThan,_t.And,_t.Or;class kt{schema;statement;constructor(e,t){this.schema=e,this.statement=t}getValue(e){let t=-1,s=!1,r=!1;for(let e=0;e<this.statement.length;e++){const i=this.statement[e];if(i==_t.And||i==_t.Or){t=i;continue}const a=this.schema.nodes[i[0]].getValue(this.schema.voxel.getState());switch(i[1]){case Tt.Equals:r=a==i[2];break;case Tt.NotEquals:r=a!=i[2];break;case Tt.GreaterThan:r=a>=i[2];break;case Tt.LessThan:r=a<=i[2]}if(-1!=t)switch(t){case _t.And:s=s&&r;break;case _t.Or:s=s||r}else s=r}return s}}class Nt{schema;tree;statements=[];constructor(e,t,s){this.schema=e,this.tree=s;for(const s of t)this.statements.push(new kt(e,s))}getState(){if(!this.tree.length)return-1;let e=this.tree;for(let t=0;t<this.statements.length;t++)e=e[this.statements[t].getValue(this)?1:0];return e}}class Lt{id;builder;data;isModel=!0;geometries=[];modSchema;modTree;transparentIndex;baseInputMap;conditonalInputMap;schema;effects;shapeStateTree;condtioanlShapeStateTree;constructor(e,t,s,r){this.id=e,this.builder=t,this.data=s,this.baseInputMap=r.baseGeometryInputMap,this.conditonalInputMap=r.condiotnalGeometryInputMap,this.transparentIndex=new Dt(r.transparentFaceIndex),this.schema=new zt.X(s.schema),this.shapeStateTree=new Vt.z(this.schema,0,s.shapeStateTree),this.condtioanlShapeStateTree=new Nt(this.schema,s.condiotnalStatements,s.condiotnalStateTree),this.modSchema=new zt.X(r.modSchema),this.modTree=new Vt.z(this.modSchema,0,r.modStateTree),this.effects=new Mt(this)}isShapeStateFaceTransparent(e,t,s,r){return 1==this.transparentIndex.getValue(e,this.data.relativeGeometryByteIndexMap[this.data.shapeStateRelativeGeometryMap[t][s]],r)}isCondtionalStateFaceTransparent(e,t,s,r){return 1==this.transparentIndex.getValue(e,this.data.relativeGeometryByteIndexMap[this.data.condiotnalShapeStateRelativeGeometryMap[t][s]],r)}process(){let e=!1;const t=this.builder,s=t.space.getHash(t.nVoxel,t.position.x,t.position.y,t.position.z),r=t.space.stateCache[s],i=t.space.modCache[s];if(r>-1){const t=this.data.shapeStateMap[r],s=this.data.shapeStateGeometryMap[r],a=t.length,o=this.baseInputMap[i][r];for(let r=0;r<a;r++){const i=o[t[r]],a=Ge.geometry[s[r]],n=a.nodes.length;for(let t=0;t<n;t++){const s=a.nodes[t];s.builder=this.builder,s.add(i[t])&&(e=!0)}}}const a=t.space.conditonalStateCache[s];if(a>-1){const t=this.data.condiotnalShapeStateMap[a],s=t.length;for(let r=0;r<s;r++){const s=t[r],a=s.length,o=this.conditonalInputMap[i][r];for(let t=0;t<a;t++){const r=s[t],i=o[t],a=Ge.geometry[this.data.geoLinkMap[r]],n=a.nodes.length;for(let t=0;t<n;t++){const s=a.nodes[t];s.builder=this.builder,s.add(i[t])&&(e=!0)}}}}return this.effects.addEffects(t.voxel.getState(),t.origin,t.effects),t.clearCalculatedData(),e}}var Rt=s(15741),Ft=s(46830),Ut=s(15661),Pt=s(85212);const Et=["16-bit","8-bit","value"];class Ht{static BytePaletteMax=256;static NibblePaletteMax=16;static HalfNibblePaletteMax=4;static BitPaletteMax=2;static DetermineSubByteArray=e=>e==Ht.BitPaletteMax?"1-bit":e>Ht.BitPaletteMax&&e<=Ht.HalfNibblePaletteMax?"2-bit":e>Ht.HalfNibblePaletteMax&&e<=Ht.NibblePaletteMax?"4-bit":e>Ht.NibblePaletteMax&&e<=Ht.BytePaletteMax?"8-bit":null;static CreateBufferForType(e,t){return"16-bit"==e?new Uint16Array(t):new Uint8Array(t)}static GetConvertedBufferSize(e,t){return"16-bit"==t||"8-bit"==t?e.length:"1-bit"==t?e.length/8:"4-bit"==t?e.length/2:"2-bit"==t?e.length/4:"value"==t?1:e.length}static GetIndexLength(e,t){return"16-bit"==t||"8-bit"==t?e.length:"1-bit"==t?8*e.length:"4-bit"==t?2*e.length:"2-bit"==t?4*e.length:"value"==t?1:e.length}static ReadBufferAtIndex(e,t,s){return"16-bit"==t||"8-bit"==t?e[s]:"1-bit"==t?(0,Pt.Tv)(e,s):"4-bit"==t?(0,Pt.wu)(e,s):"2-bit"==t?(0,Pt.pL)(e,s):e[s]}static SetBufferAtIndex(e,t,s,r){return"16-bit"==t||"8-bit"==t?e[s]=r:"1-bit"==t?(0,Pt.JU)(e,s,r):"4-bit"==t?(0,Pt.A8)(e,s,r):"2-bit"==t?(0,Pt.rW)(e,s,r):e[s]}static Convert(e,t,s){if(t==s||"16-bit"==t&&"8-bit"==s||"8-bit"==t&&"16-bit"==s){const t=this.CreateBufferForType(s,this.GetConvertedBufferSize(e,s));return t.set(e),t}const r=this.GetIndexLength(e,t),i=this.CreateBufferForType(s,this.GetConvertedBufferSize(e,s));for(let a=0;a<r;a++)this.SetBufferAtIndex(i,s,a,this.ReadBufferAtIndex(e,t,a));return i}static Create(e){return{buffer:0,...e}}constructor(e){this.buffer=e.buffer,e.type?this.type=e.type:("number"==typeof e.buffer&&(this.type="value"),e.buffer instanceof Uint16Array&&(this.type="16-bit"),e.buffer instanceof Uint8Array&&(this.type="8-bit"))}getValue(e){return"number"==typeof this.buffer?this.buffer:Ht.ReadBufferAtIndex(this.buffer,this.type,e)}toJSON(){return{buffer:this.buffer,...Et.includes(this.type)?{}:{type:this.type}}}}const Gt=new C.$,Ot=["sun","red","green","blue"],Qt={sun:e=>Gt.getS(e),red:e=>Gt.getR(e),green:e=>Gt.getG(e),blue:e=>Gt.getB(e)},Yt={sun:(e,t)=>Gt.setS(e,t),red:(e,t)=>Gt.setR(e,t),green:(e,t)=>Gt.setG(e,t),blue:(e,t)=>Gt.setB(e,t)},Xt="0123456789ABCDEF";function Zt(e){if(e<0||e>65535)throw new RangeError("Value must be a 16-bit unsigned integer.");const t=[];for(let s=0;s<4;s++){const r=e>>4*s&15;t.unshift(Xt[r])}return t.join("").replace(/^0+(?!$)/,"")}function Wt(e,t){for(const s in e){if(!(s in t))return!1;const r=e[s],i=t[s];if(ArrayBuffer.isView(r)||"object"!=typeof r||null===r||ArrayBuffer.isView(i)||"object"!=typeof i||null===i){if("number"!=typeof r&&"string"!=typeof r&&"number"!=typeof i&&"string"!=typeof i){if(r instanceof Uint8Array||r instanceof Uint16Array){if(!(i instanceof r.constructor))return!1;if(r.length!==i.length)return!1;let e=i;for(let t=0;t<e.length;t++)if(r[t]!=e[t])return!1}}else if(r!==i)return!1}else if(!Wt(r,i))return!1}return!0}function qt(e,t){return Wt(e,t)}function jt(e){return{buffer:e,allTheSame:!0,isPaletted:!1,remapped:!1,value:0}}const $t=e=>({original:e,palettes:{ids:new Rt.h,level:new Rt.h,light:Kt(),state:new Rt.h,mod:new Rt.h,secondaryId:new Rt.h,secondaryState:new Rt.h},isBuriedAllTheSame:!1,buriedValue:0,isVoxelMapAllTheSame:!1,voxelMapValue:0,isDirtyMapAllTheSame:!1,dirtyMapValue:0,ids:jt(new Uint16Array(e.ids.length)),light:{sun:jt(new Uint8Array(e.light.length)),red:jt(new Uint8Array(e.light.length)),green:jt(new Uint8Array(e.light.length)),blue:jt(new Uint8Array(e.light.length))},level:jt(new Uint8Array(e.level.length)),state:jt(new Uint16Array(e.level.length)),mod:jt(new Uint16Array(e.mod.length)),secondary:jt(new Uint16Array(e.mod.length))});function Kt(){return{sun:new Rt.h,red:new Rt.h,green:new Rt.h,blue:new Rt.h}}function Jt(e,t){const s=new Uint8Array(t.length/2);for(let r=0;r<t.length;r++){let i=0;"sun"==e&&(i=ts.getS(t[r])),"red"==e&&(i=ts.getR(t[r])),"green"==e&&(i=ts.getG(t[r])),"blue"==e&&(i=ts.getB(t[r])),(0,Pt.A8)(s,r,i)}return s}function es(e,t){const s={};e.ids.remapped&&(s.id=Uint16Array.from(e.palettes.ids._palette)),e.level.remapped&&(s.level=Uint8Array.from(e.palettes.level._palette)),e.light.sun.remapped&&(s.light??={},s.light.sun=Uint8Array.from(e.palettes.light.sun._palette)),e.light.red.remapped&&(s.light??={},s.light.red=Uint8Array.from(e.palettes.light.red._palette)),e.light.green.remapped&&(s.light??={},s.light.green=Uint8Array.from(e.palettes.light.green._palette)),e.light.blue.remapped&&(s.light??={},s.light.blue=Uint8Array.from(e.palettes.light.blue._palette)),e.state.remapped&&(s.state=Uint16Array.from(e.palettes.state._palette)),e.mod.remapped&&(s.mod=Uint16Array.from(e.palettes.mod._palette)),e.secondary.remapped&&(s.secondaryId=Uint16Array.from(e.palettes.secondaryId._palette),s.secondaryState=Uint16Array.from(e.palettes.secondaryState._palette));const r={};if(e.ids.allTheSame)0!==e.ids.buffer[0]&&(r.id=e.ids.buffer[0]);else if(e.ids.isPaletted){const s=Ht.DetermineSubByteArray(e.ids.remapped?e.palettes.ids.size:t.ids.size);r.id=Ht.Create({buffer:Ht.Convert(e.ids.buffer,"16-bit",s),type:s})}else r.id=Ht.Create({buffer:e.ids.buffer});if(e.level.allTheSame)0!==e.level.buffer[0]&&(r.level=e.level.buffer[0]);else if(e.level.isPaletted){const s=Ht.DetermineSubByteArray(e.level.remapped?e.palettes.level.size:t.level.size);r.level=Ht.Create({buffer:Ht.Convert(e.level.buffer,"8-bit",s),type:s})}else r.level=Ht.Create({buffer:e.original.level.slice()});for(const s of Ot)if(e.light[s].allTheSame)0!==e.light[s].value&&(r.light??={},r.light[s]=e.light[s].value);else if(e.light[s].isPaletted){const i=Ht.DetermineSubByteArray(e.light[s].remapped?e.palettes.light[s].size:t.light[s].size);r.light??={},r.light[s]=Ht.Create({buffer:Ht.Convert(e.light[s].buffer,"8-bit",i),type:i})}else r.light??={},r.light[s]=Ht.Create({buffer:Jt(s,e.original.light),type:"4-bit"});if(e.state.allTheSame)0!==e.state.buffer[0]&&(r.state=e.state.buffer[0]);else if(e.state.isPaletted){const s=Ht.DetermineSubByteArray(e.state.remapped?e.palettes.state.size:t.state.size);r.state=Ht.Create({buffer:Ht.Convert(e.state.buffer,"16-bit",s),type:s})}else r.state=Ht.Create({buffer:e.state.buffer});if(e.mod.allTheSame)0!==e.mod.buffer[0]&&(r.mod=e.mod.buffer[0]);else if(e.mod.isPaletted){const s=Ht.DetermineSubByteArray(e.mod.remapped?e.palettes.mod.size:t.mod.size);r.mod=Ht.Create({buffer:Ht.Convert(e.mod.buffer,"16-bit",s),type:s})}else r.mod=Ht.Create({buffer:e.mod.buffer});if(e.secondary.allTheSame)0!==e.secondary.buffer[0]&&(r.secondary=e.secondary.buffer[0]);else if(e.secondary.isPaletted){const s=Ht.DetermineSubByteArray(e.secondary.remapped?Math.max(e.palettes.secondaryState.size,e.palettes.secondaryId.size):Math.max(t.secondaryState.size,t.secondaryId.size));r.secondary=Ht.Create({buffer:Ht.Convert(e.secondary.buffer,"16-bit",s),type:s})}else r.secondary=Ht.Create({buffer:e.secondary.buffer});e.isBuriedAllTheSame?0!==e.buriedValue&&(r.buried=e.buriedValue):r.buried=e.original.buried.slice(),e.isVoxelMapAllTheSame?0!==e.voxelMapValue&&(r.voxelMap=e.voxelMapValue):r.voxelMap=e.original.voxelMap.slice(),e.isDirtyMapAllTheSame?0!==e.dirtyMapValue&&(r.dirtyMap=e.dirtyMapValue):r.dirtyMap=e.original.dirtyMap.slice();const i=e.original.storeFlags();return{...Object.keys(i).length?{flags:i}:{},...Object.keys(s).length?{palettes:s}:{},buffers:r}}const ts=new C.$;function ss(e){const t=n._.sectors.get(e.location[0],e.location[1],e.location[2],e.location[3]);if(!t)throw new Error(`Column at location ${location} does not exist when trying to arhicve it.`);const s={ids:new P.N,level:new Rt.h,light:Kt(),stateIdMap:[],state:new Rt.h,modIdMap:[],mod:new Rt.h,secondaryId:new P.N,secondaryState:new Rt.h},r=[];for(const e of t.sections){const t=$t(e);{let s=e.buried[0];t.isBuriedAllTheSame=!0;for(let r=0;r<e.buried.length;r++)if(s!=e.buried[r]){t.isBuriedAllTheSame=!1;break}t.buriedValue=s}{let s=e.voxelMap[0];t.isVoxelMapAllTheSame=!0;for(let r=0;r<e.voxelMap.length;r++)if(s!=e.voxelMap[r]){t.isVoxelMapAllTheSame=!1;break}t.voxelMapValue=s}{let s=e.dirtyMap[0];t.isDirtyMapAllTheSame=!0;for(let r=0;r<e.dirtyMap.length;r++)if(s!=e.dirtyMap[r]){t.isDirtyMapAllTheSame=!1;break}t.dirtyMapValue=s}const i=e.ids[0],a=e.light[0],o=e.level[0],n=e.state[0],l=e.mod[0],d=e.secondary[0],h={sun:ts.getS(a),red:ts.getR(a),green:ts.getG(a),blue:ts.getB(a)},c=e.ids.length;for(let r=0;r<c;r++){const a=He.A.voxels.getStringId(e.ids[r]),c=s.ids.isRegistered(a)?s.ids.getNumberId(a):s.ids.register(a);t.ids.value=c,t.palettes.ids.isRegistered(c)||t.palettes.ids.register(c);const u=Ut.L.VoxelTags[e.ids[r]].dve_can_have_secondary&&He.A.voxels.getStringId(e.secondary[r]),g=u?s.secondaryId.isRegistered(u)?s.secondaryId.getNumberId(u):s.secondaryId.register(u):s.secondaryState.isRegistered(e.secondary[r])?s.secondaryState.getId(e.secondary[r]):s.secondaryState.register(e.secondary[r]);Ut.L.VoxelTags[e.ids[r]].dve_can_have_secondary?t.palettes.secondaryId.isRegistered(g)||t.palettes.secondaryId.register(g):t.palettes.secondaryState.isRegistered(g)||t.palettes.secondaryState.register(g);const f=s.level.isRegistered(e.level[r])?s.level.getId(e.level[r]):s.level.register(e.level[r]);t.palettes.level.isRegistered(e.level[r])||t.palettes.level.register(e.level[r]);let m=-1;s.state.isRegistered(e.state[r])?m=s.state.getId(e.state[r]):(m=s.state.register(e.state[r]),s.stateIdMap[m]=u?e.secondary[r]:e.ids[r]),t.palettes.state.isRegistered(m)||t.palettes.state.register(m);let p=-1;s.mod.isRegistered(e.mod[r])?p=s.mod.getId(e.mod[r]):(p=s.mod.register(e.mod[r]),s.modIdMap[p]=u?e.secondary[r]:e.ids[r]),t.palettes.mod.isRegistered(p)||t.palettes.mod.register(p);for(let i=0;i<Ot.length;i++){const a=Ot[i],o=Qt[a](e.light[r]);o!=h[a]&&(t.light[a].allTheSame=!1),t.light[a].value=o;const n=s.light[a].isRegistered(o)?s.light[a].getId(o):s.light[a].register(o);t.palettes.light[a].isRegistered(o)||t.palettes.light[a].register(o),t.light[a].buffer[r]=n}e.ids[r]!=i&&(t.ids.allTheSame=!1),e.level[r]!=o&&(t.level.allTheSame=!1),e.state[r]!=n&&(t.state.allTheSame=!1),e.mod[r]!=l&&(t.mod.allTheSame=!1),e.secondary[r]!=d&&(t.secondary.allTheSame=!1),t.ids.buffer[r]=c,t.level.buffer[r]=f,t.state.buffer[r]=m,t.mod.buffer[r]=p,t.secondary.buffer[r]=g}r.push(t)}let i={level:!1,light:{sun:!1,red:!1,green:!1,blue:!1}};for(const e of r){e.ids.isPaletted=s.ids.size<=Ht.BytePaletteMax||e.palettes.ids.size<=Ht.BytePaletteMax,e.ids.remapped=s.ids.size>Ht.BytePaletteMax&&e.palettes.ids.size<=Ht.BytePaletteMax&&!e.ids.allTheSame,e.level.isPaletted=s.level.size<=Ht.NibblePaletteMax&&e.palettes.level.size<=Ht.NibblePaletteMax,e.level.remapped=s.level.size>Ht.NibblePaletteMax&&e.palettes.level.size<=Ht.NibblePaletteMax&&!e.level.allTheSame,e.level.isPaletted&&!e.level.remapped&&(i.level=!0),e.state.isPaletted=s.state.size<=Ht.BytePaletteMax||e.palettes.state.size<=Ht.BytePaletteMax,e.state.remapped=s.state.size>Ht.BytePaletteMax&&e.palettes.state.size<=Ht.BytePaletteMax&&!e.state.allTheSame,e.mod.isPaletted=s.mod.size<=Ht.BytePaletteMax||e.palettes.mod.size<=Ht.BytePaletteMax,e.mod.remapped=s.mod.size>Ht.BytePaletteMax&&e.palettes.mod.size<=Ht.BytePaletteMax&&!e.mod.allTheSame;for(const t of Ot)e.light[t].isPaletted=s.light[t].size<=Ht.HalfNibblePaletteMax||e.palettes.light[t].size<=Ht.HalfNibblePaletteMax,e.light[t].remapped=s.light[t].size>Ht.HalfNibblePaletteMax&&e.palettes.light[t].size<=Ht.HalfNibblePaletteMax&&!e.light[t].allTheSame,e.light[t].isPaletted&&!e.light[t].remapped&&(i.light[t]=!0);if(e.secondary.isPaletted=s.secondaryState.size<=Ht.BytePaletteMax&&s.secondaryId.size<=Ht.BytePaletteMax||e.palettes.secondaryState.size<=Ht.BytePaletteMax&&e.palettes.secondaryId.size<=Ht.BytePaletteMax,e.secondary.remapped=Math.max(s.secondaryState.size,s.secondaryId.size)>Ht.BytePaletteMax&&Math.max(e.palettes.secondaryId.size,e.palettes.secondaryState.size)<=Ht.BytePaletteMax&&!e.secondary.allTheSame,!(e.ids.remapped||e.light.sun.remapped||e.light.red.remapped||e.light.green.remapped||e.light.blue.remapped||e.secondary.remapped||e.mod.remapped||e.level.remapped))continue;const t=e.original.ids.length;for(let r=0;r<t;r++){e.ids.remapped&&(e.ids.buffer[r]=e.palettes.ids.getId(e.ids.buffer[r]));for(let t=0;t<Ot.length;t++){const s=Ot[t];e.light[s].remapped&&(e.light[s].buffer[r]=e.palettes.light[s].getId(Qt[s](e.original.light[r])))}e.level.remapped&&(e.level.buffer[r]=e.palettes.level.getId(e.original.level[r])),e.state.remapped&&(e.state.buffer[r]=e.palettes.state.getId(s.state.getId(e.state.buffer[r]))),e.mod.remapped&&(e.mod.buffer[r]=e.palettes.mod.getId(s.mod.getId(e.mod.buffer[r]))),e.secondary.remapped&&(e.secondary.buffer[r]=Ut.L.VoxelTags[e.original.ids[r]].dve_can_have_secondary?e.palettes.secondaryId.getId(e.secondary.buffer[r]):e.palettes.secondaryState.getId(e.secondary.buffer[r]))}}const a={};for(let e=0;e<s.state._palette.length;e++){const t=s.state._palette[e],r=He.A.voxels.getStringId(s.stateIdMap[e]);if(!Ft.r.hasVoxelSchema(r))continue;const i=Ft.r.getVoxelSchemas(r);a[e]=i.state.getStateObject(t)}const o={};for(let e=0;e<s.mod._palette.length;e++){const t=s.mod._palette[e],r=He.A.voxels.getStringId(s.modIdMap[e]);if(!Ft.r.hasVoxelSchema(r))continue;const i=Ft.r.getVoxelSchemas(r);o[e]=i.mod.getStateObject(t)}const l=[];for(const e of r)l.push(es(e,s));const h={id:s.ids._palette,stateMap:a,modMap:o,state:new Uint16Array(s.state._palette),mod:new Uint16Array(s.mod._palette),light:{},secondaryId:s.secondaryId._palette,secondaryState:new Uint16Array(s.secondaryState._palette)};i.level&&(h.level=new Uint8Array(s.level._palette));for(const e of Ot)i.light[e]&&(h.light[e]=new Uint8Array(s.light[e]._palette));const c={version:"",vloxVersion:d.i.version,location:[...e.location],flags:t.storeFlags(),timestamps:t.storeTimestamps(),buffers:{},palettes:h,duplicates:{},sections:l};return function(e){const t=new Map;let s=[];for(let r=0;r<e.sections.length;r++)for(let i=0;i<e.sections.length;i++){const a=e.sections[r],o=e.sections[i];if(r==i)continue;if("string"==typeof a||"string"==typeof o)continue;let n=-1;if(qt(a,o)){if(t.has(o))n=t.get(o)[1];else{let e=!1;for(let t=0;t<s.length;t++)qt(a,s[t])&&(n=t,e=!0);e||(s.push(a),n=s.length-1)}t.set(a,[r,n])}}const r={};for(const[s,[i,a]]of t){const t=Zt(a);r[t]||(r[t]=s),e.sections[i]=t}e.duplicates={sections:r}}(c),c}const rs=e=>({sector:e,idPalette:new P.N(e.palettes.id),secondaryId:new P.N(e.palettes.secondaryId),levelPalette:e.palettes.level?new Rt.h(e.palettes.level):void 0,lightPalette:{sun:e.palettes.light.sun?new Rt.h(e.palettes.light.sun):null,red:e.palettes.light.red?new Rt.h(e.palettes.light.red):null,green:e.palettes.light.green?new Rt.h(e.palettes.light.green):null,blue:e.palettes.light.blue?new Rt.h(e.palettes.light.blue):null},statePalette:new Rt.h(e.palettes.state),modPalette:new Rt.h(e.palettes.mod),secondaryState:new Rt.h(e.palettes.secondaryState)}),is=e=>({section:e,buffers:{ids:e.buffers.id?"number"==typeof e.buffers.id?new Ht({buffer:e.buffers.id}):new Ht(e.buffers.id):new Ht({buffer:0}),level:e.buffers.level?"number"==typeof e.buffers.level?new Ht({buffer:e.buffers.level}):new Ht(e.buffers.level):new Ht({buffer:0}),light:{sun:e.buffers.light?.sun?"number"==typeof e.buffers.light.sun?new Ht({buffer:e.buffers.light.sun}):new Ht(e.buffers.light.sun):new Ht({buffer:0}),red:e.buffers.light?.red?"number"==typeof e.buffers.light.red?new Ht({buffer:e.buffers.light.red}):new Ht(e.buffers.light.red):new Ht({buffer:0}),green:e.buffers.light?.green?"number"==typeof e.buffers.light.green?new Ht({buffer:e.buffers.light.green}):new Ht(e.buffers.light.green):new Ht({buffer:0}),blue:e.buffers.light?.blue?"number"==typeof e.buffers.light.blue?new Ht({buffer:e.buffers.light.blue}):new Ht(e.buffers.light.blue):new Ht({buffer:0})},state:e.buffers.state?"number"==typeof e.buffers.state?new Ht({buffer:e.buffers.state}):new Ht(e.buffers.state):new Ht({buffer:0}),mod:e.buffers.mod?"number"==typeof e.buffers.mod?new Ht({buffer:e.buffers.mod}):new Ht(e.buffers.mod):new Ht({buffer:0}),secondary:e.buffers.secondary?"number"==typeof e.buffers.secondary?new Ht({buffer:e.buffers.secondary}):new Ht(e.buffers.secondary):new Ht({buffer:0})},idPalette:e.palettes?.id?new Rt.h(e.palettes?.id):void 0,lightPalette:{sun:e.palettes?.light?.sun?new Rt.h(e.palettes?.light?.sun):null,red:e.palettes?.light?.red?new Rt.h(e.palettes?.light?.red):null,green:e.palettes?.light?.green?new Rt.h(e.palettes?.light?.green):null,blue:e.palettes?.light?.blue?new Rt.h(e.palettes?.light?.blue):null},levelPalette:e.palettes?.level?new Rt.h(e.palettes?.level):void 0,statePalette:e.palettes?.state?new Rt.h(e.palettes?.state):void 0,modPalette:e.palettes?.mod?new Rt.h(e.palettes?.mod):void 0,secondaryState:e.palettes?.secondaryState?new Rt.h(e.palettes?.secondaryState):void 0,secondaryId:e.palettes?.secondaryId?new Rt.h(e.palettes?.secondaryId):void 0}),as=(e,t,s)=>"value"==s.buffers.ids.type?He.A.voxels.getNumberId(t.idPalette.getStringId(e)):s.idPalette?He.A.voxels.getNumberId(t.idPalette.getStringId(s.idPalette.getValue(e))):He.A.voxels.getNumberId(t.idPalette.getStringId(e)),os=(e,t,s)=>{let r=0;for(let i=0;i<Ot.length;i++){const a=Ot[i];let o=0;"value"==s.buffers.light[a].type||"4-bit"==s.buffers.light[a].type?o=s.buffers.light[a].getValue(e):s.lightPalette[a]?o=s.lightPalette[a].getValue(s.buffers.light[a].getValue(e)):t.lightPalette[a]&&(o=t.lightPalette[a].getValue(s.buffers.light[a].getValue(e))),r=Yt[a](o,r)}return r},ns=(e,t,s)=>s.levelPalette?s.levelPalette.getValue(e):t.levelPalette?t.levelPalette.getValue(e):e,ls=(e,t,s,r,i)=>{const a=He.A.voxels.getStringId(e);if(!Ft.r.hasVoxelSchema(a))return t;let o=-1;return(i.section.buffers.state instanceof Uint16Array||"number"==typeof i.section.buffers.state)&&(o=t),i.statePalette?o=i.statePalette.getValue(t):r.statePalette&&(o=t),void 0!==s[o]?s[o]:(t=Ft.r.getVoxelSchemas(a).state.fromStateObject(r.sector.palettes.stateMap[o]),s[o]=t,t)},ds=(e,t,s,r,i)=>{const a=He.A.voxels.getStringId(e);if(!Ft.r.hasVoxelSchema(a))return t;let o=-1;return(i.section.buffers.state instanceof Uint16Array||"number"==typeof i.section.buffers.state)&&(o=t),i.modPalette?o=i.modPalette.getValue(t):r.modPalette&&(o=t),void 0!==s[o]?s[o]:(t=Ft.r.getVoxelSchemas(a).mod.fromStateObject(r.sector.palettes.modMap[o]),s[o]=t,t)},hs=(e,t,s,r)=>Ut.L.VoxelTags[e].dve_can_have_secondary?r.secondaryId?He.A.voxels.getNumberId(s.secondaryId.getStringId(r.secondaryId.getValue(t))):He.A.voxels.getNumberId(s.sector.palettes.secondaryId[t]):"number"==typeof r.section.buffers.secondary?t:r.secondaryState&&s.secondaryState?s.secondaryState.getValue(r.secondaryState.getValue(t)):s.secondaryState?s.secondaryState.getId(t):t;function cs(e,t){const s=new m.h(m.h.CreateNew(),[e.location[1],e.location[2],e.location[3]]);s.loadFlags(e.flags),s.loadTimestamps(e.timestamps);const r=rs(e),i={},a={};for(let t=0;t<e.sections.length;t++){const o=e.sections[t],n="string"==typeof o?e.duplicates?.sections?.[o]:o,l=is(n),d=s.sections[t];if(n.flags&&d.loadFlags(n.flags),ArrayBuffer.isView(n.buffers.buried))for(let e=0;e<d.buried.length;e++)d.buried[e]=n.buffers.buried[e];else for(let e=0;e<d.buried.length;e++)d.buried[e]=n.buffers.buried||0;if(ArrayBuffer.isView(n.buffers.voxelMap))for(let e=0;e<d.voxelMap.length;e++)d.voxelMap[e]=n.buffers.voxelMap[e];else for(let e=0;e<d.voxelMap.length;e++)d.voxelMap[e]=n.buffers.voxelMap||0;if(ArrayBuffer.isView(n.buffers.dirtyMap))for(let e=0;e<d.dirtyMap.length;e++)d.dirtyMap[e]=n.buffers.dirtyMap[e];else for(let e=0;e<d.dirtyMap.length;e++)d.dirtyMap[e]=n.buffers.dirtyMap||0;for(let e=0;e<d.ids.length;e++){d.ids[e]=as(l.buffers.ids.getValue(e),r,l),d.level[e]=ns(l.buffers.level.getValue(e),r,l),d.light[e]=os(e,r,l),d.secondary[e]=hs(d.ids[e],l.buffers.secondary.getValue(e),r,l);let t=Ut.L.VoxelTags[d.ids[e]].dve_can_have_secondary&&d.secondary[e]>0;d.state[e]=ls(t?d.secondary[e]:d.ids[e],l.buffers.state.getValue(e),i,r,l),d.mod[e]=ds(t?d.secondary[e]:d.ids[e],l.buffers.mod.getValue(e),a,r,l)}s.sections[t]=d}return s.setBitFlag(m.h.FlagIds.isStored,!0),s}var us,gs=s(85860);!function(e){e[e.Name=0]="Name",e[e.Object=1]="Object",e[e.ObjectEnd=2]="ObjectEnd",e[e.Array=3]="Array",e[e.ArrayEnd=4]="ArrayEnd",e[e.Int8=5]="Int8",e[e.Uint8=6]="Uint8",e[e.Uint8Clamped=7]="Uint8Clamped",e[e.Int16=8]="Int16",e[e.Uint16=9]="Uint16",e[e.Float32=10]="Float32",e[e.Int32=11]="Int32",e[e.Uint32=12]="Uint32",e[e.Float64=13]="Float64",e[e.BigInt=14]="BigInt",e[e.BigUint=15]="BigUint",e[e.String=16]="String",e[e.Boolean=17]="Boolean",e[e.Undefined=18]="Undefined",e[e.ArrayBuffer=19]="ArrayBuffer",e[e.TypedArray=20]="TypedArray",e[e.Json=21]="Json",e[e.Blob=22]="Blob"}(us||(us={}));const fs={[us.Int8]:gs.QI.Int8,[us.Uint8]:gs.QI.Uint8,[us.Uint8Clamped]:gs.QI.Uint8Clamped,[us.Int16]:gs.QI.Int16,[us.Uint16]:gs.QI.Uint16,[us.Float32]:gs.QI.Float32,[us.Int32]:gs.QI.Int32,[us.Uint32]:gs.QI.Uint32,[us.Float64]:gs.QI.Float64,[us.BigInt]:gs.QI.BigInt,[us.BigUint]:gs.QI.BigUint};class ms{data;get length(){return this.data[2]}get marker(){return this.data[0]}get numberType(){return fs[this.marker]}get listType(){return this.data[1]}get value(){return this.data[3]}set value(e){this.data[3]=e}constructor(e,t,s=0,r=0){this.data=[e,s,r,t]}}class ps{static json(e){return new ms(us.Json,e)}static object(e){return new ms(us.Object,e)}static array(e){if(!Array.isArray(e))throw new Error("Data for array must be an array.");return new ms(us.Array,e)}static int8(e){return new ms(us.Int8,e)}static uIint8(e){return new ms(us.Uint8,e)}static int16(e){return new ms(us.Int16,e)}static uint16(e){return new ms(us.Uint16,e)}static uint32(e){return new ms(us.Uint32,e)}static int32(e){return new ms(us.Int32,e)}static float32(e){return new ms(us.Float32,e)}static float64(e){return new ms(us.Float64,e)}static bingInt(e){return new ms(us.BigInt,e)}static bigUint(e){return new ms(us.BigUint,e)}static boolean(e){return new ms(us.Boolean,e)}static undefined(){return new ms(us.Undefined,void 0)}static arrayBuffer(e){return new ms(us.ArrayBuffer,e)}static typedArray(e,t){return new ms(us.TypedArray,ArrayBuffer.isView(t)?t:TypedArrayMap[e].from(t),e)}static string(e){return new ms(us.String,e)}}var ys=s(34135);const xs={[gs.QI.Int8]:(e,t=!1)=>new Int8Array(t?new SharedArrayBuffer(e*Int8Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Int8Array.BYTES_PER_ELEMENT)),[gs.QI.Uint8]:(e,t=!1)=>new Uint8Array(t?new SharedArrayBuffer(e*Uint8Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Uint8Array.BYTES_PER_ELEMENT)),[gs.QI.Uint8Clamped]:(e,t=!1)=>new Uint8ClampedArray(t?new SharedArrayBuffer(e*Uint8ClampedArray.BYTES_PER_ELEMENT):new ArrayBuffer(e*Uint8ClampedArray.BYTES_PER_ELEMENT)),[gs.QI.Int16]:(e,t=!1)=>new Int16Array(t?new SharedArrayBuffer(e*Int16Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Int16Array.BYTES_PER_ELEMENT)),[gs.QI.Uint16]:(e,t=!1)=>new Uint16Array(t?new SharedArrayBuffer(e*Uint16Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Uint16Array.BYTES_PER_ELEMENT)),[gs.QI.Int32]:(e,t=!1)=>new Int32Array(t?new SharedArrayBuffer(e*Int32Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Int32Array.BYTES_PER_ELEMENT)),[gs.QI.Uint32]:(e,t=!1)=>new Uint32Array(t?new SharedArrayBuffer(e*Uint32Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Uint32Array.BYTES_PER_ELEMENT)),[gs.QI.Float32]:(e,t=!1)=>new Float32Array(t?new SharedArrayBuffer(e*Float32Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Float32Array.BYTES_PER_ELEMENT)),[gs.QI.Float64]:(e,t=!1)=>new Float64Array(t?new SharedArrayBuffer(e*Float64Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*Float64Array.BYTES_PER_ELEMENT)),[gs.QI.BigInt]:(e,t=!1)=>new BigInt64Array(t?new SharedArrayBuffer(e*BigInt64Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*BigInt64Array.BYTES_PER_ELEMENT)),[gs.QI.BigUint]:(e,t=!1)=>new BigUint64Array(t?new SharedArrayBuffer(e*BigUint64Array.BYTES_PER_ELEMENT):new ArrayBuffer(e*BigUint64Array.BYTES_PER_ELEMENT))};class vs{static _mode="object";static _sharedMemory=!1;static _cobj={};static _parents=[];static _objArray=[];static _name="";static _length=0;static _objCount=0;static _inOject=!1;static _newTypedNode(e,t,s=0){return new ms(e,t,s)}static _assign(e){"object"==this._mode||"json"==this._mode?Array.isArray(this._cobj)?this._cobj.push(e):this._cobj[this._name]=e:Array.isArray(this._cobj.value)?this._cobj.value.push(e):this._cobj.value[this._name]=e}static markFunctions={[us.Name]:(e,t)=>{this._name="";const s=Number(ys.n[gs.QI.Uint8](e,t+1));for(let r=t+=2*gs.bI.Uint8;r<t+s;r++)this._name+=String.fromCharCode(ys.n[gs.QI.Uint8](e,r));return t+s*gs.bI.Uint8},[us.Object]:(e,t)=>{let s;return s="object"==this._mode?{}:this._newTypedNode(us.Object,{}),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,gs.bI.Uint8+t},[us.ObjectEnd]:(e,t)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),gs.bI.Uint8+t),[us.Array]:(e,t)=>{let s;return s="object"==this._mode?[]:this._newTypedNode(us.Array,[]),0!=this._objCount&&(this._assign(s),this._parents.push(this._cobj)),this._objCount++,this._cobj=s,gs.bI.Uint8+t},[us.ArrayEnd]:(e,t)=>(this._parents.length>0&&(this._cobj=this._parents.pop()),gs.bI.Uint8+t),[us.Boolean]:(e,t)=>{const s=ys.n[gs.QI.Uint8](e,t+1);return"type-node"!=this._mode?this._assign(!s):this._assign(this._newTypedNode(us.Boolean,!s)),gs.bI.Uint8+gs.bI.Int8+t},[us.Undefined]:(e,t)=>("type-node"!=this._mode?this._assign(void 0):this._assign(this._newTypedNode(us.Undefined,void 0)),gs.bI.Uint8+t),[us.Int8]:(e,t)=>{const s=ys.n[gs.QI.Int8](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Int8,s)),gs.bI.Uint8+gs.bI.Int8+t},[us.Uint8]:(e,t)=>{const s=ys.n[gs.QI.Uint8](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Uint8,s)),gs.bI.Uint8+gs.bI.Uint8+t},[us.Uint8Clamped]:(e,t)=>{const s=ys.n[gs.QI.Uint8](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Uint8,s)),gs.bI.Uint8+gs.bI.Uint8+t},[us.Int16]:(e,t)=>{const s=ys.n[gs.QI.Int16](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Int16,s)),gs.bI.Uint8+gs.bI.Int16+t},[us.Uint16]:(e,t)=>{const s=ys.n[gs.QI.Uint16](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Uint16,s)),gs.bI.Uint8+gs.bI.Uint16+t},[us.Float32]:(e,t)=>{const s=ys.n[gs.QI.Float32](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Float32,s)),gs.bI.Uint8+gs.bI.Float32+t},[us.Int32]:(e,t)=>{const s=ys.n[gs.QI.Int32](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Int32,s)),gs.bI.Uint8+gs.bI.Int32+t},[us.Uint32]:(e,t)=>{const s=ys.n[gs.QI.Uint32](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Uint32,s)),gs.bI.Uint8+gs.bI.Uint8+gs.bI.Uint32+t+1},[us.Float64]:(e,t)=>{const s=ys.n[gs.QI.Float64](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.Float64,s)),gs.bI.Uint8+gs.bI.Float64+t},[us.BigInt]:(e,t)=>{const s=ys.n[gs.QI.BigInt](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.BigInt,s)),gs.bI.Uint8+gs.bI.BigInt+t},[us.BigUint]:(e,t)=>{const s=ys.n[gs.QI.BigUint](e,t+1);return"type-node"!=this._mode?this._assign(s):this._assign(this._newTypedNode(us.BigUint,s)),gs.bI.Uint8+gs.bI.BigUint+t},[us.String]:(e,t)=>{const s=ys.n[gs.QI.Uint32](e,t+1);let r="";for(let i=t+=gs.bI.Uint32+gs.bI.Uint8;i<t+s;i++)r+=String.fromCharCode(ys.n[gs.QI.Uint8](e,i));return"type-node"!=this._mode?this._assign(r):this._assign(this._newTypedNode(us.String,r)),t+s*gs.bI.Uint8},[us.TypedArray]:(e,t)=>{const s=ys.n[gs.QI.Uint8](e,t+1);if(void 0===s)throw new Error(`Not a valid type for a typed array ${s}`);const r=ys.n[gs.QI.Uint32](e,t+2);let i;t+=2*gs.bI.Uint8+gs.bI.Uint32,i="json"==this._mode?[]:xs[s](r,this._sharedMemory);const a=ys.n[s];for(let o=0;o<r;o++)i[o]=a(e,t),t+=gs.Yd[s];return"type-node"!=this._mode?this._assign(i):this._assign(this._newTypedNode(us.TypedArray,i,s)),t},[us.Blob]:(e,t)=>("type-node"!=this._mode?this._assign(Blob):this._assign(this._newTypedNode(us.Blob,void 0)),gs.bI.Uint8+t),[us.ArrayBuffer]:(e,t)=>{const s=ys.n[gs.QI.Uint32](e,t+1);t+=gs.bI.Uint8+gs.bI.Uint32;const r=new Uint8Array(this._sharedMemory?new SharedArrayBuffer(s):new ArrayBuffer(s));for(let i=0;i<s;i++)r[i]=ys.n[gs.QI.Uint8](e,t),t+=gs.QI.Uint8;return"type-node"!=this._mode?this._assign(r.buffer):this._assign(this._newTypedNode(us.ArrayBuffer,r.buffer)),t},[us.Json]:(e,t)=>{const s=ys.n[gs.QI.Uint32](e,t+1);let r="";for(let i=t+=gs.bI.Float32+gs.bI.Uint8;i<t+s;i++)r+=String.fromCharCode(ys.n[gs.QI.Uint8](e,i));const i=JSON.parse(r);return"type-node"!=this._mode?this._assign(i):this._assign(this._newTypedNode(us.Json,i)),t+s*gs.bI.Uint8}};static setUseSharedMemory(e){this._sharedMemory=e}static toObject(e,t=0,s=0){let r;this._mode="object",r=0==s?e.byteLength:s;const i=new DataView(e);this._objCount=0;let a=t,o=us.Object;for(;a<r;)o=ys.n[gs.QI.Uint8](i,a),a=this.markFunctions[o](i,a);return this._cobj}static toJSON(e,t=0,s=0){let r;this._mode="json",r=0==s?e.byteLength:s;const i=new DataView(e);this._objCount=0;let a=t,o=us.Object;for(;a<r;)o=ys.n[gs.QI.Uint8](i,a),a=this.markFunctions[o](i,a);return this._cobj}static toTypedNodes(e,t=0,s=0){let r;this._mode="type-node",r=0==s?e.byteLength:s,this._mode="object";const i=new DataView(e);this._objCount=0;let a=t,o=us.Object;for(;a<r;)o=ys.n[gs.QI.Uint8](i,a),a=this.markFunctions[o](i,a);return this._cobj}}gs.QI.Int8,Int8Array,gs.QI.Uint8,Uint8Array,gs.QI.Uint8Clamped,Uint8ClampedArray,gs.QI.Int16,Int16Array,gs.QI.Uint16,Uint16Array,gs.QI.Float32,Float32Array,gs.QI.Int32,Int32Array,gs.QI.Uint32,Uint32Array,gs.QI.Float64,Float64Array,gs.QI.BigInt,BigInt64Array,gs.QI.BigUint,BigUint64Array;const bs=new Map([[Int8Array,gs.QI.Int8],[Uint8Array,gs.QI.Uint8],[Uint8ClampedArray,gs.QI.Uint8Clamped],[Int16Array,gs.QI.Int16],[Uint16Array,gs.QI.Uint16],[Int32Array,gs.QI.Int32],[Uint32Array,gs.QI.Uint32],[Float32Array,gs.QI.Float32],[Float64Array,gs.QI.Float64],[BigInt64Array,gs.QI.BigInt],[BigUint64Array,gs.QI.BigUint]]);var ws,As=s(25075);class Bs{static view=new DataView(new ArrayBuffer(8));static count=0;static value=0;static setValue(e,t){return this.value=t,As.v[e](this.view,0,t),this.count=gs.Yd[e],this}static addBytes(e){for(let t=0;t<this.count;t++)e.push(this.view.getUint8(t))}}class Is{static _proto=[];static _tokenizeString(e){for(let t=0;t<e.length;t++)this._addToken(gs.QI.Uint8,e.charCodeAt(t))}static _traverseObj(e){this._addMarker(us.Object);for(const t of Object.keys(e.value)){if(t.length>255)throw new Error("An object key cannot be longer then 255 chars.");this._addMarker(us.Name),this._addToken(gs.QI.Uint8,t.length),this._tokenizeString(t);const s=e.value[t];s.marker!=us.Object||ArrayBuffer.isView(s.value)?s.marker!=us.Array||ArrayBuffer.isView(s.value)?this._tokenizePrimiives(s):this._traverseArray(s):this._traverseObj(s)}this._addMarker(us.ObjectEnd)}static _traverseArray(e){this._addMarker(us.Array);const t=e.value;for(const e of t)"object"!=typeof e.value||Array.isArray(e.value)||ArrayBuffer.isView(e.value)?"object"!=typeof e.value||!Array.isArray(e.value)||ArrayBuffer.isView(e.value)?this._tokenizePrimiives(e):this._traverseArray(e):this._traverseObj(e);this._addMarker(us.ArrayEnd)}static _tokenizePrimiives(e){if(e.marker!=us.String){if("number"==typeof e.value)return this._addMarker(e.marker),void this._addToken(e.numberType,e.value);if("boolean"==typeof e.value)return this._addMarker(e.marker),void this._addToken(gs.QI.Uint8,e.value?0:1);if(void 0!==e.value)if(e.marker!=us.ArrayBuffer){if(e.marker==us.TypedArray){this._addMarker(us.TypedArray),this._addToken(gs.QI.Uint8,e.listType),this._addToken(gs.QI.Uint32,e.value.length);let t=e.value;for(let s=0;s<t.length;s++)this._addToken(e.listType,t[s])}if(e.marker!=us.Json);else{let t="";t="object"==typeof e.value?JSON.stringify(e.value):e.value,this._addMarker(us.Json),this._addToken(gs.QI.Uint32,t.length);for(let e=0;e<t.length;e++)this._addToken(gs.QI.Uint8,t.charCodeAt(e))}}else{this._addMarker(us.ArrayBuffer);const t=new Uint8Array(e.value);this._addToken(gs.QI.Uint32,t.length);for(let e=0;e<t.length;e++)this._addToken(gs.QI.Uint8,t[e])}else this._addMarker(us.Undefined)}else{this._addMarker(us.String),this._addToken(gs.QI.Uint32,e.value.length);for(let t=0;t<e.value.length;t++)this._addToken(gs.QI.Uint8,e.value.charCodeAt(t))}}static _tokenize(e){e.marker!=us.Object||Array.isArray(e.value)||this._traverseObj(e),e.marker==us.Array&&Array.isArray(e.value)&&this._traverseArray(e)}static toBuffer(e){this._tokenize(e);const t=Uint8Array.from(this._proto);return this._proto=[],t.buffer}static _addMarker(e){Bs.setValue(gs.QI.Uint8,e).addBytes(this._proto)}static _addToken(e,t){Bs.setValue(e,t).addBytes(this._proto)}}class Ss{static _name="";static _traverseObj(e){const t=ps.object({});for(const s of Object.keys(e)){const r=e[s];this._name=s,r instanceof ms?t.value[s]=r:ArrayBuffer.isView(r)||r instanceof ArrayBuffer||r instanceof SharedArrayBuffer?t.value[s]=this._addPrimitive(r):r instanceof Blob||"undefined"!=typeof File&&r instanceof File||("object"!=typeof r||Array.isArray(r)?"object"==typeof r&&Array.isArray(r)?t.value[s]=this._traverseArray(r):t.value[s]=this._addPrimitive(r):t.value[s]=this._traverseObj(r))}return t}static _traverseArray(e){const t=ps.array([]);for(const s of e)s instanceof ms?t.value.push(s):ArrayBuffer.isView(s)?t.value.push(this._addPrimitive(s)):"object"!=typeof s||Array.isArray(s)?"object"!=typeof s||!Array.isArray(s)||ArrayBuffer.isView(s)?t.value.push(this._addPrimitive(s)):t.value.push(this._traverseArray(s)):t.value.push(this._traverseObj(s));return t}static _addPrimitive(e){if("string"==typeof e)return ps.string(e);if("number"==typeof e)return ps.float64(e);if("boolean"==typeof e)return ps.boolean(e);if(void 0===e)return ps.undefined();if(e instanceof ArrayBuffer||e instanceof SharedArrayBuffer)return ps.arrayBuffer(e);if(ArrayBuffer.isView(e)&&bs.has(e.constructor))return ps.typedArray(bs.get(e.constructor),e);if(e instanceof ms)return e;throw new Error("Unsuppourted type for DBO parser.")}static tokTypedNodes(e){if("object"==typeof e&&!Array.isArray(e)){const t=ps.object({});return t.value=this._traverseObj(e).value,t}if("object"==typeof e&&Array.isArray(e)){const t=ps.array([]);return t.value=this._traverseArray(e).value,t}return this._addPrimitive(e)}static toBuffer(e){const t=this.tokTypedNodes(e);return Is.toBuffer(t)}}class Cs{static nodes=ps;static setUseSharedMemory(e){vs.setUseSharedMemory(e)}static bufferToObject(e,t=0,s=0){return vs.toObject(e,t,s)}static objectToBuffer(e){return Ss.toBuffer(e)}static objectToTypedNodes(e){return Ss.tokTypedNodes(e)}static typedNodeToBuffer(e){return Is.toBuffer(e)}static bufferToTypedNodes(e,t=0,s=0){return vs.toTypedNodes(e,t,s)}}function Ts(e){if(!n._.sectors.get(e[0],e[1],e[2],e[3]))throw new Error(`Sector at location ${e.toString()} does not exist`);const t=ss({location:e}),s=[];t.palettes.state&&s.push(t.palettes.state.buffer),t.palettes.secondaryState&&s.push(t.palettes.secondaryState.buffer);for(const e of t.sections)"string"!=typeof e&&(ArrayBuffer.isView(e.buffers.id?.buffer)&&s.push(e.buffers.id.buffer),ArrayBuffer.isView(e.buffers.state?.buffer)&&s.push(e.buffers.state.buffer),ArrayBuffer.isView(e.buffers.mod?.buffer)&&s.push(e.buffers.mod.buffer),ArrayBuffer.isView(e.buffers.state?.buffer)&&s.push(e.buffers.state.buffer),ArrayBuffer.isView(e.buffers.light?.sun?.buffer)&&s.push((e.buffers.light?.sun).buffer),ArrayBuffer.isView(e.buffers.light?.red?.buffer)&&s.push((e.buffers.light?.red).buffer),ArrayBuffer.isView(e.buffers.light?.green?.buffer)&&s.push((e.buffers.light?.green).buffer),ArrayBuffer.isView(e.buffers.light?.blue?.buffer)&&s.push((e.buffers.light?.blue).buffer),ArrayBuffer.isView(e.buffers.secondary?.buffer)&&s.push(e.buffers.secondary.buffer),e.palettes&&(e.palettes.id&&s.push(e.palettes.id.buffer),e.palettes.state&&s.push(e.palettes.state.buffer),e.palettes.mod&&s.push(e.palettes.mod.buffer),e.palettes.secondaryState&&s.push(e.palettes.secondaryState.buffer),e.palettes.secondaryId&&s.push(e.palettes.secondaryId.buffer)));return[t,s]}async function _s(e={}){const t=new i.c;i.c.environment=o.O.isNode()?"node":"browser";let s="render";"node"==i.c.environment&&(s="server"),await a.QK.init("constructor",self,s);let g=!1;var f,m;return(0,r.A)({onSync(e){!function(e,t){st.register(e),Ge.registerCustomNode("liquid",Ct),Ge.setGeometryPalette(t.geometryPalette),Ge.registerGeometry(t.geometry),Ge.registerModels(t.models);for(const e of t.voxels)Ge.registerVoxel(new Lt(e.id,st.meshersMap.get(e.materialId),Ge.modelData.get(e.modelId),e))}(e.voxels.materials.palette,e.voxels.models),g=!0}}),a.QK.registerTask("clear-all",(()=>{n._.clearAll()})),await new Promise((e=>{const t=()=>{if(g)return e(!0);setTimeout(t,10)};t()})),function(e){a.QK.registerTask("archive-sector",(async e=>Ts(e))),a.QK.registerTask("archive-sector-binary",(async e=>{const[t]=Ts(e);try{const e=await async function(e){return await new Response(new Blob([Cs.objectToBuffer(e)]).stream().pipeThrough(new CompressionStream("gzip"))).arrayBuffer()}(t);return[e,[e]]}catch(e){console.log(t),console.error(e)}return[null,[]]})),a.QK.registerTask("import-sector",(async t=>{const s=cs(t);await e.worldThread.runTaskAsync("load-sector",[t.location,s])})),a.QK.registerTask("import-sector-binary",(async([t,s])=>{const r=cs(await async function(e,t=!1){const s=await new Response(new Blob([e]).stream().pipeThrough(new DecompressionStream("gzip"))).arrayBuffer();Cs.setUseSharedMemory(t);const r=Cs.bufferToObject(s);return Cs.setUseSharedMemory(!1),r}(s,!0));await e.worldThread.runTaskAsync("load-sector",[t,r])}))}({worldThread:t.threads.world}),a.QK.registerTask(gt.U.SyncDimension,(e=>{n._.dimensions.add(e.id)})),a.QK.registerTask(gt.U.UnSyncDimension,(e=>{})),a.QK.registerTask(gt.U.SyncSector,(e=>{n._.sectors.add(e[0][0],e[0][1],e[0][2],e[0][3],e[1])})),a.QK.registerTask(gt.U.UnSyncSector,(e=>{n._.sectors.remove(e[0],e[1],e[2],e[3])})),a.QK.registerTask(l.z.Propagation,(async e=>{const t=new c.P;t.setOrigin(e),function(e){if(!d.i.doLight)return!1;const t=n._.sectors.get(e.origin[0],e.origin[1],e.origin[2],e.origin[3]);if(!t)return console.error(`Tried running world rgb on a sector that does not exist ${e.origin.toString()}`),!1;let s=I.k.section.bounds.x+t.position[0],r=I.k.section.bounds.z+t.position[2];for(let i=0;i<t.sections.length;i++){const a=t.sections[i];if(!a)continue;U.setSection(a);let[o,n]=a.getMinMax();const l=t.position[0],d=t.position[1]+i*I.k.section.bounds.y,h=t.position[2];if(Math.abs(o)!=1/0||Math.abs(n)!=1/0)for(let t=d+o;t<=d+n;t++)for(let i=l;i<s;i++)for(let s=h;s<r;s++){const r=U.getVoxel(i,t,s);r&&!r.isAir()&&r.isLightSource()&&e.rgb.update.push(i,t,s)}}(0,u.D)(e)}(t)})),a.QK.registerTask(l.z.Explosion,(async e=>{const t=e[0],s=I.k.sector.getPosition(t[1],t[2],t[3]),r=new c.P;r.setOrigin([t[0],s.x,s.y,s.z]),N.runExplosion(r,e[1])})),a.QK.registerTask(l.z.WorldSun,(e=>{const t=I.k.sector.getPosition(e[1],e[2],e[3]),s=new c.P;s.setOrigin([e[0],t.x,t.y,t.z]),function(e){const[t,s,r,i]=e.origin,a=S.getRelative(e.origin),o=S.getAbsolute(e.origin),n=s+I.k.sector.bounds.x,l=I.k.world.bounds.MaxY,d=i+I.k.sector.bounds.z,c=e.nDataCursor.getSector(e.origin[1],e.origin[2],e.origin[3]);if(!c)return void console.warn("Could not load sector when running world sun at ",e.origin.toString());const u=o-1<0?0:o,g=c.getSection(s,u,i).getPosition()[1]+I.k.section.bounds.y;for(let e=u;e<g;e++)for(let t=s;t<n;t++)for(let s=i;s<d;s++){const r=c.getVoxel(t,e,s);if(!r)continue;const i=r.getLight();i<0||r.setLight(V.setS(15,i))}for(let e=g;e<l;e+=I.k.section.bounds.y){const t=c.getSection(s,e,i),r=t.light.length;for(let e=0;e<r;e++)t.light[e]=V.setS(15,t.light[e])}const f=o==a?a+1:a;let m=z.length;for(let t=u;t<=f;t++)for(let r=s;r<n;r++)for(let s=i;s<d;s++){const i=c.getVoxel(r,t,s)?.getLight();if(!(i&&i<0&&15!=V.getS(i)))for(let i=0;i<h.LE.length;i++){const a=h.LE[i],o=r+a[0],n=t+a[1],l=s+a[2],d=e.nDataCursor.getVoxel(o,n,l);if(!d)continue;const c=d.getLight();if(c>-1&&V.getS(c)<15){z[m++]=r,z[m++]=t,z[m++]=s;break}}}for(;z.length;){const t=z.shift(),s=z.shift(),r=z.shift(),i=e.sDataCursor.getVoxel(t,s,r)?.getLight();if(!i||i<0)continue;for(let a=0;a<5;a++){const o=t+_[a][0],n=s+_[a][1],l=r+_[a][2],d=e.nDataCursor.getVoxel(o,n,l);if(d){const e=d.getLight();e>-1&&(0,T.j4)(e,i)&&(z.push(o),z.push(n),z.push(l),d.setLight((0,T.ig)(i,e)))}}const a=e.nDataCursor.getVoxel(t,s-1,r);if(a){const e=a.getLight();e>-1&&(0,T.jg)(e,i)&&(a.isAir()?(z.push(t),z.push(s-1),z.push(r),a.setLight((0,T.Kl)(i,e))):a.isOpaque()||(z.push(t),z.push(s-1),z.push(r),a.setLight((0,T.ig)(i,e))))}}}(s)})),f=t.threads.parent,a.QK.registerTask(l.z.BuildSection,(e=>{const t=[],s=dt(e,t);s&&f.runTask("set-section",s,t)})),a.QK.registerTask(l.z.BuildSector,(e=>{const t=n._.sectors.getAt(e);if(t)for(let s=0;s<t.sections.length;s++){const r=t.sections[s];let[i,a]=r.getMinMax();if(Math.abs(i)==1/0&&Math.abs(a)==1/0)continue;const o=[],n=dt([e[0],...r.getPosition()],o);n&&f.runTask("set-section",n,o)}else console.warn("Tried building a sector that does not exists.",e)})),m={onDone(e,t){e.bounds.markSectionsAsDirty()}},a.QK.registerTask(l.z.VoxelUpdate,(async(e,t)=>{const s=await B(e);s&&m.onDone(s,t)})),a.QK.registerTask(l.z.VoxelErease,(async(e,t)=>{const s=await w(e);s&&m.onDone(s,t)})),a.QK.registerTask(l.z.VoxelPaint,(async(e,t)=>{const s=await A(e);s&&m.onDone(s,t)})),a.QK.registerTask(l.z.Generate,(e=>new Promise((t=>ut.J.generate(e,"generate",t))))),a.QK.registerTask(l.z.Decorate,(e=>new Promise((t=>ut.J.generate(e,"decorate",t))))),t}s(35112),function(e){e[e.Boolean=0]="Boolean",e[e.TypedNumber=1]="TypedNumber",e[e.TypedNumberArray=2]="TypedNumberArray",e[e.BitArray=3]="BitArray",e[e.Vector2=4]="Vector2",e[e.Vector3=5]="Vector3",e[e.Vector4=6]="Vector4"}(ws||(ws={})),s(23891),gs.bI.Uint32,gs.bI.Uint8},38e3:(e,t,s)=>{s.d(t,{LE:()=>a,vY:()=>i});const r=[],i=[[0,0],[1,0],[0,1],[1,1],[-1,0],[0,-1],[-1,-1],[1,-1],[-1,1]],a=[[0,1,0],[0,-1,0],[1,0,0],[-1,0,0],[0,0,-1],[0,0,1]];for(let e=-1;e<2;e++)for(const t of i)r.push([t[0],e,t[1]])},99196:(e,t,s)=>{s.d(t,{Hp:()=>u,Hx:()=>f,IH:()=>w,In:()=>g,Kl:()=>v,QT:()=>A,We:()=>p,Zk:()=>B,ig:()=>b,j4:()=>y,jg:()=>x,pq:()=>m,tr:()=>I});let r=2;function i(e){return 15&e}function a(e){return(240&e)>>4}function o(e){return(3840&e)>>8}function n(e){return(61440&e)>>12}function l(e,t){return-16&t|e}function d(e,t){return-241&t|e<<4}function h(e,t){return-3841&t|e<<8}function c(e,t){return-61441&t|e<<12}function u(e,t){let s=a(e),r=o(e),i=n(e),l=a(t),d=o(t),h=n(t);return s<l||r<d||i<h}function g(e,t){let s=a(e)+2,r=o(e)+2,i=n(e)+2,l=a(t),d=o(t),h=n(t);return s<=l||r<=d||i<=h}function f(e,t){let s=a(e),r=o(e),i=n(e),l=a(t),d=o(t),h=n(t);return s>=l||r>=d||i>=h}function m(e,t){let s=i(t),r=a(e)-1;r<0&&(r=0);let u=a(t);r<u&&(r=u);let g=o(e)-1;g<0&&(g=0);let f=o(t);g<f&&(g=f);let m=n(e)-1;m<0&&(m=0);let p=n(t);m<p&&(m=p);let y=0;return y=l(s,y),y=d(r,y),y=h(g,y),y=c(m,y),y}function p(e){let t=i(e),s=0;return s=d(0,s),s=h(0,s),s=c(0,s),s=l(t,s),s}function y(e,t){let s=i(e),a=i(t);return s+r<a}function x(e,t){let s=i(e),a=i(t);return 15==a?s<a:s+r<a}function v(e,t){let s=i(e),u=i(t);15==s&&(u=s),s<15&&(u=s-r);let g=a(t),f=o(t),m=n(t),p=0;return p=l(u,p),p=d(g,p),p=h(f,p),p=c(m,p),p}function b(e,t){let s=i(e)-r;s<0&&(s=0);let u=i(t);s<u&&(s=u);let g=a(t),f=o(t),m=n(t),p=0;return p=l(s,p),p=d(g,p),p=h(f,p),p=c(m,p),p}function w(e,t){return i(e)<i(t)}function A(e,t){return i(e)>=i(t)}function B(e,t){let s=i(t);return 15==s||i(e)<s}function I(e){return l(0,e)}},10008:(e,t,s)=>{s.d(t,{D:()=>a,Q:()=>o});var r=s(38e3),i=s(99196);function a(e){const t=e.rgb.update;for(;t.length;){const s=t.shift(),a=t.shift(),o=t.shift(),n=e.sDataCursor.getVoxel(s,a,o);if(!n)continue;const l=n.getLight();if(!(l<=0)){for(let n=0;n<6;n++){const d=r.LE[n][0]+s,h=r.LE[n][1]+a,c=r.LE[n][2]+o;if(!e.nDataCursor.inBounds(d,h,c))continue;const u=e.nDataCursor.getVoxel(d,h,c);if(!u)continue;const g=u.getLight();g>-1&&(0,i.In)(g,l)&&(t.push(d,h,c),u.setLight((0,i.pq)(l,g)))}e.bounds.update(s,a,o)}}}function o(e){const t=e.rgb.remove,s=e.rgb.update,a=e.rgb.removeMap,o=e.sun.updateMap;for(;t.length;){const n=t.shift(),l=t.shift(),d=t.shift();if(a.has(n,l,d))continue;a.add(n,l,d);const h=e.sDataCursor.getVoxel(n,l,d);if(!h)continue;const c=h.getLight();if(!(c<=0)){for(let a=0;a<6;a++){const h=r.LE[a][0]+n,u=r.LE[a][1]+l,g=r.LE[a][2]+d;if(!e.nDataCursor.inBounds(h,u,g))continue;const f=e.nDataCursor.getVoxel(h,u,g);if(!f)continue;const m=f.getLight(),p=f.hasRGBLight();p&&(0,i.Hp)(m,c)?(t.push(h,u,g),f.isLightSource()&&s.push(h,u,g)):p&&(0,i.Hx)(m,c)&&!o.has(h,u,g)&&(o.add(h,u,g),s.push(h,u,g))}e.bounds.update(n,l,d),h.setLight((0,i.We)(c))}}a.clear()}},91437:(e,t,s)=>{s.d(t,{a:()=>a,z:()=>o});var r=s(99196);const i=[[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],[0,1,0]];function a(e){const t=e.sun.update;for(;t.length;){const s=t.shift(),a=t.shift(),o=t.shift(),n=e.sDataCursor.getVoxel(s,a,o);if(!n)continue;const l=n.getLight();if(!(l<=0)){for(let n=0;n<5;n++){const d=i[n][0]+s,h=i[n][1]+a,c=i[n][2]+o;if(!e.nDataCursor.inBounds(d,h,c))continue;const u=e.nDataCursor.getVoxel(d,h,c);if(u){const e=u.getLight();e>-1&&(0,r.j4)(e,l)&&(t.push(d,h,c),u.setLight((0,r.ig)(l,e)))}}if(e.nDataCursor.inBounds(s,a-1,o)){const i=e.nDataCursor.getVoxel(s,a-1,o);if(i){const e=i.getLight();e>-1&&(0,r.jg)(e,l)&&(i.isAir()?(t.push(s,a-1,o),i.setLight((0,r.Kl)(l,e))):i.isOpaque()||(t.push(s,a-1,o),i.setLight((0,r.ig)(l,e))))}}e.bounds.update(s,a,o)}}}function o(e,t=!0){const s=e.sun.remove,a=e.sun.update,o=e.sun.removeMap,n=e.sun.updateMap;for(;s.length;){const t=s.shift(),l=s.shift(),d=s.shift();if(o.has(t,l,d))continue;o.add(t,l,d);const h=e.sDataCursor.getVoxel(t,l,d);if(!h)continue;const c=h.getLight();if(!(c<=0)){for(let o=0;o<5;o++){const h=i[o][0]+t,u=i[o][1]+l,g=i[o][2]+d;if(!e.nDataCursor.inBounds(h,u,g))continue;const f=e.nDataCursor.getVoxel(h,u,g);if(f){const e=f.getLight();e>0&&((0,r.IH)(e,c)?s.push(h,u,g):(0,r.QT)(e,c)&&!n.has(h,u,g)&&(n.add(h,u,g),a.push(h,u,g)))}}if(e.nDataCursor.inBounds(t,l-1,d)){const i=e.nDataCursor.getVoxel(t,l-1,d);if(i){const e=i.getLight();e>0&&((0,r.Zk)(e,c)?s.push(t,l-1,d):(0,r.QT)(e,c)&&!n.has(t,l-1,d)&&(n.add(t,l-1,d),a.push(t,l-1,d)))}}e.bounds.update(t,l,d),h.setLight((0,r.tr)(c))}}o.clear()}},36603:(e,t,s)=>{s.d(t,{P:()=>u});var r=s(48860),i=s(99673),a=s(62312),o=s(75438);class n{_map=[];get size(){return this._map.length}origin=i.Az.Create();start(e,t,s){this._map.length=0,this.origin.x=e,this.origin.y=t,this.origin.z=s}has(e,t,s){return void 0!==this._map[i.Az.HashXYZ(e-this.origin.x,t-this.origin.y,s-this.origin.z)]}add(e,t,s){this._map[i.Az.HashXYZ(e-this.origin.x,t-this.origin.y,s-this.origin.z)]=!0}delete(e,t,s){this._map[i.Az.HashXYZ(e-this.origin.x,t-this.origin.y,s-this.origin.z)]=void 0}clear(){this._map.length=0}}const l=i.Az.Create(-1/0,-1/0,-1/0),d=i.Az.Create(1/0,1/0,1/0),h=i.Az.Create();class c{_task;min=i.Az.Clone(d);max=i.Az.Clone(l);dimension="main";constructor(e){this._task=e}start(e){this.dimension=e||"main",i.Az.Copy(this.min,d),i.Az.Copy(this.max,l)}update(e,t,s){e<this.min.x&&(this.min.x=e),t<this.min.y&&(this.min.y=t),s<this.min.z&&(this.min.z=s),e>this.max.x&&(this.max.x=e),t>this.max.y&&(this.max.y=t),s>this.max.z&&(this.max.z=s)}getSections(){const e=a.k.section.getPosition(this.min.x-1,this.min.y-1,this.min.z-1,h),t=e.x,s=e.y,r=e.z,i=a.k.section.getPosition(this.max.x+1,this.max.y+1,this.max.z+1,h),o=i.x,n=i.y,l=i.z,d=[];for(let e=t;e<=o;e+=a.k.section.bounds.x)for(let t=s;t<=n;t+=a.k.section.bounds.y)for(let s=r;s<=l;s+=a.k.section.bounds.z)this._task.nDataCursor.inBounds(e,t,s)&&d.push([e,t,s]);return d}markSectionsAsDirty(){const e=a.k.section.getPosition(this.min.x-1,this.min.y-1,this.min.z-1,h),t=e.x,s=e.y,r=e.z,i=a.k.section.getPosition(this.max.x+1,this.max.y+1,this.max.z+1,h),n=i.x,l=i.y,d=i.z;for(let e=t;e<=n;e+=a.k.section.bounds.x)for(let t=r;t<=d;t+=a.k.section.bounds.z)for(let r=s;r<=l;r+=a.k.section.bounds.y){if(!a.k.world.inBounds(e,r,t))continue;const s=o._.sectors.get(this.dimension,e,r,t);s&&s.getSection(e,r,t).setDirty(!0)}}}class u{flow=new g;rgb=new f;sun=new f;bounds=new c(this);sDataCursor=new r.p;nDataCursor=new r.p;origin;setOrigin(e){this.sDataCursor.setFocalPoint(...e),this.nDataCursor.setFocalPoint(...e),this.origin=e,this.rgb.removeMap.start(e[1],e[2],e[3]),this.sun.removeMap.start(e[1],e[2],e[3]),this.rgb.updateMap.start(e[1],e[2],e[3]),this.sun.updateMap.start(e[1],e[2],e[3]),this.flow.update.map.start(e[1],e[2],e[3]),this.flow.remove.map.start(e[1],e[2],e[3]),this.flow.remove.noRemoveMap.start(e[1],e[2],e[3]),this.bounds.start(e[0]),this.clear()}clear(){this.rgb.clear(),this.sun.clear(),this.flow.clear()}}class g{update={queue:[],map:new n};remove={queue:[],map:new n,noRemoveMap:new n};clear(){this.update.queue.length=0,this.update.map.clear(),this.remove.queue.length=0,this.remove.map.clear(),this.remove.noRemoveMap.clear()}}class f{update=[];remove=[];removeMap=new n;updateMap=new n;clear(){this.update.length=0,this.remove.length=0,this.removeMap.clear(),this.updateMap.clear()}}},66454:(e,t,s)=>{s.d(t,{T:()=>u});var r=s(56417),i=s(83651),a=s(50327),o=s(20650),n=s(6694),l=s(36603),d=s(10008),h=s(91437);const c=new a.$;class u extends i.l{constructor(){super(),o.J._brushes.push(this)}requestsId;tasks=new l.P;start(e,t,s,r){return this.dataCursor.setFocalPoint(e,t,s,r),this.tasks.setOrigin([e,t,s,r]),this.dimension=e,this.x=t,this.y=s,this.z=r,this}paint(){let e=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!e){if(""!=this.requestsId)return r.o.addToRequest(this.requestsId,[this.dimension,this.x,this.y,this.z],this.voxelCursor.getRaw()),this;throw new Error(`Tried painting in an unloaded location ${[this.dimension,this.x,this.y,this.z].toString()}`)}const t=e.getLight();return(t>0||!e.isAir())&&(this._erase(),e.setLight(t<0?0:t),c.hasRGBLight(t)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,d.Q)(this.tasks)),c.hasSunLight(t)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,h.z)(this.tasks))),this._paint(),this.tasks.bounds.update(this.x,this.y,this.z),this}getUpdatedSections(){const e=this.tasks.bounds.getSections();return this.tasks.bounds.start(),e}update(){let e=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!e)return!1;const t=e.getLight();e.updateVoxel(2),c.hasRGBLight(t)&&this.tasks.rgb.update.push(this.x,this.y,this.z),c.hasSunLight(t)&&this.tasks.sun.update.push(this.x,this.y,this.z),this.tasks.bounds.update(this.x,this.y,this.z)}erase(){let e=this.dataCursor.getVoxel(this.x,this.y,this.z);if(!e)return this;const t=e.getLight();return this._erase(),e=this.dataCursor.getVoxel(this.x,this.y,this.z),e.setLight(t>0?t:0),c.hasRGBLight(t)&&(this.tasks.rgb.remove.push(this.x,this.y,this.z),(0,d.Q)(this.tasks)),c.hasSunLight(t)&&(this.tasks.sun.remove.push(this.x,this.y,this.z),(0,h.z)(this.tasks)),this.tasks.bounds.update(this.x,this.y,this.z),this}runUpdates(){(0,d.D)(this.tasks),(0,h.a)(this.tasks),this.tasks.rgb.removeMap.clear(),this.tasks.sun.removeMap.clear()}worldAlloc(e,t){return n.c.instance.threads.world.runTaskAsync("world-alloc",[this.dimension,e,t])}worldDealloc(e,t){return n.c.instance.threads.world.runTaskAsync("world-dealloc",[this.dimension,e,t])}}},56417:(e,t,s)=>{s.d(t,{o:()=>l});var r=s(62312),i=s(83651),a=s(6694),o=s(75438);const n=new i.l;n.voxelCursor;class l{static MAX_ATTEMPTS=100;static _requests=new Map;static registerRequest(e){const t=e.toString();return this._requests.set(t,{attempts:0,sections:new Map,dimension:e[0],voxels:[]}),t}static addToRequest(e,t,s){if(t[2]<r.k.world.bounds.MinY||t[2]>=r.k.world.bounds.MaxY)return!1;const i=this._requests.get(e);if(!i)return;if(!o._.sectors.get(t[0],t[1],t[2],t[3])){const e=r.k.sector.getPosition(t[1],t[2],t[3]),s=r.k.hash.hashVec3(e);i.sections.has(s)||(a.c.instance.threads.world.runTask("add-sector",[i.dimension,e.x,e.y,e.z]),i.sections.set(s,[e.x,e.y,e.z]))}const[n,l,d,h]=t;i.voxels.push([l,d,h,s])}static attemptRequestFullFill(e){const t=this._requests.get(e);if(!t||!t.voxels.length)return!0;let s=!0;for(const[e,i]of t.sections)r.k.world.inBounds(i[0],i[1],i[2])&&(o._.sectors.get(t.dimension,i[0],i[1],i[2])||(s=!1,a.c.instance.threads.world.runTask("add-sector",[t.dimension,i[0],i[1],i[2]])));return s?(n.stop(),this._requests.delete(e),!0):(t.attempts++,t.attempts>=this.MAX_ATTEMPTS&&(console.error("World gen requests cancled after max attempts",t),this._requests.delete(e),!0))}}},20650:(e,t,s)=>{s.d(t,{J:()=>a});var r=s(56417),i=s(66454);class a{static worldGen=null;static register=r.o;static _brushes=[];static setWorldGen(e){this.worldGen=e}static async generate(e,t,s){if(!this.worldGen)throw new Error("A World Generator must be set.");const i=r.o.registerRequest(e[0]);for(const e of this._brushes)e.requestsId=i;if("generate"==t&&await this.worldGen.generate(e),"decorate"==t&&await this.worldGen.decorate(e),r.o.attemptRequestFullFill(i))s();else{const e=()=>{r.o.attemptRequestFullFill(i)?s():setTimeout(e,10)};e()}}static getBrush(){return new i.T}}},85212:(e,t,s)=>{s.d(t,{A8:()=>n,JU:()=>a,Tv:()=>i,pL:()=>l,rW:()=>d,wu:()=>o});var r=s(29105);function i(e,t){const s=Math.floor(t/8),i=t%8;return(0,r.x3)(e[s],i,1)}function a(e,t,s){const i=Math.floor(t/8),a=t%8;e[i]=(0,r.Lm)(e[i],a,1&s,1)}function o(e,t){return(0,r.x3)(e[t/2|0],t%2==0?4:0,4)}function n(e,t,s){const i=t/2|0;e[i]=(0,r.Lm)(e[i],t%2==0?4:0,s,4)}function l(e,t){return(0,r.x3)(e[t/4|0],t%4*2,2)}function d(e,t,s){const i=t/4|0;e[i]=(0,r.Lm)(e[i],t%4*2,s,2)}},15741:(e,t,s)=>{s.d(t,{h:()=>r});class r{_count=0;_palette=[];_map={};get size(){return this._count}constructor(e){if(e){let t=e.length;for(let s=0;s<t;s++)this.register(e[s])}}register(e){const t=this._count;return this._palette[t]=e,this._map[e]=t,this._count++,t}get(){return this._palette}getMap(){return this._map}isRegistered(e){return void 0!==this._map[e]}getId(e){return this._map[e]}getValue(e){return this._palette[e]}}},48860:(e,t,s)=>{s.d(t,{p:()=>l});var r=s(99673),i=s(69224),a=s(62312);let o=[];const n=r.Az.Create();class l{sectorCursors=new Map;origin={x:0,y:0,z:0};dimension="";setFocalPoint(e,t,s,r){const i=a.k.sector.getPosition(t,s,r,n);for(const[e,t]of this.sectorCursors)for(const[e,s]of t)o.push(s);this.sectorCursors.clear(),this.dimension=e,this.origin.x=i.x/a.k.sector.bounds.x,this.origin.y=i.y/a.k.sector.bounds.y,this.origin.z=i.z/a.k.sector.bounds.z}inBounds(e,t,s){return a.k.world.inBounds(e,t,s)}getSector(e,t,s){if(!this.inBounds(e,t,s))return null;const r=a.k.sector.getPosition(e,t,s,n),l=r.x/a.k.sector.bounds.x-this.origin.x,d=r.z/a.k.sector.bounds.z-this.origin.z;let h=this.sectorCursors.get(l),c=h?.get(d);if(!c){if(c=o.length?o.shift():new i.j,!c.setSector(this.dimension,r.x,r.y,r.z))return o.push(c),null;h||(h=new Map,this.sectorCursors.set(l,h)),h.set(d,c)}return c}getVoxel(e,t,s){const r=this.getSector(e,t,s);return r?r.getVoxel(e,t,s):null}}}},n={};function l(e){var t=n[e];if(void 0!==t)return t.exports;var s=n[e]={exports:{}};return o[e].call(s.exports,s,s.exports,l),s.exports}l.m=o,l.x=()=>{var e=l.O(void 0,[289,147,433],(()=>l(78872)));return l.O(e)},e="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",t="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",s="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",r=e=>{e&&e.d<1&&(e.d=1,e.forEach((e=>e.r--)),e.forEach((e=>e.r--?e.r++:e())))},l.a=(i,a,o)=>{var n;o&&((n=[]).d=-1);var l,d,h,c=new Set,u=i.exports,g=new Promise(((e,t)=>{h=t,d=e}));g[t]=u,g[e]=e=>(n&&e(n),c.forEach(e),g.catch((e=>{}))),i.exports=g,a((i=>{var a;l=(i=>i.map((i=>{if(null!==i&&"object"==typeof i){if(i[e])return i;if(i.then){var a=[];a.d=0,i.then((e=>{o[t]=e,r(a)}),(e=>{o[s]=e,r(a)}));var o={};return o[e]=e=>e(a),o}}var n={};return n[e]=e=>{},n[t]=i,n})))(i);var o=()=>l.map((e=>{if(e[s])throw e[s];return e[t]})),d=new Promise((t=>{(a=()=>t(o)).r=0;var s=e=>e!==n&&!c.has(e)&&(c.add(e),e&&!e.d&&(a.r++,e.push(a)));l.map((t=>t[e](s)))}));return a.r?d:o()}),(e=>(e?h(g[s]=e):d(u),r(n)))),n&&n.d<0&&(n.d=0)},i=[],l.O=(e,t,s,r)=>{if(!t){var a=1/0;for(h=0;h<i.length;h++){for(var[t,s,r]=i[h],o=!0,n=0;n<t.length;n++)(!1&r||a>=r)&&Object.keys(l.O).every((e=>l.O[e](t[n])))?t.splice(n--,1):(o=!1,r<a&&(a=r));if(o){i.splice(h--,1);var d=s();void 0!==d&&(e=d)}}return e}r=r||0;for(var h=i.length;h>0&&i[h-1][2]>r;h--)i[h]=i[h-1];i[h]=[t,s,r]},l.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return l.d(t,{a:t}),t},l.d=(e,t)=>{for(var s in t)l.o(t,s)&&!l.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},l.f={},l.e=e=>Promise.all(Object.keys(l.f).reduce(((t,s)=>(l.f[s](e,t),t)),[])),l.u=e=>e+".bundle.js",l.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),l.p="/",(()=>{var e={873:1};l.f.i=(t,s)=>{e[t]||importScripts(l.p+l.u(t))};var t=self.webpackChunkdivinecraft=self.webpackChunkdivinecraft||[],s=t.push.bind(t);t.push=t=>{var[r,i,a]=t;for(var o in i)l.o(i,o)&&(l.m[o]=i[o]);for(a&&a(l);r.length;)e[r.pop()]=1;s(t)}})(),a=l.x,l.x=()=>Promise.all([289,147,433].map(l.e,l)).then(a),l.x()})();